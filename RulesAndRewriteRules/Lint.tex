% $Author: jannik $
% $Date: 2010-05-13 23:11:04 +0200 (Thu, 13 May 2010) $
% $Revision: 32942 $

% HISTORY:
% 2012-11-11: Stephane is doing a pass after Andre's one.

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================

%=================================================================


%\chapter{Validation et Transformations de code automatique en Pharo}
\chapter{SmallLint: static analysis in Pharo}


Being able to check that the code of your application follows certain rules is important to control its quality. Pharo offers SmallLint a tool originally developed by John Brant and Don Roberts to identify several families of problems that code may exhibit. SmallLint defines a list of static analyses grouped by topics and that you can run automatically on your code. In addition, in Pharo, package meta-data supports the application of SmallLint by letting the programmer flagging irrelevant or false positives. 
In this chapter we will @@





\section{Ensuring Quality}

%Agile, Tests, Checking
%Adapted from the paper the Smells in JOT 2012
Good design practices are fundamental requisites to address software inherent properties (e.g., complexity, conformity, changeability). But smells are often introduced unintentionally by developers during early software development or software maintenance.

For example, a software designer may adopt well-known established practices during initial design; however, such design may indicate certain structural deficiencies or smells that have arose during the process. 
Also, software developers who are tasked with software maintenance (e.g., develop new features or fix bugs) may introduce smells into the code.  It is important in both cases to address the smells as to reduce the technical debt and maintain a high structural quality of the software.
Awareness of smells enable designers to make well-informed design decisions and developers to avoid introducing smells in the software. 

As defined by Martin Fowler, smells are certain structures in the code that suggest (sometimes they scream for) the possibility of refactoring.
Basically, three types of smells can be found in source code at different levels: architectural, design and implementation. The architectural level includes smells such as "god package" and "cyclical dependency between packages". The design (or micro-architectural) level includes smells such as "cyclic hierarchy" and "large abstraction". Finally, the implementation level includes smells such as "improper name length" and "variables having constant value". Smalllint aims the detection of smells at design and implementation level, so this chapter is limited to such types of smells.

%This section can be automatically exported from the comments in #longDescription in each Smalllint rule:
%Gofer new
%    squeaksource: 'PharoTaskForces';
%   package: 'Manifest-Core';
%    package: 'Manifest-Support';
%    load.
%SimpleLatexDoc exportLatexDocForRules


\section{Existing SmallLint Rules}\label{existingRules}
SmallLint is a tool that analyses Pharo code and identifies bugs, design problems and other mismatches to recommanded idioms. 

\input{SmallLint-rules}





\section{Using Code Critics}

You can invoke the Code Critic Browser via the Tools menu. We will execute it on one of our project Kozen whose purpose is to generate static web page based on scientific publications. We started from a project on which we never run the rules. 
\begin{figure}[h]
\centering
\includegraphics[width=6cm]{selectingPackage}\includegraphics[width=6cm]{selectingPackage2} 
\end{figure}


\paragraph{Selecting Rules.}
Once you have selected the packages on which you want to run the rules, you can select them as shown in Figure~\ref{ruleselection}. Rules are sorted in different categories as explained in Section~\ref{existingRules}. By default running all the rules is a good idea.


\begin{figure}[h]
\centering
\includegraphics[width=6cm]{selectingRules}
\caption{Selecting rules. By default running all the rules is a good idea. \label{ruleselection}}
\end{figure}


\paragraph{First look at Results.} Once the rules are run you get a browser showing you the results as shown in Figure~\ref{unclassified}. Once the rules are run, we obtain a set of rule violations, we have several possibilities:

\begin{itemize}
\item \emph{Addressing the problem}. In such a case it can be wise to rerun the rule to verify that it has been addressed.

\item \emph{Marking the problem as a ToDo}. The point here is that tagging a violation as to-do makes sure that the violation will not show up as red warning when rules are checked again later. To-dos indicate that the package developer knows that there is an issue that it should be fixed later. 
Having Todos is a nice feature because it lets the developer decide when to address a problem while avoiding the tools to always report it as a problems. 

\item \emph{Marking the violation as a tool error}. Indeed a rule may be wrong or irrelevant. We call such error a false positive. Marking a violation as a false positive makes sure that the next time the rule execution will be executed
\end{itemize}

With the Critics Browser we payed attention that once a developer runs and evaluates the violations (\ie addressing, marking them as todos or false positives), he can be sure that a new execution of the rules on the same code will not report again the same problems. 


The Critics Browser shows the results are grouped by rule kinds. 
The top level label labelled \ct{selected Rules (FP: 0, ToDo: 0, Total: 326} means the following: we got a total of 326 rule violations. Since we just started to check a new project, we did not mark any violations as false positive\footnote{A false positive is said to a violation that was detected by a tool but that was not true.}, this is why we have FP: 0, and since we did not flag violations as point to address in the future we have \ct{ToDo: 0}.


Figure~\ref{unclassified} shows that in the rules related to style issues, the Kozen packages got two badly classified methods. Since moving the methods to a correct method category is easy, we did it and run the rules. We obtain then the situation described by Figure~\ref{reapplying}.

The Critics Browser shows the rules on the left pane. When one rule is selected, the violations appear in the right pane. You can search by typing in the top right input field. The pane at the bottom shows either the rule description or the entity exhibiting the violation. 

\begin{figure}[h]
\centering
\includegraphics[width=8cm]{UnclassifiedMethods}
\caption{Browsing rule results. Two methods are not well classified in the class KzMenuInfoBoySite.\label{unclassified}}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=8cm]{ReapplyingTheRulesAfterAChange}
\caption{Addressing an issue on the spot and running the rules once again\label{reapplying}}
\end{figure}





A more interesting case is the 'Bugs' category as shown by Figure~\ref{}



\paragraph{Banning a complete rule.}

\begin{figure}[h]
\centering
\includegraphics[width=6cm]{LookingAtBugs}
\caption{Looking at the 'Bugs' rule category.}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=6cm]{BanningTimeStampRules}
\caption{Banning the rule for the complete selected packages.}
\end{figure}


\paragraph{Banning a single critic.}

\begin{figure}[h]
\centering
\includegraphics[width=6cm]{OneUndeclaredRefence}\includegraphics[width=6cm]{BanningOneViolation}
\caption{Looking at the undeclared variable bug (left) and Banning one single critic (right)}
\end{figure}














\section{Defining Your Own Rules}

\subsection{Block Rules}




Block rules use the Smalltalk reflective API. Block rules rules can be created to look for methods that should be not invoked, to check style consistence such capitalization and lenght of classes variables, to check method and class size, to look for classes and variables not referenced or not defined, to search classes not commented, to look for instance variables defined in all subclasses, among others. More specifically, every thing that is possible to do using the Smalltalk reflective API can be implemented as a block rule. This includes having easy access to superclasses, subclasses, methods, variables, arguments, comments, invocations, etc.

TODO

- Such kind of rules must extend the class RBBlockLintRule.

- Two levels: class and method.

- Class level rules must implement the method \#checkClass: and method level rules must implemente the method \#checkMethod:

- Example

\subsection{Abstract Syntax Tree-Based Rules}

\subsection{Defining a simple rules}

\section{Conclusion}







\section{Junk}

\section{ Analyse qualitative de code avec SmallLint}

 SmallLint est un outil d'analyse de code. Il permet d'identifier une soixantaine de
probl\`emes possibles allant du simple bogue, à la pr\'evision de bogue,
en passant par la d\'etection de code inutile ou l'identification de
m\'ethodes trop longues. SmallLint met en \'evidence des probl\`emes au
niveau de m\'ethodes ou de classes qui utilisent l'h\'eritage, et d\'etecte
certaines erreurs.  

Pour ouvrir cet outil, ex\'ecutez l'expression
LintDialog open ; vous obtenez une fenêtre comme celle qui est
pr\'esent\'ee figure  qui montre le r\'esultat de l'application de
quelques r\`egles sur les classes.


@@ here rules@@
 Pour vous en servir,
vous devez choisir les jeux de r\`egles que vous souhaitez appliquer
(dans le panneau, en haut à gauche), s\'electionner les r\`egles (panneau,
en bas à gauche), les cat\'egories (panneau du milieu), les classes
(panneau de droite), et finalement presser « Run ». Une fois que tout
est affich\'e, vous pouvez avoir acc\`es aux m\'ethodes suspectes en
cliquant sur les lignes qui d\'etaillent le r\'esultat.  Certaines
soci\'et\'es imposent aux d\'eveloppeurs d'invoquer syst\'ematiquement
SmallLint avant de d\'elivrer leur code. Notons que les r\`egles peuvent
en être particularis\'ees et qu'il est possible d'en ajouter de
nouvelles au jeu existant. La d\'efinition des r\`egles utilise la
reconnaissance de code (pattern matching) propos\'e par le RewriteTool
que nous allons maintenant \'etudier.

\section{Identification de code avec RewriteTool}

RewriteTool est un outil de r\'ecriture de code bas\'e sur la d\'efinition
de reconnaissance de formes (pattern matching), appliqu\'ee sur des
arbres de syntaxes abstraites. Une documentation plus compl\`ete est
disponible à http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/
Rewrite.html.

Il semble que Squeak ne dispose pas actuellement d'interface graphique
pour la r\'ecriture du code, mais uniquement pour identifier des
morceaux de code.


Cet outil de r\'ecriture de code est particuli\`erement utile lorsqu'on
doit transformer d'une mani\`ere r\'ep\'etitive du code. On peut repr\'esenter
dans les sch\'emas (patterns) de reconnais- sance des variables, des
listes, des instructions r\'ecursives et des litt\'eraux.

\begin{itemize}
\item	Variable. Un sch\'ema peut contenir des variables en utilisant
  le backquote ou accent grave. Ainsi, \ct{`key} repr\'esente n'importe
  quelle variable, mais pas une expression.

\item Liste. Pour repr\'esenter une expression potentiellement
  complexe, on utilise \ct{@} qui caract\'erise une liste. Ainsi, `@key
  peut repr\'esenter aussi bien une variable simple comme temp qu'une
  expression comme \ct{(aDict at: self keyForDict)}. Par exemple, | `@Temps
  | reconnaît une liste de variables temporaires. Le point . reconnaît
  une instruction dans une s\'equence de code.\ct{`@.Statements}
  reconnaît une liste d'instructions. Par exemple, foo `@message:
  \ct{`@args} reconnaît n'importe quel message envoy\'e à foo.


\item R\'ecursion. Pour que la reconnaissance s'effectue aussi à
  l'int\'erieur de l'expression, il faut doubler la quote. La seconde
  quote repr\'esente la r\'ecursion du sch\'ema cherch\'e. Ainsi,
  \ct{``@object foo} reconnaît foo, à quelque objet qu'il soit envoy\'e,
  mais observe \'egalement pour chaque reconnaissance si une
  reconnaissance est possible dans la partie repr\'esent\'ee par la
  variable \ct{``@object}.

\item	Litt\'eraux. \ct{\\#} repr\'esente les litt\'eraux ; ainsi, \ct{`\\#literal}
  reconnaît n'importe quel litt\'eral, par exemple 1, \ct{\\#()}, "unechaine"
  ou \ct{\\#unSymbol}.
\end{itemize}

\section{Des exemples d'identification de sch\'emas}

Si l'on veut identifier les expressions de type
aDict at: aKey ifAbsent: aBlock dans lesquelles les variables peuvent être des expressions compos\'ees, on \'ecrit l'expression
suivante :
\ct{``@aDict at: ``@aKey ifAbsent: ``@aBlock.}
Une telle expression identifie par exemple les expressions suivantes :

\begin{code}{}
instVarMap at: aClass name ifAbsent: [oldClass instVarNames]
deepCopier references at: argumentTarget ifAbsent: [argumentTarget]
bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]
object at: (keyArray at: selectionIndex) ifAbsent: [nil]
\end{code}

Comme l'interface en Squeak ne permet pas encore de s\'electionner les
classes sur lesquelles on veut travailler, le syst\`eme analyse les 1
934 classes et quelque 42 869 m\'ethodes qui sont disponibles dans la
distribution de base, ce qui peut sensiblement ralentir le traitement.

Voici quelques exemples d'
expressions qui pourraient être avantageusement transform\'ees :

\begin{code}{}
| `@Temps | ``@.Statements. ``@Boolean ifTrue: [^false]. ^true
| `@Temps | ``@.Statements. ^``@Boolean not
``@object not ifTrue: ``@block
``@object ifFalse: ``@block.
\end{code}


% RBParseTreeRewriter new
% 	replace: '``@aDictionary at: ``@key
% 		ifAbsent:
% 			[| `@Temps |
% 			``@.Statements.
% 			``@aDictionary at: ``@key put: ``@value]' with: '``@aDictionary at: ``@key
% 		ifAbsentPut:
% 			[| `@Temps |
% 			``@.Statements.
% 			``@value]';
% 	yourself

\begin{code}{}
rule := RBUnderscoreAssignmentRule new.
environment := BrowserEnvironment new forPackageNames: \#('PackageA'
'PackageB' ...).
SmalllintChecker runRule: rule onEnvironment: environment.
rule open
\end{code}

\begin{code}{}
ORLintBrowser
	openRule: (RBCompositeLintRule rules: (RBCompositeLintRule
rulesGroupedFor: RBSpellingRule) name: 'Spelling')
	environment: (BrowserEnvironment new forPackageNames: \#('Kernel'
'Collections-Abstract'))
\end{code}


\end{document}


%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: Lint.tex
%%% TeX-PDF-mode: t
%%% End:
