% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% HISTORY:
% 2008-01-19 - Stef started
% 2008-12-26 - Jannick Menanteau added text
% version of max
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
%% to do check the difference between the previous version and what max did
% 2011-09-12 - Stef checked max changes and did a large pass.

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Files with FileSystem }\chalabel{filesystem}
\chapterauthor{Max Leske}

Filesystem is the new file system library for Pharo. It is integrated in the system since Pharo 2.0. 
Filesystem has been originally developed by Colin Putney. Camillo Bruni made some changes to the original design or API and integrated it into Pharo with the help of Esteban Lorenzano and Guillermo Polito - This is this version that we describe in this chapter. This chapter is a quick start that shows how to get started. 

\section{Getting started}
The framework supports different kinds of filesystems that can be used interchangeably and that can transparently work with each other. The most obvious one is the filesystem on your hard disk. We are going to work with that one for now. 
\ct{FileSystem} is the factory to access different filesystem. 

Sending the message \mthind{FileSystem}{disk} to \ct{FileSystem}, returns a file system as on your physical hard-drive. Another less used possibility is \ct{memory} to create a file system at the system of the image. 

\begin{code}{}
| working |
working := FileSystem disk workingDirectory.
--> /Users/ducasse/Workspace/FirstCircle//Pharo/20

working := FileSystem disk workingDirectory class 
--> FileReference
\end{code} 

The message \mthind{FileReference}{workingDirectory} above returns a reference to the working directory. References are instances of the class \ct{FileReference}.  As we will see references are the central objects of the framework and provide the primary mechanisms for working with files and directories. 

Filesystem defines four classes that are important for the end-user: \ct{FileSystem}, \ct{FileReference}, \ct{FileLocator}, and \ct{FileSystemDirectoryEntry}. These classes are grouped in the 'FileSystem-Core-Public' category.

You should do not use platform specific classes such as \ct{UnixStore} or \ct{WindowsStore}, these are internal classes. All code snippets below work on \ct{FileReference} instances.


\section{Navigating the Filesystem}

Now let's do some more interesting things. To list the immediate children of your working directory, execute the following expression:

\begin{code}{}
| working |
working := FileSystem disk workingDirectory.
working children.
--> anArray(file:///Users/ducasse/Workspace/FirstCircle/Pharo/20/.DS_Store file:///Users/ducasse/Workspace/FirstCircle/Pharo/20/ASAnimation.st ...)
\end{code} 

Notice that \mthind{FileReference}{children} returns the direct files and folders. 
To recursively access all the children of the current directory you should use the message \mthind{FileReference}{allChildren} as follows:

\begin{code}{}
working allChildren.
\end{code}

To find all st files in the working directory, simply execute:

\begin{code}{}
working allChildren select: [ :each | each basename endsWith: 'st' ]
\end{code} 
 
Use the slash operator to obtain a reference to a specific file or directory within your working directory:

\begin{code}{}
| working cache |
working := FileSystem disk workingDirectory.
cache := working / 'package-cache'.
\end{code} 

Navigating back to the parent is easy using the \mthind{FileReference}{parent} message:

\begin{code}{}
| working cache |
working := FileSystem disk workingDirectory.
cache := working / 'package-cache'.
parent := cache parent.
parent = working			
--> true
\end{code}

You can check for various properties of the cache directory by executing the following expressions:

\begin{code}{}
cache exists.				--> true
cache isSymLink.				--> false
cache isFile.				--> false
cache isDirectory.			--> true
cache basename.			--> 'package-cache'
cache fullName           
  --> '/Users/ducasse/Workspace/FirstCircle/Pharo/20/package-cache'
cache parent fullName    
  --> '/Users/ducasse/Workspace/FirstCircle/Pharo/20/'
\end{code}
 


The methods \mthind{FileReference}{exists}, \mthind{FileReference}{isFile}, \mthind{FileReference}{isDirectory}, and  \mthind{FileReference}{basename} are defined on the \ct{FileReference} class. Notice that there is no message to get 
the path without the basename and that the idiom is to use \ct{parent fullName} to obtain it.
The message \ct{path} returns a Path object which is internally used by FileSystem. You normally do not to use such objects. 
  
Note that FileSystem does not really distinguish between files and folders which often leads to cleaner code and can be seen as an application of the composite design patterns.   
  
\paragraph{Querying file entry status.}
To get additional information about a filesystem entry, we should get an \ct{FileSystemDirectoryEntry} using the message \mthind{FileSystemDirectoryEntry}{entry}. Note that you can access the file permissions. Here are some examples:

\begin{code}{}
cache entry creation.		-->  2012-04-25T15:11:36+02:00
cache entry creationTime -->  2012-04-25T15:11:36+02:00
cache entry creationSeconds -->  3512812296 2012-08-02T14:23:29+02:00
cache entry modificationTime -->  2012-08-02T14:23:29+02:00
cache entry size.			--> 0 (directories have size 0)
cache entry permissions		-->  rwxr-xr-x
cache entry permissions class		-->  FileSystemPermission
cache entry permissions isWritable --> true
cache entry isFile			--> false
cache entry isDirectory 		--> true
\end{code} 


\paragraph{Locations.}
The framework also supports locations, late-bound references that point to a file or directory. When asking to perform a concrete operation, a location behaves the same way as a reference. Here are some  locations.

\begin{code}{}
FileLocator desktop.
FileLocator home.
FileLocator imageDirectory.
FileLocator vmDirectory.
\end{code} 

If you save a location with your image and move the image to a different machine or operating system, a location will still resolve to the expected directory or file. Note that some of them are still in flux because depending on specific VM functionalities. 

\section{Opening read and write Streams}
To open a file-stream on a file, just ask the reference for a read- or write-stream using the message \ct{writeStream} or \ct{readStream} as follows:

\begin{code}{}
| working stream |
working := FileSystem disk workingDirectory.
stream := (working / 'foo.txt') writeStream.
stream nextPutAll: 'Hello World'.
stream close.
stream := (working / 'foo.txt') readStream.
stream contents.			--> 'Hello World'
stream close.
\end{code}

Please note that \ct{writeStream} overrides any existing file and \ct{readStream} throws an exception if the file does not exist. There are also short forms available that eliminate the need to close a stream manually:

\begin{code}{}
| working  |
working := FileSystem disk workingDirectory.
working / 'foo.txt' writeStreamDo: [ :stream | stream nextPutAll: 'Hello World' ].
working / 'foo.txt' readStreamDo: [ :stream | stream contents ].
\end{code}


\begin{code}{}
| stream |
stream := FileSystem disk openFileStream: 'authors.txt' writable: true.
stream nextPutAll: 'stephane alexandre damien jannik'.
	
| working |
working := FileSystem disk workingDirectory.
working / 'authors.txt' readStreamDo: [ :stream | stream contents ]. 
   --> 'stephane alexandre damien jannik'
   
FileSystem disk workingDirectory / 'authors.txt' 
	writeStreamDo: [ :stream | stream nextPutAll: 'andrew oscar'].

| working |
working := FileSystem disk workingDirectory.
working / 'authors.txt' readStreamDo: [ :stream | stream contents ]. 
	--> 'andrew oscarxandre damien jannik'
\end{code}

Have a look at the streams protocol of \ct{FileReference} for other convenience methods.

\section{Renaming, Copying and Deleting Files and Directories}

You can also copy and rename files using the methods \ct{copyTo:} and \ct{renameTo:}.

\begin{code}{}
| working |
working := FileSystem disk workingDirectory.
working / 'foo.txt' writeStreamDo: [ :stream | stream nextPutAll: 'Hello World' ].
working / 'foo.txt' copyTo: (working / 'bar.txt').

| working  |
working := FileSystem disk workingDirectory.
working / 'bar.txt' readStreamDo: [ :stream | stream contents ].
-->  'Hello World'

| working |
working := FileSystem disk workingDirectory.
working / 'foo.txt' !\textbf{renameTo:}! 'skweek.txt'.

| working  |
working := FileSystem disk workingDirectory.
working / 'skweek.txt' readStreamDo: [ :stream | stream contents ]. 
-->  'Hello World'
\end{code} 



To create a directory use the message \mthind{FSReference}{createDirectory}:

\begin{code}{}
| working  |
working := FileSystem disk workingDirectory.
backup := working / 'cache-backup'.
backup createDirectory.
backup isDirectory.
	--> true
back children.
	--> #()
\end{code} 

To then you can  copy the contents of the complete package-cache to that directory simply use \mthind{FileReference}{copyAllTo:}:

\begin{code}{}
cache copyAllTo: backup.
\end{code}

Note that the target directory will be automatically created if it was not there before.


To delete a single file, use the message \mthind{FileReference}{delete}:
\begin{code}{}
 (working / 'bar.txt') delete.
\end{code}

To delete a complete directory tree use \mthind{FileReference}{deleteAll}. Be careful with that one though.

\begin{code}
backup deleteAll.
\end{code}

\section{FileReference}

FileReference offers a set of operations to manipulate files. We saw some of them until now and here is a more complete list of operations.

\paragraph{Accessing.}
First given a file reference you can access usual information using methods \ct{basename}, \ct{base}, \ct{extensions}...



\begin{code}{}
| pf |
pf := (FileSystem disk workingDirectory / 'package-cache' ) children second.
  -->  /Users/ducasse/Pharo/PharoHarvestingFixes/20/package-cache/AsmJit-IgorStasenko.66.mcz
pf fullName.
  --> '/Users/ducasse/Pharo/PharoHarvestingFixes/20/package-cache/AsmJit-IgorStasenko.66.mcz'
pf basename.
  --> 'AsmJit-IgorStasenko.66.mcz'  
pf basenameWithoutExtension. 
  -->	'AsmJit-IgorStasenko.66'
pf base 
	--> 'AsmJit-IgorStasenko'
pf extension 'mcz'
    -->
pf extensions
	--> an OrderedCollection('66' 'mcz')
\end{code}

\begin{code}{}
pf  basenameWithIndicator  
	--> 'AsmJit-IgorStasenko.66.mcz'
pf parent  basename 
	--> 'package-cache'
pf parent basenameWithIndicator  
	--> 'package-cache/'
\end{code}



\begin{code}{}
pf pathSegments  
	-->  #('Users' 'ducasse' 'Pharo' 'PharoHarvestingFixes' '20' 'package-cache' 'AsmJit-IgorStasenko.66.mcz')
pf path
    -->  Path / 'Users' / 'ducasse' / 'Pharo' / 'PharoHarvestingFixes' / '20' / 'package-cache' / 'AsmJit-IgorStasenko.66.mcz'
\end{code}



\begin{code}{}
| pf |
pf := (FileSystem disk workingDirectory / 'package-cache' ) children second.
pf humanReadableSize 
	--> '182.78 kB'
pf size 
	--> 182778
\end{code}  


You can get limited information about the file entry itself using creationTime, permissions

To get the full information you should access the entry itself.

\begin{code}{}
| pf |
pf := (FileSystem disk workingDirectory / 'package-cache' ) children second.
pf creationTime.
	--> 2012-06-10T10:43:19+02:00
pf modificationTime.
	-->  2012-06-10T10:43:19+02:00
pf permissions
	-->  rw-r--r--
\end{code}

\begin{code}{}
| pf |
pf := (FileSystem disk workingDirectory / 'package-cache' ) children second.
pf entry


pf parent entries
	"returns all the entries of the children of the receiver"
\end{code}


\paragraph{Operating on files.}
\sd{here so far}

delete (deletes the file if it is present else raise an error, deleteAll, deleteAllChildren, deleteIfAbsent: 
ensureDeleted (which makes sure that the file will be deleted), 


ensureDirectory does not raise an error while createDirectory does it.

\begin{code}{}
(FileSystem disk workingDirectory / 'paf' ) delete.
(FileSystem disk workingDirectory / 'paf' ) createDirectory.
[(FileSystem disk workingDirectory / 'paf' ) createDirectory] on: DirectoryExists do: [:ex| true].
	--> true
(FileSystem disk workingDirectory / 'paf' ) delete.
(FileSystem disk workingDirectory / 'paf' ) delete.
(FileSystem disk workingDirectory / 'paf' ) ensureDirectory.
(FileSystem disk workingDirectory / 'paf' ) ensureDirectory.
(FileSystem disk workingDirectory / 'paf' ) isDirectory.
  --> true
\end{code}



ensureFile

\sd{what is the difference between deleteAll and deleteAllChildren}
\sd{what is the difference between delete and ensureDeleted? since delete sent to a non existing file does not raise error}


\subsection{Reference}
Paths and filesystems are the lowest level of the FileSystem API. A \ct{FileReference} combines a path and a filesystem into a single object which provides a simpler protocol for working with files. It implements the same operations as \ct{FileSystem}, but without the need to track paths and filesystem separately:

\begin{code}{}
fs := Filesystem memory.
griffle := fs referenceTo: (Path / 'plonk' / 'griffle').
nurp := fs referenceTo: (Path * 'nurp').
    
griffle isFile.				--> false
griffle isDirectory. 		--> false
    
griffle parent ensureDirectory.
griffle writeStreamDo: [ :stream | ].
griffle exists & griffle isFile		--> true
griffle copyTo: nurp
nurp exists.				--> true
griffle delete              
\end{code}    

References also implement the path protocol with methods like \ct{/}, \ct{parent} and \ct{resolve:}.

\subsection{Locator}

Locators can be considered late-bound references. They're left deliberately fuzzy, and are only resolved to a concrete reference when some file operation needs to be performed. Instead of a filesystem and path, locators are made up of an origin and a path. An origin is an abstract filesystem location, such as the user's home directory, the image file, or the VM executable. When it receives a message like \ct{isFile}, a locator will first resolve its origin, then resolve its path against the origin.

Locators make it possible to specify things like "an item named 'package-cache' in the same directory as the image file" and have that specification remain valid even if the image is saved and moved to another directory, possibly on a different computer.

\begin{code}{}
    locator := FileLocator imageDirectory / 'package-cache'.
    locator printString.             --> ' {imageDirectory}/package-cache'
    locator resolve.                 -->  /Users/ducasse/Pharo/PharoHarvestingFixes/20/package-cache
    locator isFile.                  --> false
    locator isDirectory.             --> true
\end{code}	

The following origins are currently supported:

\begin{itemize}
\item \ct{imageDirectory} - the directory in which the image resides in
\item\ct{image} - the image file
\item\ct{changes} - the changes file
\item\ct{vmBinary} - the executable for the running virtual machine
\item\ct{vmDirectory} - the directory containing the VM application (may not be the parent of \ct{vmBinary})
\item\ct{home} - the user's home directory
\item\ct{desktop} - the directory that hold the contents of the user's desktop
\item\ct{documents} - the directory where the user's documents are stored (e.g. '/Users/colin/Documents')
\end{itemize}

Applications may also define their own origins, but the system will not be able to resolve them automatically. Instead, the user will be asked to manually choose a directory. This choice is then cached so that future resolution requests will not require user interaction.


\subsection{Filesystem}

A filesystem is an interface to access hierarchies of directories and files. "The filesystem," provided by the host operating system, is represented by \ct{FSDiskFilesystem} and its platform-specific subclasses. However, the user should not access them directly but using \ct{FSFilesystem} as we show previously. Other kinds of Filesystems are also possible. The memory filesystem provides a RAM disk filesystem where all files are stored as ByteArrays in the image. The zip filesystem represents the contents of a zip file.

Each filesystem has its own working directory, which it uses to resolve any relative paths that are passed to it. Some examples:

\begin{code}{}
fs := FSFilesystem memory.
fs workingDirectoryPath: (FSPath / 'plonk').
griffle := FSPath / 'plonk' / 'griffle'.
nurp := FSPath * 'nurp'.
    
fs resolve: nurp.            --> /plonk/nurp
    
fs createDirectory: (FSPath / 'plonk').  --> "/plonk created"
(fs writeStreamOn: griffle) close.  --> "/plonk/griffle created"
fs isFile: griffle.         --> true
fs isDirectory: griffle.         --> false
fs copy: griffle to: nurp.       --> "/plonk/griffle copied to /plonk/nurp"
fs exists: nurp.             --> true
fs delete: griffle.          --> "/plonk/griffle" deleted
fs isFile: griffle.          --> false
fs isDirectory: griffle.         --> false
\end{code}
	



\section{Looking at FileSystem internals}
\sd{put an uml diagram?}
Now we explain the key classes of Filesystem. 






\subsection{Path}
Paths are the most fundamental element of the Filesystem API. They represent filesystem paths in a very abstract sense, and provide a high-level protocol for working with paths without having to manipulate strings. Here are some examples showing how to 
define absolute paths (\mthind{FSPath}{/}), relative paths (\mthind{FSPath}{*}), file extension (\mthind{FSPath}{,}), parent navigation (\mthind{FSPath}{parent})

\begin{code}{}
"absolute path"
FSPath / 'plonk' / 'feep'       --> /plonk/feep
    
"relative path"
FSPath * 'plonk' / 'feep'       --> plonk/feep

"relative path with extension"
FSPath * 'griffle' , 'txt'      --> griffle.txt
    
"changing the extension"
FSPath * 'griffle.txt' , 'jpeg'     --> griffle.jpeg
    
"parent directory"
(FSPath / 'plonk' / 'griffle') parent   --> /plonk
    
"resolving a relative path"
(FSPath / 'plonk' / 'griffle') resolve: (FSPath * '..' / 'feep')
                   --> /plonk/feep
    
"resolving an absolute path"
(FSPath / 'plonk' / 'griffle') resolve: (FSPath / 'feep')
                   --> /feep
                                           
"resolving a string"
(FSPath * 'griffle') resolve: 'plonk'   --> griffle/plonk
                        
"comparing"
(FSPath / 'plonk') contains: (FSPath / 'griffle' / 'nurp')
                     --> false
\end{code}

Note that some of the path protocol (messages like \ct{/}, \ct{parent} and \ct{resolve:}) are also available on references --- references are a combination of path and filesystem. 

\subsection{Enumeration}

References and Locators also provide simple methods for dealing with whole directory trees:

\begin{description}
\item[allChildren.]

This will answer an array of references to all the files and directories in the directory tree rooted at the receiver. If the receiver is a file, the array will contain a single reference, equal to the receiver.

\item[allEntries.]
This method is similar to \ct{allChildren}, but it answers an array of \ct{FSDirectoryEntries}, rather than references.

\item[copyAllTo: aReference.]

This will perform a deep copy of the receiver, to a location specified by the argument. If the receiver is a file, the file will be copied; if a directory, the directory and its contents will be copied recursively. The argument must be a reference that doesn't exist; it will be created by the copy.

\item[deleteAll.]

This will perform a recursive delete of the receiver. If the receiver is a file, this has the same effect as \ct{delete}.
\end{description}

\subsection{Visitors}

The above methods are sufficient for many common tasks, but application developers may find that they need to perform more sophisticated operations on directory trees.

The visitor protocol is very simple. A visitor needs to implement \ct{visitFile:} and \ct{visitDirectory:}. The actual traversal of the filesystem is handled by a guide. A guide works with a visitor, crawling the filesystem and notifying the visitor of the files and directories it discovers. There are three Guide classes, \ct{FSPreorderGuide}, \ct{FSPostorderGuide} and \ct{FSBreadthFirstGuide} , which traverse the filesystem in different orders. To arrange for a guide to traverse the filesystem with a particular visitor is simple. Here's an example:

\begin{code}{}
    FSBreadthFirstGuide show: aReference to: aVisitor
\end{code}	

The enumeration methods described above are implemented with visitors; see \ct{FSCopyVisitor}, \ct{FSDeleteVisitor}, and \ct{FSCollectVisitor} for examples.



%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: