% $Author: oscar $
% $Date: 2009-08-16 16:37:09 +0200 (Sun, 16 Aug 2009) $
% $Revision: 28477 $

% HISTORY:
% 2008-01-19 - Stef started
% 2008-12-26 - Jannik Laval added text
% 2011-20-05 - Jean baptiste Arnaud add some text (Lexical closure)
% 2011-07-01 - Jean baptiste Arnaud add some test (Storing a block)
% 2011-08-09 - Stef doing another pass
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
% todo for stef explaining blockClosure environment representation + explaining the trick with the bytecodes
% 2012-01-27 - Integrated Ben Coman feedback
% 2012-07-25 - Stef doing another pass to restart working on it.

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Athens}\chalabel{athens}

Athens in 4 points:  Athens is a modern graphics engine for Pharo
Athens is an object-oriented (smalltalk oriented) vector graphics library. It is not a
wrapper of a C-library. 
Athens offers one API and multiple backends (Cairo, openGl).


\section{Why a new canvas?}

\begin{itemize}
\item Bitblt lacks of abstraction
\item We living in pixelated world
\item Balloon engine is built ''on top'' of BitBlt, not-so-nice integration. As result - existing Canvas and Morphic code is cumbersome and overloaded
\item hard to maintain and improve (VM plugins written in slang)
\item rendering quality
\end{itemize}

\paragraph{Canvas (the pre-Athens canvas)}
\begin{itemize}
\item  methodDict size returns 88
\item coordinate system is fixed
\item  many places assuming canvas have direct access to pixels
\end{itemize}

\paragraph{AthensCanvas}
\begin{itemize}
\item  methodDict size returns 21
\item free transformation of coordinate system 
\item  no assumptions about output media
\end{itemize}

\section{Athens Design}


\begin{figure}[!h]
\begin{center}
\includegraphics[width=9cm]{AthensArchitecture}
\caption{ Athens is the API that applications and infrastructure should use. \label{fig:AthensArchitecture}}
\end{center}
\end{figure}

\begin{figure}[!h]
\begin{center}
\includegraphics[width=9cm]{RoleBasedArchitecture}
\caption{ \label{fig:RoleBasedArchitecture}}
\end{center}
\end{figure}

\section{Main Architecture Players}

\subsection{Surface}
\ct{Surface} is an abstract class which represents an output media and defines backend which you will be using.

A surface acts as a factory for creating paints, paths, canvas and other involved objects. 
It provides access to its canvas. Surfaces are ALWAYS backend-specific. 


\subsection{Canvas}
A canvas is associated to a surface. Canvas implements one, single drawing operation: \ct{canvas draw} \sd{is it the real method name?} 
The canvas maintains current coordinate system transformations:
\ct{canvas pathTransform}

\ct{canvas paintTransform} maintains currently selected shape (selected using \ct{canvas setShape: ...}, and 
maintains currently selected paint (selected using \ct{canvas setPaint:} and the paint mode (not fully implemented). 

\subsection{Paint}
A paint is used to fill the shape. It can be composed of 
\begin{itemize}
\item solid color
\item  gradients
\item  stroke paints
\item bitmap (form) paints
\end{itemize}
In addition you can define own paint. 

\subsection{Shape}
A shape defines an enclosing region of drawing operation. This region can be a 
rectangle or paths. 

A path delineates a contour consisting of a sequence of connected segments. Segments
are line, quadric Bezier curve, cubic Bezier curve, circular arcs, and elliptical arcs. In addition you can define your own shape.

\section{Athens examples}

\subsection{Studying a first example}

\begin{code}{}
| surf |surf :=  AthensCairoSurface extent: 100@100.	surf drawDuring: [:canvas |		surf clear.		canvas setPaint: (Color red).		canvas setShape: (0@ 0 corner: 40@ 40).		canvas draw].
Display getCanvas drawImage: surf asForm at: 0@0\end{code}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:


%| last |
%last := thisContext.
%thisContext runSimulated: [#(1 2 3) detect: [:e| e even]] contextAtEachStep: [:c| c ~~ last ifTrue: [Transcript print: c; cr; flush. last := c]]
%
%=>
%
%[] in UndefinedObject>>DoIt
%Array(Collection)>>detect:
%Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
%
%
%or...
%
%
%| last home indent |
%last := nil.
%home := thisContext.
%indent := 0.
%thisContext
%	runSimulated: [#(1 2 3) detect: [:e| e even]]
%	contextAtEachStep:
%		[:c| | ctxt |
%		c ~~ last ifTrue:
%			[last := c.
%			 indent := 0. ctxt := c sender.
%			 [ctxt ~~ home] whileTrue:
%				[ctxt := ctxt sender. indent := indent + 1].
%			Transcript crtab: indent; print: c; flush]]
%
%[] in UndefinedObject>>DoIt
%	Array(Collection)>>detect:
%		Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%	Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
%


\section{Chapter conclusion}


We want to thank Ben Coman for his english corrections and Eliot Miranda for the discussions and explanations about his implementation of fast closure for Squeak and Pharo. We thank Norbert Hartl for his feedback.
