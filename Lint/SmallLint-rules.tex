\section{Existing SmallLint Rules}
\subsection{Refactoring-Critics-TransformationRules}
\textbf{Move variable assignment outside of single statement ifTrue:ifFalse: blocks} (RBAssignmentInIfTrueRule class): Moving assignements outside blocks leads to shorter and more efficient code.For example:test 	ifTrue: [var := 1]	ifFlase: [var:= 2]is equivalent to:var :=  test 	ifTrue: [1]	ifFlase: [2]

\textbf{at:ifAbsent: -> at:ifAbsentPut:} (RBAtIfAbsentRule class):  Replaces at:ifAbsent: by at:ifAbsentPut:

\textbf{"a >= b and: [a <= c]" -> "a between: b and: c"} (RBBetweenAndRule class):  Replaces "a >= b and: [a <= c]" by "a between: b and: c"

\textbf{#detect:ifNone: -> anySatisfy:} (RBDetectIfNoneRule class): Replaces detect:ifNone: by anySatisfy:

\textbf{= nil -> isNil AND ~= nil -> notNil} (RBEqualNilRule class): Replaces = nil and == nil by isNil, ~= nil and ~~ nil by notNil, 

\textbf{Eliminate unnecessary not's} (RBNotEliminationRule class): Eliminate unnecessary not's.For example test not ifTrue:[] is equivalent to test ifFalse:[]

\subsection{Refactoring-Critics-ParseTreeRules}
\textbf{Assignment has no effect} (RBAssignmentWithoutEffectRule class): This smell arises when a statement such as x := x is found. This statement has not effect, it can be removed.

\textbf{Debugging code left in methods} (RBCodeCruftLeftInMethodsRule class): This smell arises when a breakpoints, logging statements, etc is found in a method. This debugging code should not be left in production code.

\textbf{Check for same statements at end of ifTrue:ifFalse: blocks} (RBEndTrueFalseRule class): Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end. While you might not originally write such code, as it is modified, it is easier to create such code. Instead of having the same code in two places, you should move it outside the blocks.For example, test 	ifTrue:[self foo. self bar] 	ifFalse: [self foo. self baz] is equivalent to: self foo.  test 	ifTrue:[self bar] 	ifFalse: [self baz]

\textbf{Block immediately evaluated} (RBExtraBlockRule class): Check for blocks that are immediately evaluated. Since the block is immediately evaluated, there is no need for the statements to be in a block.For example, [:x | 1 + x] value: 4 is equivalent to 1 + 4

\textbf{Possible missing "; yourself"} (RBMissingYourselfRule class): When using cascaded messages, it is often important to finish the cascade with a yourself message. Why? for several reasons. 		First the messages in the cascade may not return the last receiver but the argument as in the well known case of adding elements in a collection.		| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2.		In this example, col will be assigned to 2 instead of an orderedCollection because add: returns its argument and not the receiver. 		The correct way to do it is using yourself (since yourself returns the receiver).	| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2 ; yourself.			Second case. Using yourself you can block the influence of redefined method. 	Imagine the following example: a method creating an instance, initializing it and returning it.		Box class $>>$ new		| inst | 		inst := self new.		inst initialize. 		^ inst			What this code ensures is that the instance is returned. Using ^ inst initialize would have 	return the same (but with the risk that if initialize did not return the receiver the new method would not return the right instance)		The previous code can be expressed as follow:		Box class $>>$ new		^ self new initialize ; yourself 			Here yourself play the same role as the ^ inst above. 		

\textbf{String concatenation instead of streams} (RBStringConcatenationRule class): Check for string concatenation inside some iteration message. Since string concatenation is O(n^2), it is better to use streaming since it is O(n) - assuming that n is large enough. As a general principal avoid , since the receiver is copied. Therefore chaining , messages will lead to multiple useless copies of the receiver. Instead of writing	| string | 	string := String new.	\#(1 2 3) do: [ :each |		string := string, each asString].	^ stringWrite, it is much more efficient.	String streamContents: [:s | 		\#(1 2 3)  do: [:each | s nextPutAll: each asString]]

\subsection{Refactoring-Critics-TransformationRules}
\textbf{Move variable assignment outside of single statement ifTrue:ifFalse: blocks} (RBAssignmentInIfTrueRule class): Moving assignements outside blocks leads to shorter and more efficient code.For example:test 	ifTrue: [var := 1]	ifFlase: [var:= 2]is equivalent to:var :=  test 	ifTrue: [1]	ifFlase: [2]

\textbf{at:ifAbsent: -> at:ifAbsentPut:} (RBAtIfAbsentRule class):  Replaces at:ifAbsent: by at:ifAbsentPut:

\textbf{"a >= b and: [a <= c]" -> "a between: b and: c"} (RBBetweenAndRule class):  Replaces "a >= b and: [a <= c]" by "a between: b and: c"

\textbf{#detect:ifNone: -> anySatisfy:} (RBDetectIfNoneRule class): Replaces detect:ifNone: by anySatisfy:

\textbf{= nil -> isNil AND ~= nil -> notNil} (RBEqualNilRule class): Replaces = nil and == nil by isNil, ~= nil and ~~ nil by notNil, 

\textbf{Eliminate unnecessary not's} (RBNotEliminationRule class): Eliminate unnecessary not's.For example test not ifTrue:[] is equivalent to test ifFalse:[]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-TransformationRules}
\textbf{Move variable assignment outside of single statement ifTrue:ifFalse: blocks} (RBAssignmentInIfTrueRule class): Moving assignements outside blocks leads to shorter and more efficient code.For example:test 	ifTrue: [var := 1]	ifFlase: [var:= 2]is equivalent to:var :=  test 	ifTrue: [1]	ifFlase: [2]

\textbf{at:ifAbsent: -> at:ifAbsentPut:} (RBAtIfAbsentRule class):  Replaces at:ifAbsent: by at:ifAbsentPut:

\textbf{"a >= b and: [a <= c]" -> "a between: b and: c"} (RBBetweenAndRule class):  Replaces "a >= b and: [a <= c]" by "a between: b and: c"

\textbf{#detect:ifNone: -> anySatisfy:} (RBDetectIfNoneRule class): Replaces detect:ifNone: by anySatisfy:

\textbf{= nil -> isNil AND ~= nil -> notNil} (RBEqualNilRule class): Replaces = nil and == nil by isNil, ~= nil and ~~ nil by notNil, 

\textbf{Eliminate unnecessary not's} (RBNotEliminationRule class): Eliminate unnecessary not's.For example test not ifTrue:[] is equivalent to test ifFalse:[]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-ParseTreeRules}
\textbf{Assignment has no effect} (RBAssignmentWithoutEffectRule class): This smell arises when a statement such as x := x is found. This statement has not effect, it can be removed.

\textbf{Debugging code left in methods} (RBCodeCruftLeftInMethodsRule class): This smell arises when a breakpoints, logging statements, etc is found in a method. This debugging code should not be left in production code.

\textbf{Check for same statements at end of ifTrue:ifFalse: blocks} (RBEndTrueFalseRule class): Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end. While you might not originally write such code, as it is modified, it is easier to create such code. Instead of having the same code in two places, you should move it outside the blocks.For example, test 	ifTrue:[self foo. self bar] 	ifFalse: [self foo. self baz] is equivalent to: self foo.  test 	ifTrue:[self bar] 	ifFalse: [self baz]

\textbf{Block immediately evaluated} (RBExtraBlockRule class): Check for blocks that are immediately evaluated. Since the block is immediately evaluated, there is no need for the statements to be in a block.For example, [:x | 1 + x] value: 4 is equivalent to 1 + 4

\textbf{Possible missing "; yourself"} (RBMissingYourselfRule class): When using cascaded messages, it is often important to finish the cascade with a yourself message. Why? for several reasons. 		First the messages in the cascade may not return the last receiver but the argument as in the well known case of adding elements in a collection.		| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2.		In this example, col will be assigned to 2 instead of an orderedCollection because add: returns its argument and not the receiver. 		The correct way to do it is using yourself (since yourself returns the receiver).	| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2 ; yourself.			Second case. Using yourself you can block the influence of redefined method. 	Imagine the following example: a method creating an instance, initializing it and returning it.		Box class $>>$ new		| inst | 		inst := self new.		inst initialize. 		^ inst			What this code ensures is that the instance is returned. Using ^ inst initialize would have 	return the same (but with the risk that if initialize did not return the receiver the new method would not return the right instance)		The previous code can be expressed as follow:		Box class $>>$ new		^ self new initialize ; yourself 			Here yourself play the same role as the ^ inst above. 		

\textbf{String concatenation instead of streams} (RBStringConcatenationRule class): Check for string concatenation inside some iteration message. Since string concatenation is O(n^2), it is better to use streaming since it is O(n) - assuming that n is large enough. As a general principal avoid , since the receiver is copied. Therefore chaining , messages will lead to multiple useless copies of the receiver. Instead of writing	| string | 	string := String new.	\#(1 2 3) do: [ :each |		string := string, each asString].	^ stringWrite, it is much more efficient.	String streamContents: [:s | 		\#(1 2 3)  do: [:each | s nextPutAll: each asString]]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-TransformationRules}
\textbf{Move variable assignment outside of single statement ifTrue:ifFalse: blocks} (RBAssignmentInIfTrueRule class): Moving assignements outside blocks leads to shorter and more efficient code.For example:test 	ifTrue: [var := 1]	ifFlase: [var:= 2]is equivalent to:var :=  test 	ifTrue: [1]	ifFlase: [2]

\textbf{at:ifAbsent: -> at:ifAbsentPut:} (RBAtIfAbsentRule class):  Replaces at:ifAbsent: by at:ifAbsentPut:

\textbf{"a >= b and: [a <= c]" -> "a between: b and: c"} (RBBetweenAndRule class):  Replaces "a >= b and: [a <= c]" by "a between: b and: c"

\textbf{#detect:ifNone: -> anySatisfy:} (RBDetectIfNoneRule class): Replaces detect:ifNone: by anySatisfy:

\textbf{= nil -> isNil AND ~= nil -> notNil} (RBEqualNilRule class): Replaces = nil and == nil by isNil, ~= nil and ~~ nil by notNil, 

\textbf{Eliminate unnecessary not's} (RBNotEliminationRule class): Eliminate unnecessary not's.For example test not ifTrue:[] is equivalent to test ifFalse:[]

\subsection{Refactoring-Critics-ParseTreeRules}
\textbf{Assignment has no effect} (RBAssignmentWithoutEffectRule class): This smell arises when a statement such as x := x is found. This statement has not effect, it can be removed.

\textbf{Debugging code left in methods} (RBCodeCruftLeftInMethodsRule class): This smell arises when a breakpoints, logging statements, etc is found in a method. This debugging code should not be left in production code.

\textbf{Check for same statements at end of ifTrue:ifFalse: blocks} (RBEndTrueFalseRule class): Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end. While you might not originally write such code, as it is modified, it is easier to create such code. Instead of having the same code in two places, you should move it outside the blocks.For example, test 	ifTrue:[self foo. self bar] 	ifFalse: [self foo. self baz] is equivalent to: self foo.  test 	ifTrue:[self bar] 	ifFalse: [self baz]

\textbf{Block immediately evaluated} (RBExtraBlockRule class): Check for blocks that are immediately evaluated. Since the block is immediately evaluated, there is no need for the statements to be in a block.For example, [:x | 1 + x] value: 4 is equivalent to 1 + 4

\textbf{Possible missing "; yourself"} (RBMissingYourselfRule class): When using cascaded messages, it is often important to finish the cascade with a yourself message. Why? for several reasons. 		First the messages in the cascade may not return the last receiver but the argument as in the well known case of adding elements in a collection.		| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2.		In this example, col will be assigned to 2 instead of an orderedCollection because add: returns its argument and not the receiver. 		The correct way to do it is using yourself (since yourself returns the receiver).	| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2 ; yourself.			Second case. Using yourself you can block the influence of redefined method. 	Imagine the following example: a method creating an instance, initializing it and returning it.		Box class $>>$ new		| inst | 		inst := self new.		inst initialize. 		^ inst			What this code ensures is that the instance is returned. Using ^ inst initialize would have 	return the same (but with the risk that if initialize did not return the receiver the new method would not return the right instance)		The previous code can be expressed as follow:		Box class $>>$ new		^ self new initialize ; yourself 			Here yourself play the same role as the ^ inst above. 		

\textbf{String concatenation instead of streams} (RBStringConcatenationRule class): Check for string concatenation inside some iteration message. Since string concatenation is O(n^2), it is better to use streaming since it is O(n) - assuming that n is large enough. As a general principal avoid , since the receiver is copied. Therefore chaining , messages will lead to multiple useless copies of the receiver. Instead of writing	| string | 	string := String new.	\#(1 2 3) do: [ :each |		string := string, each asString].	^ stringWrite, it is much more efficient.	String streamContents: [:s | 		\#(1 2 3)  do: [:each | s nextPutAll: each asString]]

\subsection{Refactoring-Critics-TransformationRules}
\textbf{Move variable assignment outside of single statement ifTrue:ifFalse: blocks} (RBAssignmentInIfTrueRule class): Moving assignements outside blocks leads to shorter and more efficient code.For example:test 	ifTrue: [var := 1]	ifFlase: [var:= 2]is equivalent to:var :=  test 	ifTrue: [1]	ifFlase: [2]

\textbf{at:ifAbsent: -> at:ifAbsentPut:} (RBAtIfAbsentRule class):  Replaces at:ifAbsent: by at:ifAbsentPut:

\textbf{"a >= b and: [a <= c]" -> "a between: b and: c"} (RBBetweenAndRule class):  Replaces "a >= b and: [a <= c]" by "a between: b and: c"

\textbf{#detect:ifNone: -> anySatisfy:} (RBDetectIfNoneRule class): Replaces detect:ifNone: by anySatisfy:

\textbf{= nil -> isNil AND ~= nil -> notNil} (RBEqualNilRule class): Replaces = nil and == nil by isNil, ~= nil and ~~ nil by notNil, 

\textbf{Eliminate unnecessary not's} (RBNotEliminationRule class): Eliminate unnecessary not's.For example test not ifTrue:[] is equivalent to test ifFalse:[]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-ParseTreeRules}
\textbf{Assignment has no effect} (RBAssignmentWithoutEffectRule class): This smell arises when a statement such as x := x is found. This statement has not effect, it can be removed.

\textbf{Debugging code left in methods} (RBCodeCruftLeftInMethodsRule class): This smell arises when a breakpoints, logging statements, etc is found in a method. This debugging code should not be left in production code.

\textbf{Check for same statements at end of ifTrue:ifFalse: blocks} (RBEndTrueFalseRule class): Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end. While you might not originally write such code, as it is modified, it is easier to create such code. Instead of having the same code in two places, you should move it outside the blocks.For example, test 	ifTrue:[self foo. self bar] 	ifFalse: [self foo. self baz] is equivalent to: self foo.  test 	ifTrue:[self bar] 	ifFalse: [self baz]

\textbf{Block immediately evaluated} (RBExtraBlockRule class): Check for blocks that are immediately evaluated. Since the block is immediately evaluated, there is no need for the statements to be in a block.For example, [:x | 1 + x] value: 4 is equivalent to 1 + 4

\textbf{Possible missing "; yourself"} (RBMissingYourselfRule class): When using cascaded messages, it is often important to finish the cascade with a yourself message. Why? for several reasons. 		First the messages in the cascade may not return the last receiver but the argument as in the well known case of adding elements in a collection.		| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2.		In this example, col will be assigned to 2 instead of an orderedCollection because add: returns its argument and not the receiver. 		The correct way to do it is using yourself (since yourself returns the receiver).	| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2 ; yourself.			Second case. Using yourself you can block the influence of redefined method. 	Imagine the following example: a method creating an instance, initializing it and returning it.		Box class $>>$ new		| inst | 		inst := self new.		inst initialize. 		^ inst			What this code ensures is that the instance is returned. Using ^ inst initialize would have 	return the same (but with the risk that if initialize did not return the receiver the new method would not return the right instance)		The previous code can be expressed as follow:		Box class $>>$ new		^ self new initialize ; yourself 			Here yourself play the same role as the ^ inst above. 		

\textbf{String concatenation instead of streams} (RBStringConcatenationRule class): Check for string concatenation inside some iteration message. Since string concatenation is O(n^2), it is better to use streaming since it is O(n) - assuming that n is large enough. As a general principal avoid , since the receiver is copied. Therefore chaining , messages will lead to multiple useless copies of the receiver. Instead of writing	| string | 	string := String new.	\#(1 2 3) do: [ :each |		string := string, each asString].	^ stringWrite, it is much more efficient.	String streamContents: [:s | 		\#(1 2 3)  do: [:each | s nextPutAll: each asString]]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-ParseTreeRules}
\textbf{Assignment has no effect} (RBAssignmentWithoutEffectRule class): This smell arises when a statement such as x := x is found. This statement has not effect, it can be removed.

\textbf{Debugging code left in methods} (RBCodeCruftLeftInMethodsRule class): This smell arises when a breakpoints, logging statements, etc is found in a method. This debugging code should not be left in production code.

\textbf{Check for same statements at end of ifTrue:ifFalse: blocks} (RBEndTrueFalseRule class): Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end. While you might not originally write such code, as it is modified, it is easier to create such code. Instead of having the same code in two places, you should move it outside the blocks.For example, test 	ifTrue:[self foo. self bar] 	ifFalse: [self foo. self baz] is equivalent to: self foo.  test 	ifTrue:[self bar] 	ifFalse: [self baz]

\textbf{Block immediately evaluated} (RBExtraBlockRule class): Check for blocks that are immediately evaluated. Since the block is immediately evaluated, there is no need for the statements to be in a block.For example, [:x | 1 + x] value: 4 is equivalent to 1 + 4

\textbf{Possible missing "; yourself"} (RBMissingYourselfRule class): When using cascaded messages, it is often important to finish the cascade with a yourself message. Why? for several reasons. 		First the messages in the cascade may not return the last receiver but the argument as in the well known case of adding elements in a collection.		| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2.		In this example, col will be assigned to 2 instead of an orderedCollection because add: returns its argument and not the receiver. 		The correct way to do it is using yourself (since yourself returns the receiver).	| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2 ; yourself.			Second case. Using yourself you can block the influence of redefined method. 	Imagine the following example: a method creating an instance, initializing it and returning it.		Box class $>>$ new		| inst | 		inst := self new.		inst initialize. 		^ inst			What this code ensures is that the instance is returned. Using ^ inst initialize would have 	return the same (but with the risk that if initialize did not return the receiver the new method would not return the right instance)		The previous code can be expressed as follow:		Box class $>>$ new		^ self new initialize ; yourself 			Here yourself play the same role as the ^ inst above. 		

\textbf{String concatenation instead of streams} (RBStringConcatenationRule class): Check for string concatenation inside some iteration message. Since string concatenation is O(n^2), it is better to use streaming since it is O(n) - assuming that n is large enough. As a general principal avoid , since the receiver is copied. Therefore chaining , messages will lead to multiple useless copies of the receiver. Instead of writing	| string | 	string := String new.	\#(1 2 3) do: [ :each |		string := string, each asString].	^ stringWrite, it is much more efficient.	String streamContents: [:s | 		\#(1 2 3)  do: [:each | s nextPutAll: each asString]]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-TransformationRules}
\textbf{Move variable assignment outside of single statement ifTrue:ifFalse: blocks} (RBAssignmentInIfTrueRule class): Moving assignements outside blocks leads to shorter and more efficient code.For example:test 	ifTrue: [var := 1]	ifFlase: [var:= 2]is equivalent to:var :=  test 	ifTrue: [1]	ifFlase: [2]

\textbf{at:ifAbsent: -> at:ifAbsentPut:} (RBAtIfAbsentRule class):  Replaces at:ifAbsent: by at:ifAbsentPut:

\textbf{"a >= b and: [a <= c]" -> "a between: b and: c"} (RBBetweenAndRule class):  Replaces "a >= b and: [a <= c]" by "a between: b and: c"

\textbf{#detect:ifNone: -> anySatisfy:} (RBDetectIfNoneRule class): Replaces detect:ifNone: by anySatisfy:

\textbf{= nil -> isNil AND ~= nil -> notNil} (RBEqualNilRule class): Replaces = nil and == nil by isNil, ~= nil and ~~ nil by notNil, 

\textbf{Eliminate unnecessary not's} (RBNotEliminationRule class): Eliminate unnecessary not's.For example test not ifTrue:[] is equivalent to test ifFalse:[]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Manifest-Core}
\textbf{Remove assignment has no effect} (RBRemoveAssignmentWithoutEffectRule class): Remove assignment has no effect. For example, var := var is unless

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-ParseTreeRules}
\textbf{Assignment has no effect} (RBAssignmentWithoutEffectRule class): This smell arises when a statement such as x := x is found. This statement has not effect, it can be removed.

\textbf{Debugging code left in methods} (RBCodeCruftLeftInMethodsRule class): This smell arises when a breakpoints, logging statements, etc is found in a method. This debugging code should not be left in production code.

\textbf{Check for same statements at end of ifTrue:ifFalse: blocks} (RBEndTrueFalseRule class): Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end. While you might not originally write such code, as it is modified, it is easier to create such code. Instead of having the same code in two places, you should move it outside the blocks.For example, test 	ifTrue:[self foo. self bar] 	ifFalse: [self foo. self baz] is equivalent to: self foo.  test 	ifTrue:[self bar] 	ifFalse: [self baz]

\textbf{Block immediately evaluated} (RBExtraBlockRule class): Check for blocks that are immediately evaluated. Since the block is immediately evaluated, there is no need for the statements to be in a block.For example, [:x | 1 + x] value: 4 is equivalent to 1 + 4

\textbf{Possible missing "; yourself"} (RBMissingYourselfRule class): When using cascaded messages, it is often important to finish the cascade with a yourself message. Why? for several reasons. 		First the messages in the cascade may not return the last receiver but the argument as in the well known case of adding elements in a collection.		| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2.		In this example, col will be assigned to 2 instead of an orderedCollection because add: returns its argument and not the receiver. 		The correct way to do it is using yourself (since yourself returns the receiver).	| col  | 	col := (OrderedCollection new: 2) add: 1; add: 2 ; yourself.			Second case. Using yourself you can block the influence of redefined method. 	Imagine the following example: a method creating an instance, initializing it and returning it.		Box class $>>$ new		| inst | 		inst := self new.		inst initialize. 		^ inst			What this code ensures is that the instance is returned. Using ^ inst initialize would have 	return the same (but with the risk that if initialize did not return the receiver the new method would not return the right instance)		The previous code can be expressed as follow:		Box class $>>$ new		^ self new initialize ; yourself 			Here yourself play the same role as the ^ inst above. 		

\textbf{String concatenation instead of streams} (RBStringConcatenationRule class): Check for string concatenation inside some iteration message. Since string concatenation is O(n^2), it is better to use streaming since it is O(n) - assuming that n is large enough. As a general principal avoid , since the receiver is copied. Therefore chaining , messages will lead to multiple useless copies of the receiver. Instead of writing	| string | 	string := String new.	\#(1 2 3) do: [ :each |		string := string, each asString].	^ stringWrite, it is much more efficient.	String streamContents: [:s | 		\#(1 2 3)  do: [:each | s nextPutAll: each asString]]

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

\subsection{Refactoring-Critics-BlockRules}
\textbf{Sends "questionable" message} (RBBadMessageRule class): This smell arises when methods send messages that perform low level things. You might want to limit the number of such messages in your application. Messages such as \#isKindOf: can signify a lack of polymorphism. You can see which methods are "questionable" by editing the RBBadMessageRule$>>$badSelectors method. Some examples are: \#respondsTo: \#isMemberOf: \#performMethod: and \#performMethod:arguments:

\textbf{Redundant class name in selector} (RBClassNameInSelectorRule class): This smell arises when the class name is found in a selector. This is redundant since to call the you must already refer to the class name. For example, \#openHierarchyBrowserFrom: is a redundant name for HierarchyBrowser.

\textbf{Class not referenced} (RBClassNotReferencedRule class): This smell arises when a class is not referenced either directly or indirectly by a symbol. If a class is not referenced, it can be removed.

\textbf{Class variable capitalization} (RBClassVariableCapitalizationRule class): This smell arises when class or pool variable names do not start with an uppercase letter, which is a standart style in Smalltalk

\textbf{Defines = but not hash} (RBDefinesEqualNotHashRule class): This smell arises when a class defines \#= also and not \#hash. If \#hash is not defined then the instances of the class might not be able to be used in sets since equal element must have the same hash.

\textbf{Methods equivalently defined in superclass} (RBEquivalentSuperclassMethodsRule class): This smell arises when a method is equivalent to its superclass method. The methods are equivalent when they have the same abstract syntax tree, except for variables names. Such method does not add anything to the computation and can be removed since the superclass method have the same behaviour. Furthermore, the methods \#new and \#initialize are ignored once they are often overridden for compatilbity with other platforms. The ignored methods can be edited in RBEquivalentSuperclassMethodsRule$>>$ignoredSelectors

\textbf{Excessive number of arguments} (RBExcessiveArgumentsRule class): This smell arises when a method contains a long number of argument (five or more), which can indicate that a new object should be created to wrap the numerous parameters. The defined number of arguments can be edited in RBExcessiveArgumentsRule$>>$argumentsCount.

\textbf{Excessive inheritance depth} (RBExcessiveInheritanceRule class): This smell arises when a deep inheritance is found (depth of ten or more), which is usually a sign of a design flaw. It should be broken down and reduced to something manageable. The defined inheritance depth can be edited in RBExcessiveInheritanceRule$>>$inheritanceDepth.

\textbf{Excessive number of methods} (RBExcessiveMethodsRule class): This smell arises when a large class is found (with 40 or more methods). Large classes are indications that it has too much responsibility. Try to break it down, and reduce the size to something manageable. The defined number of methods can be edit in RBExcessiveMethodsRule$>>$methodsCount.

\textbf{Excessive number of variables} (RBExcessiveVariablesRule class): This smell arises when a class has too many instance variables (10 or more). Such classes could be redesigned to have fewer fields, possibly through some nested object grouping. The defined number of instance variables can be edited in RBExcessiveVariablesRule$>>$variablesCount.

\textbf{Methods implemented but not sent} (RBImplementedNotSentRule class): This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.	Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: 		foo		self deprecated: 'Use bar instead '. 		^ self bar		 

\textbf{Inconsistent method classification} (RBInconsistentMethodClassificationRule class): This smell arises when a method protocol is not equivalent to the one defined in the superclass of such method class. All methods should be put into a protocol (method category) that is equivalent to the one of the superclass, which is a standart style in Smalltalk. Furthermore, methods which are extended in the superclass are ignored, since they may have different protocol name. Pay attention when you apply automatic recategorisation because it may move method in antoher package if the method is defined in the superclass as an extension.

\textbf{Instance variables defined in all subclasses} (RBInstVarInSubclassesRule class): This smell arises when instance variables are defined in all subclasses. Many times you might want to pull the instance variable up into the class so that all the subclasses do not have to define it. In addition have a look at the initialize method in each of the subclasses because if the instance variable is really the same, it will be initialized similarly in different places.

\textbf{Instance variable capitalization} (RBInstanceVariableCapitalizationRule class): This smell arises when instance variable names (in instance and class side) do not start with an lowercase letter, which is a standart style in Smalltalk.

\textbf{Method just sends super message} (RBJustSendsSuperRule class): This smell arises when a method just forwards the message to its superclass. This often happens due to code changes or when you simply forget that you wanted to extend the behavior of a superclass method. These methods can be removed.

\textbf{Literal array contains a #true, #false, or #nil but the source doesn't.} (RBLiteralArrayContainsSuspiciousTrueFalseOrNilRule class): Some times ago, arrays were not allowed to contain true false and nil objects. They only contain their symbol representation: evaluating \#(true false nil) returns \#(\#true \#false \#nil). 	Nowadays, \#(true false nil) is equivalent to {true . false . nil }, i.e., it returns an array with the objects true, false, and nil. 	This smells checks methods having \#(\#true \#false \#nil) in their literal frame since it can be the source of potential bugs. 	 

\textbf{Long methods} (RBLongMethodsRule class): This smell arises when a long method is found (with 10 or more statements). Note that, it counts statements, not lines. Long methods should often be split into several smaller ones. When you start to have empty line to separate groups of methods, this is an indication that you should probably define a new method. 	Do not forget that methods are unit of extensions in an object-oriented language. It means that each time you define a method a subclass may override and extend it while taking advantage and reusing the calling context of your method. This is the basis for Hook and Template Design Pattern and central to good object-oriented design. So keep your methods short. 	Use the extract method refactoring, it even checks whether the method you are extracting already exists in the class. 		The defined number of statements can be edited in RBLongMethodsRule$>>$longMethodSize.

\textbf{Method defined in all subclasses, but not in superclass} (RBMissingSubclassResponsibilityRule class): This smell arises when a class defines a method in all subclasses, but not in itself as an abstract method. Such methods should most likely be defined as subclassResponsibility methods. Furthermore, this check helps to find similar code that might be occurring in all the subclasses that should be pulled up into the superclass.

\textbf{No class comment} (RBNoClassCommentRule class): This smell arises when a class has no comment. Classes should have comments to explain their purpose, collaborations with other classes, and optionally provide examples of use.

\textbf{Instance variables not read AND written} (RBOnlyReadOrWrittenVariableRule class): This smell arises when an instance variable is not both read and written. If an instance variable is only read, the reads can be replaced by nil, since it could not have been assigned a value. If the variable is only written, then it does not need to store the result since it is never used. This check does not work for the data model classes since they use the \#instVarAt:put: messages to set instance variables.

\textbf{Overrides a "special" message} (RBOverridesSpecialMessageRule class): Checks that a class does not override a message that is essential to the base system. For example, if you override the \#class method from object, you are likely to crash your image.In the class the messages we should not override are: ==, ~~, class, basicAt:, basicAt:put:, basicSize, identityHash.In the class side the messages we should not override are: basicNew, basicNew, class, comment, name.

\textbf{Refers to class name instead of "self class"} (RBRefersToClassRule class): This smell arises when a class has its class name directly in the source instead of "self class". The self class variant allows you to create subclasses without needing to redefine that method.

\textbf{Returns a boolean and non boolean} (RBReturnsBooleanAndOtherRule class): This smell arises when a method return a boolean value (true or false) and return some other value such as (nil or self). If the method is suppose to return a boolean, then this signifies that there is one path through the method that might return a non-boolean. If the method doesn't need to return a boolean, it should be probably rewriten to return some non-boolean value since other programmers reading the method might assume that it returns a boolean.

\textbf{Messages sent but not implemented} (RBSentNotImplementedRule class): This smell arises when a message is sent by a method,  but no class in the system implements such a message. This method sent will certainly cause a doesNotUnderstand: message when they are executed.  Further this rule checks if messages sent to self or super exist in the hierarchy, since these can be statically typed.

\textbf{Subclass responsibility not defined} (RBSubclassResponsibilityNotDefinedRule class): This rule checks if all subclassResponsibility methods are defined in all leaf classes. if such a method is not overridden, a subclassResponsibility message can be occur when this method is called

\textbf{Sends super new initialize} (RBSuperSendsNewRule class):  This rule checks for method that wrongly initialize an object twice. Contrary to other Smalltalk implementations Pharo automatically calls \#initiailize on object creation.For example, a warning is raised when the statment self new initialize is found in a method.

\textbf{Temporary variable capitalization} (RBTemporaryVariableCapitalizationRule class): This smell arises when a temporary or argument variable do not start with a lowercase letter, which is a standart style in Smalltalk.

