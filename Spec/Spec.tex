% $Author: Benjamin $
% $Date: 2011-12-21 14:28:33 +0200 $
% $Revision: 28563 $

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================

\chapter{Spec}

Creating programmatically user interfaces is often tedious and a repeating task. Some attempts to offer UIBuilder solved the problem  of the position of UI elements and their inter connection. However, there is a still the challenge of the reuse of the widgets and the reuse of the logic behind. There is a need for a declarative way to specify widgets that enables composition and reuse of the UI declaration and logic. 

A Spec is a declarative way to describe a user interface. Used as a presenter, it is a major element of UIs and applicative models reuse.

In this chapter, we will present the Spec Interpreter and how to implement a model and a UI, and more useful than that, how to reuse existing models and UIs.

\section{Code}

The code is available on squeaksource:
\begin{code}{}
Gofer new
	squeaksource: 'DirtyExperiments';
	package: 'Spec';
	load
\end{code}

\subsection{Example}

The most important point of the spec is the reuse and the possibility of composition at two levels, UI and models.
In this section, I will show you how to build a little browser of methods ( like senders/implementors ) and how to reuse this browser to build a classes and methods browser ( like a code browser ).

It's a simple example to quickly show you how to use Specs. Do not try to hard to understand deeply how it works, the mechanism will be explained just after the example.

\subsubsection{Methods Browser}

Firstly, let's think about how is structured a methods browser GUI.
It is basically composed of two areas: a list, and a text zone. And the entry point is the list of methods provided.

So let's define a MethodBrowser class

\begin{classdef}{MethodBrowser class}
ComposableModel subclass: #MethodBrowser
	instanceVariableNames: 'listHolder listModel textModel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Spec-Examples'
\end{classdef}

I let you write accessors. The will be needed by the presenter.
I will just provide you a setter example, because there is a little trick:

\begin{method}{MethodBrowser>>\#listHolder:}
MethodBrowser>>#listHolder: anHolder
	
	listHolder := anHolder.
	listModel listHolder: anHolder
\end{method}

The trick is to think to also set the list holder of the list model when the list holder is changed. This way, we ensure that a each every moment, the holder of the browser and the holder of the list model is the same\footnote{Another implementation is to get rid of the listHolder, and to only use the holder from the listModel}.

So now we have the entry point and the models. So lets make the connections between them.

\begin{method}{MethodBrowser>>\#listHolder:}
MethodBrowser>>#initialize
	"Initialization code for MethodBrowser"
	| textHolder behaviorHolder |
	
	super initialize.

	listModel := ListComposableModel new.
	self listHolder: {} asValueHolder.
	
	textHolder := ComposableValueHolder on: (listModel selectionHolder) do: [:index :selection | selection contents 
		ifNil: [ '' ]
		ifNotNil: [:m | m sourceCode ]].
	
	behaviorHolder := ComposableValueHolder on: (listModel selectionHolder) do: [:index :selection | selection contents 
		ifNil: [ nil ]
		ifNotNil: [:m | m methodClass ]].
	
	textModel := TextComposableModel textHolder: textHolder.

	textModel behaviorHolder: behaviorHolder.
	textModel aboutToStyleHolder contents: [ true ].
\end{method}

Now that links are created, we have to specify the spec on class side:

\begin{method}{MethodBrowser class>>\#internSpec:}
MethodBrowser>>#internSpec

	^{ #PanelMorph.
			#changeTableLayout.
			#listDirection:. #bottomToTop.
			#addMorph:. {#model. #listModel. #internSpec.}.
			#addMorph:. {#model. #textModel. #internSpec.}.
			#vResizing:. #spaceFill.
			#hResizing:. #spaceFill.}.
\end{method}
We specify the layout to be a column, with submorphs added from top to bottom.
And then for each model, we add its spec recursively.

So if you evaluate
\begin{code}{}
| browser |
browser := MethodBrowser new.
browser openWithSpec.
\end{code}
You should have a window like the \figref{fig:methodBrowser1}.
\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser1}
	\caption{Our browser with an empty list}
	\figlabel{fig:methodBrowser1}
\end{center}
\end{figure}

And then, if you do:
\begin{code}{}
browser  listHolder contents: (ComposableModel methodDict values , ListComposableModel methodDict values).
\end{code}
The list should automatically be updated, and looks like \figref{fig:methodBrowser2}.
\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser2}
	\caption{Our browser with list of methods}
	\figlabel{fig:methodBrowser2}
\end{center}
\end{figure}

\newpage
And if you select a method, its source code should appear, like \figref{fig:methodBrowser3}

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser3}
	\caption{Our browser with a method selected}
	\figlabel{fig:methodBrowser3}
\end{center}
\end{figure}

We are almost done, only the window's title is still wrong.
So we will define
\begin{method}{MethodBrowser class>>\#title}
MethodBrowser class>>#title

	^ 'Method Browser'
\end{method}

So now, if you re-evaluate the code, you should have a window like \figref{fig:methodBrowser4}

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser4}
	\caption{Now with a nice title}
	\figlabel{fig:methodBrowser4}
\end{center}
\end{figure}

\subsection{Classes and methods browser}

Now, we want to build a classes and methods browser. To do that, we need a list for classes, and a methods browser. As previously, the entry point is a list, but this time, a list of methods.

\begin{classdef}{ClassMethodBrowser class}
ComposableModel subclass: #ClassMethodBrowser
	instanceVariableNames: 'listHolder listModel methodModel'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Spec-Examples'
\end{classdef}

As previously, I let you wrote the accessors. And as previously, we have to ensure the holder from the browser and the holder from the list is the same.

\begin{method}{ClassMethodBrowser>>\#listHolder:}
ClassMethodBrowser>>#listHolder: anHolder
	
	listHolder := anHolder.
	listModel listHolder: anHolder
\end{method}

Now we have to create the link. It's simpler here than before because there is only one link to create between the list of classes and the method browser:

\begin{method}{ClassMethodBrowser>>\#initialize}
ClassMethodBrowser>>#initialize

	"Initialization code for ClassMethodBrowser"
	| listHolder2 |
	
	super initialize.
	
	listHolder := {} asValueHolder.
	listModel := ListComposableModel new.
	listModel listHolder: listHolder.
	
	methodModel := MethodBrowser new.
	listHolder2 := ComposableValueHolder on: (listModel selectionHolder) do: [:index :selection | selection contents ifNotNil: [:c | c methodDict values sort: [:a :b | a selector < b selector]]].
	methodModel listHolder: listHolder2.
	methodModel listModel wrapHolder contents: [:method | method selector ].
\end{method}

So now, lets do the spec. Firstly, let's create the top row, with the two lists:
\begin{method}{ClassMethodBrowser class>>\#topSpec}
ClassMethodBrowser class>>#topSpec

	^{ #PanelMorph.
			#changeTableLayout.
			#listDirection:. #rightToLeft.
			#addMorph:. {#model. #listModel. #internSpec.}.
			#addMorph:. {#model. #methodModel. #listModel. #internSpec.}.
			#vResizing:. #spaceFill.
			#hResizing:. #spaceFill.}.
\end{method}

And now we can do the internSpec:

\begin{method}{ClassMethodBrowser class>>\#interSpec}
ClassMethodBrowser class>>#interSpec

	^ { #PanelMorph.
			#changeTableLayout.
			#listDirection:. #bottomToTop.
			#addMorph:. self topSpec.
			#addMorph:. {#model. #methodModel. #textModel. #internSpec.}.
			#vResizing:. #spaceFill.
			#hResizing:. #spaceFill.}.
\end{method}
In each spec, we call the spec of our internal models.

Lastly, we can specify a title for the window:
\begin{method}{ClassMethodBrowser class>>\#title}
ClassMethodBrowser class>>#title

	^ 'Class Method Browser'
\end{method}
Then, if you evaluate:

\begin{code}{}
| browser |
browser := ClassMethodBrowser new.
browser openWithSpec.
browser listHolder contents: (Smalltalk allClasses).
\end{code}
you will get a nice browser like \figref{fig:methodBrowser5}.


\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MethodBrowser5}
	\caption{Our classes and methods browser with a method selected}
	\figlabel{fig:methodBrowser5}
\end{center}
\end{figure}


Here ends this example. I hope you have understood how you can compose Spec widget together to get new powerful widgets.

Other examples are provided in the package \verb?Spec-Example?, feel free to have a look.

\section{Spec structure and Spec Interpretor}

Now that you've seen an example, I will explain how it works and what is the principle of the mechanism behind.

\subsection{Spec Structure}

To have a static structure easily inspectable, we have decided to use an array. It avoids having to implement our own parser, and can be analyzed regardless of the implementation of Smalltalk.

A spec is composed of a receiver which is the first element of the Spec. If the first element is a class name symbol, it will be turn into an instance of this class by the interpreter. Then follow selectors and arguments. For this part, the spec is considered as a stack: each time a selector is read, as many arguments as needed by the selector are pulled and analyzed (see the following example).

%stupid indentation is used to have a render almost aligned
\begin{method}{Example of a spec}
internSpec

	^ {#PluggableListMorph.
	    	#model:.			  	  #model.
			#getListSelector:.	  #getList.
			#getIndexSelector:.	#getIndex.
			#setIndexSelector:.	#setIndex:.
			#wrapSelector:.	  	 #wrapItem:.
			#hResizing:.			#spaceFill.
			#vResizing:.			#spaceFill		}
\end{method} 

As the specs are defined on class side, we have introduced a specific keyword \#model to create the binding between an instance and its spec.

\subsection{Spec Interpreter}

The goal of the Spec Interpreter is to build an instance starting from a spec.

So it iterates on a spec and recursively build each part of the spec.
Right now, for instance creation, it basically takes the name of a class to create an instance (as seen in the previous example), but a better abstraction could be done by using a Dictionary with keywords as key and morphic classes as values. It allows to separate the morphic part from the presenter, and to simply change the binding to be able to create other interfaces with the same presenter (a dictionary for seaside objects by example).

\begin{method}{Example of a recursive spec}
internSpec

	^	{  #PanelMorph.
			#changeTableLayout.
			#listDirection:. #bottomToTop.
			#addMorph:.   { #model. #listModel. #internSpec.	 }.
			#addMorph:.	  { #model. #textModel. #internSpec. 	}.
			#vResizing:. 	#spaceFill.
			#hResizing:. 	#spaceFill.	}.
\end{method} 

\section{Models and presenters construction}

\subsection{ComposableModel}

\verb?ComposableModel? is an abstract class which is the superclass of all applicative models used with specs.

There is a small API used to handle specs and the connections between the instances and their specs.

\begin{itemize}
	\item morph: an instance variable used to store the UI once the interpreter have created it.\ben{dunno if usefull}
	\item internSpec: this is the default spec. The mechanism assumes each applicative model have such a method on class side.
	\item title: this method return the title of the window used to render the presenter.
\end{itemize}

Then, each model have to define his own entry and exit points used to bind them together.

\subsection{Basic Models}

There is an applicative model for each basic UI widget \ben{now only list, text and button} with their entry points for each customizable behavior of the widget and exit point for information you want to retrieve.  \ben{not yet full coverage}

\paragraph{ListComposableModel} It is the model used to model a list.
Now the entry points are:
\begin{itemize}
	\item listHolder: a value holder which contains a list of elements to be displayed.
	\item wrapHolder: a value holder which contains a block used to wrap items from the list.
\end{itemize}
My exit point is:
\begin{itemize}
	\item selectionHolder: a selection value holder. It contains the index of the current selection and the currently selected object.
\end{itemize}

\paragraph{TextComposableModel} It is the model used to model a text area.
Now the entry points are:
\begin{itemize}
	\item textHolder: a value holder which contains the text displayed (it's also an exit point).
	\item actionToPerformHolder: a value holder which contains a block performed when the modified text is saved.
\end{itemize}
There are also entry points for colorization:
\begin{itemize}	
	\item aboutToStyleHolder: this value holder is evaluated to determine if the text should be colorize or not. It should return a boolean.
	\item behaviorHolder: this holder contains the class or metaclass related to the current text, for a good colorization.
\end{itemize}

\paragraph{ButtonComposableModel} It is the model used to model a button.
Now the entry points are:
\begin{itemize}
	\item actionHolder: a value holder which contains a block performed when the button is clicked.
	\item labelHolder: a value holder which contains the label of the button.
	\item stateHolder: a value holder containing a boolean which determines if the button is active or not.
	\item enabledHolder: a value holder containing a boolean which determines if the button is enabled or not.
	\end{itemize}
	
\section{ValueHolder}

\sd{should I add a subsection about ValueHolders ?}

\subsection*{ComposableValueHolder} 

A \verb?ComposableValueHolder? is a special value holder used to transform the value of another value holder.

Sometimes, a value is provided from a graphical widget as an entry point for another widget, but you need to transform this value to be used.

By example, you have two lists: a list of classes, and a list of methods. And you want the methods list to display the methods from the selected class.
The trick is the selection from the list of classes returns you a class. So you need a mechanism which allow you to transform the list of classes selection into a list of class, and you need it to do this transformation each time the selection changed.

And it's exactly what a \verb?ComposableValueHolder? does.
\paragraph{The protocol: } The only one method which should be used from \verb?ComposableValueHolder? is \mthind{on: aValueHolder do: aBlock}{on: aValueHolder do: aBlock}.
Each time \verb?aValueHolder?'s content changes, the \verb?ComposableValueHolder? will retrieve this value, perform \verb?aBlock? with this value, and store the result as its own content.

\paragraph{An example: } a \verb?ComposableValueHolder? used to transform the selection of a list of classes into a list of methods, ready to be used a an entry point for a list of methods.

\begin{code}{}
ComposableValueHolder on: (listOfClasses selectionHolder) do: [:index :selection | selection contents 
		ifNil: [ '' ]
		ifNotNil: [:class | class methods ]].
\end{code}

Here we need a link between the methods list and the text area (when a method is selected, the text zone have to display its source code).

So we have a value holder which changes each time another value holder changes.


\section{Conclusion}

As conclusion, you have now tools to create quickly UIs and to reuse them.
So you have to keep in mind that your tools can be reuse so think of providing an API to allow that.

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: