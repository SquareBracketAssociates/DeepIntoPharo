% $Author$
% $Date$
% $Revision$

% HISTORY:
% Chapter started by Damien C (2011-07-11)
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
% could change returns by answers
% Minor correction and new section about PPExpressionParser added by Guillaume Larcheveque
% 2013-01-23 - Added section about PetitParser Browser by Jan Kurs
% 2013-07-30 - Minor corrections and extended section with a debugging example by Jan Kurs

\newcommand{\jk}[1]{\nnbb{JanKurs}{#1}} % Jan Kurs 

%=================================================================
\ifx%
\wholebook%
\relax%
\input{PetitParser/visual-grammar}%
\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
    \input{visual-grammar}
    \begin{document}
\fi
%=================================================================
%\renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{PetitParser: Building Modular Parsers}
\chalabel{petitparser}

\chapterauthor{\authorjankurs{} \\ \authorguillaume{} \\ \authorlukas{}}

\newcommand{\ppmthind}[1]{\clsmthind{PPParser}{#1}}

Building parsers to analyze and transform data is a common task in
software development. In this chapter we present a powerful parser
framework called PetitParser. PetitParser combines many ideas from
various parsing technologies to model grammars and parsers as objects
that can be reconfigured dynamically. PetitParser was written by Lukas
Renggli as part of his work on the Helvetia system \footnote{\url{http://scg.unibe.ch/research/helvetia}} but it can be used
as a standalone library.

\section{Writing parsers with PetitParser}

PetitParser is a parsing framework different from many other popular
parser generators. PetitParser makes it easy to define parsers with
Smalltalk code and to dynamically reuse, compose, transform and extend
grammars. We can reflect on the resulting grammars and modify them
on-the-fly. As such PetitParser fits better the dynamic nature of
Smalltalk.

Furthermore, PetitParser is not based on tables such as SmaCC and
ANTLR. Instead it uses a combination of four alternative parser
methodologies: scannerless parsers, parser combinators, parsing
expression grammars and packrat parsers. As such PetitParser is more
powerful in what it can parse. Let's have a quick look at these four
parser methodologies:

\begin{description}
\item[Scannerless Parsers] combine what is usually done by two
  independent tools (scanner and parser) into one. This makes writing
  a grammar much simpler and avoids common problems when grammars are
  composed.

\item[Parser Combinators] are building blocks for parsers modeled as a
  graph of composable objects; they are modular and maintainable, and
  can be changed, recomposed, transformed and reflected upon.

\item[Parsing Expression Grammars] (PEGs) provide the notion of
  ordered choices. Unlike parser combinators, the ordered choice of
  PEGs always follows the first matching alternative and ignores other
  alternatives. Valid input always results in exactly one parse-tree,
  the result of a parse is never ambiguous.

\item[Packrat Parsers] give linear parse-time guarantees and avoid
  common problems with left-recursion in PEGs.
\end{description}

\subsection{Loading PetitParser}

Enough talking, let's get started. PetitParser is developed in Pharo,
and there are also versions for Java and Dart available. A ready made
image can be downloaded\footnotemark. To load PetitParser into an
existing image evaluate the following Gofer expression:

\footnotetext{\url{https://ci.inria.fr/moose/job/petitparser/}}

\begin{script}{Installing PetitParser}
Gofer new
  smalltalkhubUser: 'Moose' project: 'PetitParser';
  package: 'ConfigurationOfPetitParser';
  load.
(Smalltalk at: #ConfigurationOfPetitParser) perform: #loadDefault.
\end{script}

%\begin{script}{Installing PetitParser}
%Gofer new
%  renggli: 'petit';
%  package: 'PetitParser';
%  package: 'PetitTests';
%  load.
%\end{script}

%There are other packages in the same repository that provide additional 
%features: PetitSmalltalk is a complete Smalltalk grammar; PetitXml is an XML 
%grammar; PetitJson is a JSON grammar; PetitAnalyzer provides functionality to 
%analyze and transform grammars; and PetitGui is a Glamour IDE (see 
%\charef{glamour}) for writing complex grammars. We are not going to use any of 
%these packages for now.

More information on how to get PetitParser can be found on the chapter
about petit parser in the Moose book.\footnotemark

\footnotetext{\url{http://www.themoosebook.org/book/internals/petit-parser}}

\subsection{Writing a simple grammar}

Writing grammars with PetitParser is as simple as writing Smalltalk
code. For example, to define a grammar that parses identifiers
starting with a letter followed by zero or more letters or digits is
defined and used as follows:

\begin{script}[identifier]{Creating our first parser to parse identifiers}
|identifier|
identifier := #letter asParser , #word asParser star.
identifier parse: 'a987jlkj' --> #($a #($9 $8 $7 $j $l $k $j))
\end{script}

\tikzgrammarfig{identifier}{
  {
    \node (identifier) [production] {identifier:}; \&
    \node (p1)     [point]       {};           \&
    \node (letter) [terminal]    {letter};     \&
    \node (p3a)    [point]       {};           \&
    \node (p3b)    [point]       {};           \&
    \node (word)   [terminal] {word};       \&
    \node (p11a)    [point]       {};           \&
    \node (p11b)   [point]       {};           \&
    \node (p11c)    [point]       {};           \\
  };
  { [start chain]
    \chainin (p1);
    \chainin (letter) [join=by tip];
    \chainin (word)  [join=by tip];
    \chainin (p11c)     [join=by tip];
    \chainin (p11b)   [join,join=with p3a by {skip loop=-5mm,tip}];
    \chainin (p3b)    [join=with p11a by {skip loop=5mm,tip}];
  }
}


\subsection{A graphical notation}

\syntaxref{identifier} presents a syntax diagram of the identifier
parser. Each box represents a parser. The arrows between the boxes
represent the flow in which input is consumed. The rounded boxes are
elementary parsers (terminals). The squared boxes (not shown on this
figure) are parsers composed of other parsers (non terminals).

If you inspect the object \ct{identifier} of the previous script, you'll notice 
that it is an instance of a \clsind{PPSequenceParser}. If you dive further into 
the object you will notice the following tree of different parser objects:

\begin{script}{Composition of parsers used for the identifier parser}
PPSequenceParser (accepts a sequence of parsers)
    PPPredicateObjectParser (accepts a single letter)
    PPPossessiveRepeatingParser (accepts zero or more instances of another parser)
       PPPredicateObjectParser (accepts a single word character)
\end{script}

The root parser is a sequence parser because the \ct{,} (comma)
operator creates a sequence of (1) a letter parser and (2) zero or
more word character parser. The root parser first child is a predicate
object parser created by the \ct{#letter asParser} expression. This
parser is capable of parsing a single letter as defined by the
\clsmthind{Character}{isLetter} method. %
The second child is a repeating parser created by the
\ct{star} call. This parser uses its child parser (another predicate
object parser) as much as possible on the input (\ie{} it is a
\emph{greedy} parser). Its child parser is a predicate object parser
created by the \ct{#word asParser} expression. This parser is capable
of parsing a single digit or letter as defined by the
\clsmthind{Character}{isDigit} and \clsmthind{Character}{isLetter}
methods.

\subsection{Parsing some input}

To actually parse a string (or stream) we use the method
\ppmthind{parse:} as follows:

\begin{script}{Parsing some input strings with the identifier parser}
identifier parse: 'yeah'.          --> #($y #($e $a $h))
identifier parse: 'f123'.           --> #($f #($1 $2 $3))
\end{script}

While it seems odd to get these nested arrays with characters as a
return value, this is the default decomposition of the input into a
parse tree. We'll see in a while how that can be customized.

If we try to parse something invalid we get an instance of
\clsind{PPFailure} as an answer:

\begin{script}{Parsing invalid input results in a failure}
identifier parse: '123'.           --> letter expected at 0
\end{script}

This parsing results in a failure because the first character (\ct{1})
is not a letter. Instances of \clsind{PPFailure} are the only objects in
the system that answer with true when you send the message
\ct{#isPetitFailure}. Alternatively you can also use
\ppmthind{parse:onError:} to throw an exception in case of an error:

\begin{code}{}
identifier
   parse: '123'
   onError: [ :msg :pos | self error: msg ].
\end{code}

If you are only interested if a given string (or stream) matches or
not you can use the following constructs:

\begin{script}{Checking that some inputs are identifiers}
identifier matches: 'foo'.        --> true
identifier matches: '123'.        --> false
identifier matches: 'foo()'.      --> true
\end{script}

The last result can be surprising: % <- don't remove the comment
indeed, a parenthesis is neither a digit nor a letter as was specified
by the \ct{#word asParser} expression. In fact, the \ct{identifier}
parser matches ``foo'' and this is enough for the \ppmthind{matches:}
call to return \ct{true}. The result would be similar with the use of
\ct{parse:} which would return \ct{#($f #($o $o))}. %$

If you want to be sure that the complete input is matched, use the
message \ppmthind{end} as follows:

\begin{script}{Ensuring that the whole input is matched using \ppmthind{end}}
identifier end matches: 'foo()'.   --> false
\end{script}

The \ppmthind{end} message creates a new parser that matches the end of
input. To be able to compose parsers easily, it is important that
parsers do not match the end of input by default. Because of this, you
might be interested to find all the places that a parser can match
using the message \ppmthind{matchesSkipIn:} and \ppmthind{matchesIn:}.

\begin{script}{Finding all matches in an input}
identifier matchesSkipIn: 'foo 123 bar12'.
 --> an OrderedCollection(#($f #($o $o)) #($b #($a $r $1 $2)))

identifier matchesIn: 'foo 123 bar12'.
 --> an OrderedCollection(#($f #($o $o)) #($o #($o)) #($o #()) #($b #($a $r $1 $2)) #($a #($r $1 $2)) #($r #($1 $2)))
\end{script}

The \ppmthind{matchesSkipIn:} method returns a collection of arrays
containing what has been matched. This function avoids parsing the
same character twice. The method \ppmthind{matchesIn:} does a similar
job but returns a collection with all possible sub-parsed elements:
\eg{} evaluating \ct{identifier matchesIn: 'foo 123 bar12'} returns a
collection of 6 elements.

Similarly, to find all the matching ranges (index of first character
and index of last character) in the given input one can use either
\ppmthind{matchingSkipRangesIn:} or \ppmthind{matchingRangesIn:} as
shown by the script below:

\begin{script}{Finding all matched ranges in an input}
identifier matchingSkipRangesIn: 'foo 123 bar12'.
 --> an OrderedCollection((1 to: 3) (9 to: 13))

identifier matchingRangesIn: 'foo 123 bar12'.
 --> an OrderedCollection((1 to: 3) (2 to: 3) (3 to: 3) (9 to: 13) (10 to: 13) (11 to: 13))
\end{script}

\subsection{Different kinds of parsers}

PetitParser provide a large set of ready-made parser that you can
compose to consume and transform arbitrarily complex languages. The
terminal parsers are the most simple ones. We've already seen a few of
those, some more are defined in the protocol \tabref{terminal-parsers}.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \textbf{Terminal Parsers} & \textbf{Description}                                \\
    \midrule
    \$a asParser              & Parses the character \$a.                           \\
    'abc' asParser            & Parses the string 'abc'.                            \\
    \#any asParser            & Parses any character.                               \\
    \#digit asParser          & Parses one digit (0..9).                            \\
    \#letter asParser         & Parses one letter (a..z and A..Z).                  \\
    \#word asParser           & Parses a digit or letter.                           \\
    \#blank asParser          & Parses a space or a tabulation.                     \\
    \#newline asParser        & Parses the carriage return or line feed characters. \\
    \#space asParser          & Parses any white space character including new line.\\
    \#tab asParser            & Parses a tab character.                       \\
    \#lowercase asParser      & Parses a lowercase character.                       \\
    \#uppercase asParser      & Parses an uppercase character.                      \\
    nil asParser	          & Parses nothing.                                     \\
  \end{tabular}
  \caption{PetitParser pre-defines a multitude of terminal parsers}
  \label{tab:terminal-parsers}
\end{table}

The class side of \clsind{PPPredicateObjectParser} provides a lot of
other factory methods that can be used to build more complex terminal
parsers. To use them, send the message \ppmthind{asParser} to a symbol
containing the name of the factory method (such as \ct{#punctuation}
\ct{asParser}).

The next set of parsers are used to combine other parsers together and
is defined in the protocol \tabref{parser-combinators}.

\begin{table}
  \centering
  \begin{tabular}{lp{.6\textwidth}}
    \textbf{Parser Combinators} & \textbf{Description}                                                \\
    \midrule
    p1 , p2                     & Parses p1 followed by p2 (sequence).                                \\
    p1 / p2                     & Parses p1, if that doesn't work parses p2.                          \\
    p star                      & Parses zero or more p.                                              \\
    p plus                      & Parses one or more p.                                               \\
    p optional                  & Parses p if possible.                                               \\
    p and                       & Parses p but does not consume its input.                            \\
    p negate                    & Parses p and succeeds when p fails.                                 \\
    p not                       & Parses p and succeeds when p fails, but does not consume its input. \\
    p end                       & Parses p and succeeds only at the end of the input.                 \\
    p times: n                  & Parses p exactly n times.                                           \\
    p min: n max: m             & Parses p at least n times up to m times                             \\
    p starLazy: q               & Like star but stop consumming when q succeeds                       \\

  \end{tabular}
  \caption{PetitParser pre-defines a multitude of parser combinators}
  \label{tab:parser-combinators}
\end{table}

As a simple example of parser combination, the following definition of
the \ct{identifier2} parser is equivalent to our previous definition
of \ct{identifier}:

\begin{script}[identifier2]{A different way to express the \ct{identifier} parser}
identifier2 := #letter asParser , (#letter asParser / #digit asParser) star.
\end{script}

\tikzgrammarfig{identifier2}{
  {
    \node (identifier2) [production] {identifier2:}; \&
    \node (p1)     [point]       {};           \&
    \node (letter1) [terminal]    {letter};     \&
    \node (p2a)    [point]       {};           \&
    \node (p2b)    [point]       {};           \&
    \node (p2c)    [point]       {};           \&
    \node (letter2)   [terminal] {letter};       \&
    \node (p3a)    [point]       {};           \&
    \node (p3b)   [point]       {};           \&
    \node (p3c)   [point]       {};           \&
    \node (p3d)    [point]       {};           \\


    \& \& \& \& \&
    \node (p10)   [point]       {};           \&
    \node (digit)   [terminal] {digit};       \&
    \node (p11)   [point]       {};           \& \\
  };
  { [start chain]
    \chainin (p1);
    \chainin (letter1) [join=by tip];
    \chainin (letter2)  [join=by tip];
    \chainin (p3d)     [join=by tip];
    \chainin (p2b)    [join=with p3b by {skip loop=5mm,tip}];
    \chainin (p10)    [join=with p2c];
    \chainin (digit)  [join=by tip];
    \chainin (p11)  [join];
    \chainin (p3a)    [join=with p11 by tip];
    \chainin (p3c)   [join,join=with p2a by {skip loop=-15mm,tip}];
  }
}

\subsection{Parser action}

To define an action or transformation on a parser we can use one of
the messages \ppmthind{==>}, \ppmthind{flatten}, \ppmthind{token} and
\ppmthind{trim} defined in the protocol \tabref{action-parsers}.

\begin{table}[h]
  \centering
  \begin{tabular}{ll}
    \textbf{Action Parsers} & \textbf{Description}                                               \\
    \midrule
    p flatten               & Creates a string from the result of \lct{p}.                       \\
    p token                 & Similar to \lct{flatten} but returns a \lct{PPToken} with details. \\
    p trim                  & Trims white spaces before and after \lct{p}.                       \\
    p trim: trimParser      & Trims whatever \lct{trimParser} can parse (\eg{} comments).        \\
    p ==> aBlock            & Performs the transformation given in \lct{aBlock}.                 \\
  \end{tabular}
  \caption{PetitParser pre-defines a multitude of action parsers}
  \label{tab:action-parsers}
\end{table}

To return a string of the parsed identifier instead of getting an
array of matched elements, configure the parser by sending it the
message \ppmthind{flatten}.

\begin{script}{Using flatten so that the parsing result is a string}
|identifier|
identifier := (#letter asParser , (#letter asParser / #digit asParser) star).
identifier parse: 'ajka0'          -->  #($a #($j $k $a $0))

identifier flatten parse: 'ajka0'          --> 'ajka0'
\end{script}

% $ <-- to compensate for odd number

The message \ppmthind{token} is similar to \ct{flatten} but returns a
\ct{PPToken} that provide much more contextual information like the
collection where the token was located and its position in the
collection.

Sending the message \ppmthind{trim} configures the parser to ignore
white spaces at the beginning and end of the parsed result. In the
following, using the first parser on the input leads to an error
because the parser does not accept the spaces. With the
second parser, spaces are ignored and removed from the result.

\begin{script}{Using \ppmthind{trim} to ignore spaces}
|identifier|
identifier := (#letter asParser , #word asParser star) flatten.
identifier parse: '  ajka   '          -->  letter expected at 0

identifier trim parse: '  ajka   '          --> 'ajka'
\end{script}

Sending the message \ct{trim} is equivalent to calling \ppmthind{trim:} with
\ct{#space}~\ct{asParser} as a parameter. That means \ct{trim:} can be
useful to ignore other data from the input, source code comments for
example:

\begin{script}{Using \ppmthind{trim:} to ignore comments}
| identifier comment ignorable line |
identifier := (#letter asParser , #word asParser star) flatten.
comment := '//' asParser, #newline asParser negate star.
ignorable := comment / #space asParser.
line := identifier trim: ignorable.
line parse: '// This is a comment
oneIdentifier // another comment'          --> 'oneIdentifier'
\end{script}

The message \ppmthind{==>} lets you specify a block to be executed
when the parser matches an input. The next section presents several
examples. Here is a simple way to get a number from its string
representation.

\begin{script}[number]{Parsing integers}
number :=  #digit asParser plus flatten ==> [ :str | str asNumber ].
number parse: '123'                     --> 123
\end{script}

\tikzgrammarfig{number}{
  {
    \node (number) [production] {number:}; \&
    \node (p1a)     [point]       {};           \&
    \node (p1b)     [point]       {};           \&
    \node (digit) [terminal]    {digit};     \&
    \node (p2a)    [point]       {};           \&
    \node (p2b)    [point]       {};           \\
  };
  { [start chain]
    \chainin (p1a);
    \chainin (digit) [join=by tip];
    \chainin (p2b)     [join=by tip];
    \chainin (p1b)    [join=with p2a by {skip loop=5mm,tip}];
  }
}

The table~\ref{tab:action-parsers} shows the basic elements to build
parsers. There are a few more well documented and tested factory
methods in the \ct{operators} protocols of \clsind{PPParser}. If you
want to know more about these factory methods, browse these protocols.
An interesting one is \ct{separatedBy:} which answers a new parser
that parses the input one or more times, with separations specified by
another parser.

\subsection{Writing a more complicated grammar}

We now write a more complicated grammar for evaluating simple
arithmetic expressions. With the grammar for a number (actually an
integer) defined above, the next step is to define the productions for
addition and multiplication in order of precedence. Note that we
instantiate the productions as \clsind{PPDelegateParser} upfront,
because they recursively refer to each other. The method
\ct{#setParser:} then resolves this recursion. The following script
defines three parsers for the addition, multiplication and parenthesis
(see \syntaxref{arithmetic} for the related syntax diagram):

\begin{script}[arithmetic]{Parsing arithmetic expressions}
term := PPDelegateParser new.
prod := PPDelegateParser new.
prim := PPDelegateParser new.

term setParser: (prod , $+ asParser trim , term ==> [ :nodes | nodes first + nodes last ])
                     / prod.
prod setParser: (prim , $* asParser trim , prod ==> [ :nodes | nodes first * nodes last ])
                     / prim.
prim setParser: ($( asParser trim , term , $) asParser trim ==> [ :nodes | nodes second ])
                     / number.
\end{script}

The term parser is defined as being either (1) a prod followed by `+',
followed by another term or (2) a prod. In case (1), an action block
asks the parser to compute the arithmetic addition of the value of the
first node (a prod) and the last node (a term). The prod parser is
similar to the term parser. The prim parser is interesting in that it
accepts left and right parenthesis before and after a term and has an
action block that simply ignores them.

To understand the precedence of productions, see
Figure~\ref{fig:expression-precedence}. The root of the tree in this
figure (\ct{term}), is the production that is tried first. A \ct{term}
is either a $+$ or a \ct{prod}. The \ct{term} production comes first
because $+$ as the lowest priority in mathematics.

\begin{figure}
  \centering
\tikzgrammar{
  {
    \node (term) [production] {term:};           \&
    \node (p1a)     [point]       {};           \&
    \node (p1b)     [point]       {};           \&
    \node (p1c)     [point]       {};           \&
    \node (prod1) [nonterminal]    {prod};      \&
    \node (p2)     [point]       {};            \&
    \node (plus) [terminal]    {+};             \&
    \node (p3)    [point]       {};             \\

    \&
    \&
    \&
    \node (p10)     [point]       {};           \&
    \node (prod2) [nonterminal]    {prod};     \&
    \&
    \&
    \&
    \node (p11)    [point]       {};           \\
    \\
    \node (prod) [production] {prod:}; \&
    \node (p21a)     [point]       {};           \&
    \node (p21b)     [point]       {};           \&
    \node (p21c)     [point]       {};           \&
    \node (prim1) [nonterminal]    {prim};     \&
    \node (p22)     [point]       {};           \&
    \node (mult) [terminal]    {*};     \&
    \node (p23)    [point]       {};           \\

    \&
    \&
    \&
    \node (p30)     [point]       {};           \&
    \node (prim2) [nonterminal]    {prim};     \&
    \&
    \&
    \&
    \node (p31)    [point]       {};           \\
    \\
    \node (prim) [production] {prim:}; \&
    \node (p41a)     [point]       {};           \&
    \node (p41b)     [point]       {};           \&
    \node (lpar) [terminal]    {(};     \&
    \node (term4) [nonterminal]    {term};     \&
    \node (p43)    [point]       {};         \&
    \node (rpar) [terminal]    {)};     \&
    \node (p44a)     [point]       {};           \&
    \node (p44b)     [point]       {};             \\
    \&
    \&
    \node (p51)     [point]       {};           \&
    \&
    \node (number5) [nonterminal]    {number};     \&
    \&
    \&
    \node (p52)     [point]       {};           \\
  };
    {[start chain]
    \chainin (p1a);
    \chainin (prod1) [join=by tip];
    \chainin (plus) [join=by tip];
    \chainin (p3)    [join];
    \chainin (p1b)    [join=with p3 by {skip loop=5mm,tip}];
    \chainin (p10)    [join=with p1c];
    \chainin (prod2)    [join=by tip];
    \chainin (p11)    [join=by tip];

    \chainin (p21a);
    \chainin (prim1) [join=by tip];
    \chainin (mult) [join=by tip];
    \chainin (p23)    [join];
    \chainin (p21b)    [join=with p23 by {skip loop=5mm,tip}];
    \chainin (p30)    [join=with p21c];
    \chainin (prim2)    [join=by tip];
    \chainin (p31)    [join=by tip];

    \chainin (p41a);
    \chainin (lpar) [join=by tip];
    \chainin (term4) [join=by tip];
    \chainin (rpar) [join=by tip];
    \chainin (p44b)    [join=by tip];
    \chainin (p51) [join=with p41b];
    \chainin (number5) [join=by tip];
    \chainin (p52) [join];
    \chainin (p44a) [join=by tip];
  }
}
  \caption{Syntax diagram representation for the term, prod, and prim parsers defined in \scrref{arithmetic}}
  \label{fig:syntax-arithmetic}
\end{figure}

\begin{figure}
  \centering
  \begin{tikzpicture}
    [ level distance=.7cm, growth parent anchor=south, sibling distance=2cm,
     thick]
    \node (term) {term}
    child{ node  {$+$} }
    child{
      node  {prod}
      child{ node {$*$} }
      child{ node {prim}
        child { node (parens) {parens} }
        child { node  {number} }
      }
    };
  \end{tikzpicture}

  \caption{Explains how to understand the precedence of productions. An expression is a term which is  either a sum or a production. It is necessary to recognize sums first as they have the lowest priority. A production is either a multiplication or a primitive. A primitive is either a parenthesised expression or a number.}
  \label{fig:expression-precedence}
\end{figure}

To make sure that our parser consumes all input we wrap it with the
\ct{end} parser into the \ct{start} production:

\begin{code}{}
start := term end.
\end{code}

That's it, we can now test our parser:

\begin{script}{Trying our arithmetic expressions evaluator}
start parse: '1 + 2 * 3'.       --> 7
start parse: '(1 + 2) * 3'.     --> 9
\end{script}

\section{Composite grammars with PetitParser}

In the previous section we saw the basic principles of PetitParser and
gave some introductory examples. In this section we are going to
present a way to define more complicated grammars. We continue where
we left off with the arithmetic expression grammar.

Writing parsers as a script as we did previously can be cumbersome,
especially when grammar productions are mutually recursive and refer
to each other in complicated ways. Furthermore a grammar specified in
a single script makes it unnecessary hard to reuse specific parts of
that grammar. Luckily there is \clsind{PPCompositeParser} to the rescue.

\subsection{Defining the grammar}

As an example let's create a composite parser using the same
expression grammar we built in the last section but this time we define
it inside a  class subclass of \ct{PPCompositeParser}.

\begin{script}{Creating a class to hold our arithmetic expression grammar}
PPCompositeParser subclass: #ExpressionGrammar
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PetitTutorial'
\end{script}

Again we start with the grammar for an integer number. Define the
method \ct{number} as follows:

\begin{script}{Implementing our first parser as a method}
ExpressionGrammar>>number
   ^ #digit asParser plus flatten trim ==> [ :str | str asNumber ]
\end{script}

Every production in \ct{ExpressionGrammar} is specified as a method
that returns its parser. Similarly, we define the productions
\ct{term}, \ct{prod}, \ct{mul}, and \ct{prim}. Productions refer to
each other by reading the respective instance variable of the same
name and PetitParser takes care of initializing these instance variables
for you automatically. We let Pharo automatically add the necessary
instance variables as we refer to them for the first time. We obtain
the following class definition:

\begin{script}{Creating a class to hold our arithmetic expression grammar}
PPCompositeParser subclass: #ExpressionGrammar
   instanceVariableNames: 'add prod term mul prim parens number'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PetitTutorial'
\end{script}

\begin{script}{Defining more expression grammar parsers, this time with no associated action}
ExpressionGrammar>>term
   ^ add / prod

ExpressionGrammar>>add
   ^ prod , $+ asParser trim , term

ExpressionGrammar>>prod
   ^ mul / prim

ExpressionGrammar>>mul
   ^ prim , $* asParser trim , prod

ExpressionGrammar>>prim
   ^ parens / number

ExpressionGrammar>>parens
   ^ $( asParser trim , term , $) asParser trim
\end{script}

Contrary to our previous implementation we do not define the
production actions yet (what we previously did by using
\ppmthind{==>}); and we factor out the parts for addition (\ct{add}),
multiplication (\ct{mul}), and parenthesis (\ct{parens}) into separate
productions. This will give us better reusability later on. For
example, a subclass may override such methods to produce slightly
different production output. Usually, production methods are
categorized in a protocol named \ct{grammar} (which can be refined
into more specific protocol names when necessary such as
\ct{grammar-literals}).

Last but not least we define the starting point of the expression
grammar. This is done by overriding
\clsmthind{PPCompositeParser}{start} in the \ct{ExpressionGrammar}
class:

\begin{script}{Defining the starting point of our expression grammar parser}
ExpressionGrammar>>start
   ^ term end
\end{script}

Instantiating the \ct{ExpressionGrammar} gives us an expression parser
that returns a default abstract-syntax tree:

\begin{script}{Testing our parser on simple arithmetic expressions}
parser := ExpressionGrammar new.
parser parse: '1 + 2 * 3'.       --> #(1 $+ #(2 $* 3))
parser parse: '(1 + 2) * 3'.     --> #(#($( #(1 $+ 2) $)) $* 3)
\end{script}

\subsection{Writing dependent grammars}

You can easily reuse parsers defined by other grammars. For example,
imagine you want to create a new grammar that reuses the definition of
\ct{number} in the \ct{ExpressionGrammar} we have just defined. For
this, you have to declare a dependency to \ct{ExpressionGrammar}:

\begin{script}{Reusing the \ct{number} parser from the \ct{ExpressionGrammar} grammar}
PPCompositeParser subclass: #MyNewGrammar
  instanceVariableNames: 'number'
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'

MyNewGrammar class>>dependencies
  "Answer a collection of PPCompositeParser classes that this parser directly dependends on."
  ^ {ExpressionGrammar}

MyNewGrammar>>number
  "Answer the same parser as ExpressionGrammar>>number."
  ^ (self dependencyAt: ExpressionGrammar) number
\end{script}

\subsection{Defining an evaluator}

Now that we have defined a grammar we can reuse this definition to
implement an evaluator. To do this we create a \emph{subclass} of
\ct{ExpressionGrammar} called \ct{ExpressionEvaluator}.

\begin{script}{Separating the grammar from the evaluator by creating a subclass}
ExpressionGrammar subclass: #ExpressionEvaluator
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PetitTutorial'
\end{script}

We then redefine the implementation of \ct{add}, \ct{mul} and
\ct{parens} with our evaluation semantics. This is accomplished by
calling the super implementation and adapting the returned parser as shown in the following methods.

\begin{script}{Refining the definition of some parsers to evaluate arithmetic expressions}
ExpressionEvaluator>>add
   ^ super add ==> [ :nodes | nodes first + nodes last ]

ExpressionEvaluator>>mul
   ^ super mul ==> [ :nodes | nodes first * nodes last ]

ExpressionEvaluator>>parens
   ^ super parens ==> [ :nodes | nodes second ]
\end{script}

The evaluator is now ready to be tested:

\begin{script}{Testing our evaluator on simple arithmetic expressions}
parser := ExpressionEvaluator new.
parser parse: '1 + 2 * 3'.       --> 7
parser parse: '(1 + 2) * 3'.     --> 9
\end{script}

\subsection{Defining a Pretty-Printer}

We can reuse the grammar for example to define a simple pretty printer.
This is as easy as subclassing \ct{ExpressionGrammar} again!

\begin{script}{Separating the grammar from the pretty printer by creating a subclass}
ExpressionGrammar subclass: #ExpressionPrinter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'

ExpressionPrinter>>add
  ^ super add ==> [:nodes | nodes first , ' + ' , nodes third]

ExpressionPrinter>>mul
  ^ super mul ==> [:nodes | nodes first , ' * ' , nodes third]

ExpressionPrinter>>number
  ^ super number ==> [:num | num printString]

ExpressionPrinter>>parens
  ^ super parens ==> [:node | '(' , node second , ')']
\end{script}

This pretty printer can be tried out as shown by the following expressions.

\begin{script}{Testing our pretty printer on simple arithmetic expressions}
parser := ExpressionPrinter new.
parser parse: '1+2 *3'.          --> '1 + 2 * 3'
parser parse: '(1+ 2 )* 3'.      --> '(1 + 2) * 3'
\end{script}

\subsection{Easy expressions with \lct{PPExpressionParser}}

PetitParser proposes a powerful tool to create expressions;
\ct{PPExpressionParser} is a parser to conveniently define an expression
grammar with prefix, postfix, and left- and right-associative infix
operators. The operator-groups are defined in descending precedence.

\begin{script}{The ExpressionGrammar we previously defined can be implemented in few lines}

| expression parens number |
expression := PPExpressionParser new.
parens := $( asParser token trim , expression , $) asParser token trim
==> [ :nodes | nodes second ].
number := #digit asParser plus flatten trim ==> [ :str | str asNumber ].

expression term: parens / number.

expression
  group: [ :g |
    g left: $* asParser token trim do: [ :a :op :b | a * b ].
    g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];
  group: [ :g |
    g left: $+ asParser token trim do: [ :a :op :b | a + b ].
    g left: $- asParser token trim do: [ :a :op :b | a - b ] ].
\end{script}

\begin{script}{Now our parser is also able to manage subtraction and division}
expression parse: '1-2/3'.       --> (1/3)
\end{script}

How do you decide when to create a subclass of \ct{PPCompositeParser}
or instantiate \ct{PPExpressionParser}? On the one hand, you should
instantiate a \ct{PPExpressionParser} if you want to do a small parser
for a small task. On the other hand, if you have a grammar that's
composed of many parsers, you should subclass \ct{PPCompositeParser}.

\section{Testing a grammar}

The PetitParser contains a framework dedicated to testing your
grammars. Testing a grammar is done by subclassing
\clsind{PPCompositeParserTest} as follows:

\begin{script}{Creating a class to hold the tests for our arithmetic expression grammar}
PPCompositeParserTest subclass: #ExpressionGrammarTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'
\end{script}

It is then important that the test case class references the parser
class: this is done by overriding the
\clsmthind{PPCompositeParserTest}{parserClass} method in
\ct{ExpressionGrammarTest}:

\begin{script}{Linking our test case class to our parser}
ExpressionGrammarTest>>parserClass
  ^ ExpressionGrammar
\end{script}

Writing a test scenario is done by implementing new methods in
\ct{ExpressionGrammarTest}:

\begin{script}{Implementing tests for our arithmetic expression grammar}
ExpressionGrammarTest>>testNumber
  self parse: '123 ' rule: #number.

ExpressionGrammarTest>>testAdd
  self parse: '123+77' rule: #add.
\end{script}

These tests ensure that the \ct{ExpressionGrammar} parser can parse
some expressions using a specified production rule. Testing the
evaluator and pretty printer is similarly easy:

\begin{script}{Testing the evaluator and pretty printer}
ExpressionGrammarTest subclass: #ExpressionEvaluatorTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'

ExpressionEvaluatorTest>>parserClass
  ^ ExpressionEvaluator

ExpressionEvaluatorTest>>testAdd
  super testAdd.
  self assert: result equals: 200

ExpressionEvaluatorTest>>testNumber
  super testNumber.
  self assert: result equals: 123

ExpressionGrammarTest subclass: #ExpressionPrinterTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'

ExpressionPrinterTest>>parserClass
  ^ ExpressionPrinter

ExpressionPrinterTest>>testAdd
  super testAdd.
  self assert: result equals: '123 + 77'

ExpressionPrinterTest>>testNumber
  super testNumber.
  self assert: result equals: '123'
\end{script}

\section{Case Study: A JSON Parser}

\lstnewenvironment{jsonscript}[2][defaultlabel]{%
\renewcommand{\lstlistingname}{Script}%
	\lstset{
		% frame=lines,
		frame=single,
		framerule=0pt,
		mathescape=false,
		name={Script},
		caption={\emph{Defining the JSON parser for #2 as represented in \syntaxjsonref{#2}}},
		label={scr:json-#2}
	}
}{}
\newcommand{\syntaxjsonref}[1]{\figref{syntax-json-#1}}
\newcommand{\tikzgrammarjsonfig}[2]{%
  \begin{figure}
    \centering
    \tikzgrammar{#2}
    \caption{Syntax diagram representation for the JSON #1 parser defined in \scrref{json-#1}}
\label{fig:syntax-json-#1}
\end{figure}
}

In this section we illustrate PetitParser through the development of a JSON 
parser. JSON is a lightweight data-interchange format defined in 
\url{http://www.json.org}. We are going to use the specification on this 
website to define our own JSON parser.

JSON is a simple format based on nested pairs and arrays. The
following script gives an example taken from Wikipedia
\url{http://en.wikipedia.org/wiki/JSON}

\begin{script}{An example of JSON}
{	"firstName" : "John",
	"lastName" : "Smith",
	"age" : 25,
	"address" :
  		{ 	"streetAddress" : "21 2nd Street",
			"city" : "New York",
		    "state" : "NY",
		    "postalCode" : "10021"	},
	"phoneNumber":
  		[
			{	"type" : "home",
		      	"number" : "212 555-1234"	},
			{	"type" : "fax",
				"number" : "646 555-4567"	}	]	}
\end{script}


JSON consists of object definitions (between curly braces ``\{\}'')
and arrays (between square brackets ``[]''). An object definition is a
set of key/value pairs whereas an array is a list of values. The
previous JSON example then represents an object (a person) with
several key/value pairs (\eg{} for the person's first name, last name,
and age). The address of the person is represented by another object
while the phone number is represented by an array of objects.


First we define a grammar as subclass of \ct{PPCompositeParser}. Let us call it
\ct{PPJsonGrammar}

\begin{script}{Defining the JSON grammar class}
PPCompositeParser subclass: #PPJsonGrammar
  instanceVariableNames: ''
  classVariableNames: 'CharacterTable'
  poolDictionaries: ''
  category: 'PetitJson-Core'
\end{script}

We define the \ct{CharacterTable} class variable since we will later
use it to parse strings.

\subsection{Parsing objects and arrays}

The syntax diagrams for JSON objects and arrays are
in~\syntaxjsonref{object} and~\syntaxjsonref{array}. A PetitParser can
be defined for JSON objects with the following code:

\begin{jsonscript}{object}
PPJsonGrammar>>object
  ^ ${ asParser token trim , members optional , $} asParser token trim

PPJsonGrammar>>members
  ^ pair separatedBy: $, asParser token trim

PPJsonGrammar>>pair
  ^ stringToken , $: asParser token trim , value
\end{jsonscript}

The only new thing here is the call to the \ppmthind{separatedBy:}
convenience method which answers a new parser that parses the receiver
(a value here) one or more times, separated by its parameter parser (a
comma here).

\tikzgrammarjsonfig{object}{
  {
    \node (object) [production] {object:}; \&
    \node (p01a) [point] {}; \&
    \node (openbrace) [terminal] {\{}; \&
    \node (p02a) [point] {}; \&
    \node (members) [nonterminal] {members}; \&
    \node (p03a) [point] {}; \&
    \node (closebrace) [terminal] {\}}; \&
    \node (p04a) [point] {}; \\

    \node (p11a) [point] {}; \&
    \& \&
    \node (p12a) [point] {}; \&
    \node (comma) [terminal] {,}; \&
    \node (p13a) [point] {}; \\

    \node (pmembers) [production] {members:}; \&
    \node (p21a) [point] {}; \& \&
    \node (p21b) [point] {}; \&
    \node (pair) [nonterminal] {pair}; \&
    \node (p22a) [point] {}; \& \&
    \node (p22b) [point] {}; \\

    \node (ppair) [production] {pair:}; \&
    \node (p31a) [point] {}; \& \&
    \node (stringToken) [nonterminal, align=center, style={text height=3.5ex}] {string \\ Token}; \&
    \node (comma2) [terminal] {:}; \&
    \node (value) [nonterminal] {value}; \&
    \& \&
    \node (p32a) [point] {}; \\
  };
  { [start chain]
    \chainin (p01a);
    \chainin (openbrace) [join=by tip];
    \chainin (members) [join=by tip];
    \chainin (closebrace) [join=by tip];
    \chainin (p04a) [join=by tip];

    \chainin (p03a) [join=with p02a by {skip loop=-5mm, tip}];

    \chainin (p21a);
    \chainin (pair) [join=by tip];
    \chainin (p22b) [join=by tip];

    \chainin (p22a);
    \chainin (p13a) [join];
    \chainin (comma) [join=by tip];
    \chainin (p12a) [join];
    \chainin (p21b) [join=by tip];

    \chainin (p31a);
    \chainin (stringToken) [join=by tip];
    \chainin (comma2) [join=by tip];
    \chainin (value) [join=by tip];
    \chainin (p32a) [join=by tip];
  }
}

Arrays are much simpler to parse as depicted in \tscrref{json-array}.

\begin{jsonscript}{array}
PPJsonGrammar>>array
  ^ $[ asParser token trim ,
         elements optional ,
    $] asParser token trim

PPJsonGrammar>>elements
  ^ value separatedBy: $, asParser token trim
\end{jsonscript}

% $ <-- to cancel previous one for Emacs highlighting

\tikzgrammarjsonfig{array}{
  {
    \node (array) [production] {array:}; \&
    \node (p01a) [point] {}; \&
    \node (openbrace) [terminal] {[}; \&
    \node (p02a) [point] {}; \&
    \node (elements) [nonterminal] {elements}; \&
    \node (p03a) [point] {}; \&
    \node (closebrace) [terminal] {]}; \&
    \node (p04a) [point] {}; \\

    \node (p11a) [point] {}; \&
    \& \&
    \node (p12a) [point] {}; \&
    \node (comma) [terminal] {,}; \&
    \node (p13a) [point] {}; \\

    \node (pelements) [production] {elements:}; \&
    \node (p21a) [point] {}; \& \&
    \node (p21b) [point] {}; \&
    \node (value) [nonterminal] {value}; \&
    \node (p22a) [point] {}; \& \&
    \node (p22b) [point] {}; \\
  };
  { [start chain]
    \chainin (p01a);
    \chainin (openbrace) [join=by tip];
    \chainin (elements) [join=by tip];
    \chainin (closebrace) [join=by tip];
    \chainin (p04a) [join=by tip];

    \chainin (p03a) [join=with p02a by {skip loop=-5mm, tip}];

    \chainin (p21a);
    \chainin (value) [join=by tip];
    \chainin (p22b) [join=by tip];

    \chainin (p22a);
    \chainin (p13a) [join];
    \chainin (comma) [join=by tip];
    \chainin (p12a) [join];
    \chainin (p21b) [join=by tip];
  }
}

\subsection{Parsing values}

In JSON, a value is either a string, a number, an object, an array, a
Boolean (\ct{true} or \ct{false}), or \ct{null}. The \ct{value} parser
is defined as below and represented in~\syntaxjsonref{value}:

\begin{jsonscript}{value}
PPJsonGrammar>>value
  ^ stringToken / numberToken / object / array /
      trueToken / falseToken / nullToken
\end{jsonscript}

\tikzgrammarjsonfig{value}{
  {
    \node (value) [production] {value:}; \&
    \node (p01a)    [point]       {};           \&
    \node (p01b)    [point]       {};           \&
    \node (string) [nonterminal, align=center, style={text height=3.5ex}] {string \\ Token};  \&
    \node (p02a)    [point]       {};           \&
    \node (p02b)    [point]       {};           \\

    \& \&
    \node (p11a)    [point]       {};           \&
    \node (number) [nonterminal]    {number};  \&
    \node (p12a)    [point]       {};           \&    \\

    \& \&
    \node (p21a)    [point]       {};           \&
    \node (object) [nonterminal]    {object};  \&
    \node (p22a)    [point]       {};           \&    \\

    \& \&
    \node (p31a)    [point]       {};           \&
    \node (array) [nonterminal]    {array};  \&
    \node (p32a)    [point]       {};           \&    \\

    \& \&
    \node (p41a)    [point]       {};           \&
    \node (true) [terminal]    {true};  \&
    \node (p42a)    [point]       {};           \&    \\

    \& \&
    \node (p51a)    [point]       {};           \&
    \node (false) [terminal]    {false};  \&
    \node (p52a)    [point]       {};           \&    \\

    \& \&
    \node (p61a)    [point]       {};           \&
    \node (null) [terminal]    {null};  \&
    \node (p62a)    [point]       {};           \&    \\
  };
  { [start chain]
    \chainin (p01a);
    \chainin (string) [join=by tip];
    \chainin (p02b) [join=by tip];

    \chainin (p11a) [join=with p01b];
    \chainin (number) [join=by tip];
    \chainin (p12a) [join];
    \chainin (p02a) [join=by tip];

    \chainin (p21a) [join=with p01b];
    \chainin (object) [join=by tip];
    \chainin (p22a) [join];
    \chainin (p02a) [join];

    \chainin (p31a) [join=with p01b];
    \chainin (array) [join=by tip];
    \chainin (p32a) [join];
    \chainin (p02a) [join];

    \chainin (p41a) [join=with p01b];
    \chainin (true) [join=by tip];
    \chainin (p42a) [join];
    \chainin (p02a) [join];

    \chainin (p51a) [join=with p01b];
    \chainin (false) [join=by tip];
    \chainin (p52a) [join];
    \chainin (p02a) [join];

    \chainin (p61a) [join=with p01b];
    \chainin (null) [join=by tip];
    \chainin (p62a) [join];
    \chainin (p02a) [join];
  }
}

A string requires quite some work to parse. A string starts and end
with double-quotes. What is inside these double-quotes is a sequence
of characters. Any character can either be an escape character, an
octal character, or a normal character. An escape character is
composed of a backslash immediately followed by a special character
(\eg{} \ct{'\n'} to get a new line in the string). An octal character
is composed of a backslash, immediately followed by the letter
\ct{'u'}, immediately followed by 4 hexadecimal digits. Finally, a
normal character is any character except a double quote (used to end
the string) and a backslash (used to introduce an escape character).

\begin{jsonscript}{string}
PPJsonGrammar>>stringToken
  ^ string token trim
PPJsonGrammar>>string
  ^ !\$" asParser , char star , \$" asParser!
PPJsonGrammar>>char
  ^ charEscape / charOctal / charNormal
PPJsonGrammar>>charEscape
  ^ $\ asParser , (PPPredicateObjectParser anyOf: (String withAll: CharacterTable keys))
PPJsonGrammar>>charOctal
  ^ '\u' asParser , (#hex asParser min: 4 max: 4)
PPJsonGrammar>>charNormal
  ^ PPPredicateObjectParser anyExceptAnyOf: '\"'
\end{jsonscript}

% $ <-- to cancel previous one for Emacs highlighting

Special characters allowed after a slash and their meanings are
defined in the \ct{CharacterTable} dictionary that we initialize in
the \ct{initialize} class method.
Please note that \ct{initialize} method on a class side is called when the class is loaded into the system. 
If you just created the \ct{initialize} method class was loaded without the method. 
To execute it, you shoud evaluate \ct{PPJsonGrammar initialize} in your workspace.

\begin{script}{Defining the JSON special characters and their meaning}
PPJsonGrammar class>>initialize
  CharacterTable := Dictionary new.
  CharacterTable
    at: $\ put: $\;
    at: $/ put: $/;
    at: $" put: $";
    at: $b put: Character backspace;
    at: $f put: Character newPage;
    at: $n put: Character lf;
    at: $r put: Character cr;
    at: $t put: Character tab
\end{script}
% $ <-- to cancel previous one for Emacs highlighting

\tikzgrammarjsonfig{string}{
  {
    \node (string) [production] {string:}; \&
    \node (p01a) [point] {}; \&
    \node (openquote) [terminal] {"}; \&
    \node (p02a) [point] {}; \&
    \node (p02b) [point] {}; \&
    \node (char) [nonterminal] {char}; \&
    \node (p03a) [point] {}; \&
    \node (p03b) [point] {}; \&
    \node (closequote) [terminal] {"}; \&
    \node (p04a) [point] {}; \\

    \& \& \& \&
    \node (p11a) [point] {}; \&
    \node (charEscape) [nonterminal] {charEscape}; \&
    \node (p12a) [point] {}; \\

    \node (charp) [production] {char:}; \&
    \node (p21a) [point] {}; \& \& \&
    \node (p21b) [point] {}; \&
    \node (charOctal) [nonterminal] {charOctal}; \&
    \node (p22a) [point] {}; \& \& \&
    \node (p22b) [point] {}; \\

    \& \& \& \&
    \node (p31a) [point] {}; \&
    \node (charNormal) [nonterminal] {charNormal}; \&
    \node (p32a) [point] {}; \\

    \node (charEscapep) [production] {charEscape:}; \&
    \node (p40a) [point] {}; \&
    \node (backslash) [terminal]    {\textbackslash};  \&
    \node (p41a) [point] {}; \& \&
    \node (quote) [terminal] {" \textrm{(quotation mark)}}; \&
    \node (p42a) [point] {}; \& \& \&
    \node (p42b) [point] {}; \\

    \& \& \&
    \node (p50a) [point] {}; \& \&
    \node (innerbackslash) [terminal] {\textbackslash{} \textrm{(backslash)}}; \&
    \node (p51a) [point] {}; \\

    \& \& \&
    \node (p60a) [point] {}; \& \&
    \node (/) [terminal] {/ \textrm{(slash)}}; \&
    \node (p61a) [point] {}; \\

    \& \& \&
    \node (p70a) [point] {}; \& \&
    \node (b) [terminal] {b \textrm{(backspace)}}; \&
    \node (p71a) [point] {}; \\

    \& \& \&
    \node (p80a) [point] {}; \& \&
    \node (f) [terminal] {f \textrm{(formfeed)}}; \&
    \node (p81a) [point] {}; \\

    \& \& \&
    \node (p90a) [point] {}; \& \&
    \node (n) [terminal] {n \textrm{(newline)}}; \&
    \node (p91a) [point] {}; \\

    \& \& \&
    \node (p100a) [point] {}; \& \&
    \node (r) [terminal] {r \textrm{(carr return)}}; \&
    \node (p101a) [point] {}; \\

    \& \& \&
    \node (p110a) [point] {}; \& \&
    \node (t) [terminal] {t \textrm{(tabulation)}}; \&
    \node (p111a) [point] {}; \\

    \node (charOctalp) [production] {charOctal:}; \&
    \node (p120a) [point] {}; \&
    \node (backslashu) [terminal] {\textbackslash{}u}; \& \& \&
    \node (4hexdigits) [nonterminal] {4 hex digits [0--9a--fA--F]}; \& \& \&
    \node (p121a) [point] {}; \\

    \node (charNormalp) [production] {charNormal:}; \&
    \node (p130a) [point] {}; \&
    \& \& \&
    \node (anycharacter) [nonterminal] {Any character except " and \textbackslash}; \& \& \&
    \node (p131a) [point] {}; \\
  };
  { [start chain]
    \chainin (p01a);
    \chainin (openquote) [join=by tip];
    \chainin (char) [join=by tip];
    \chainin (closequote) [join=by tip];
    \chainin (p04a) [join=by tip];

    \chainin (p02b) [join=with p03a by {skip loop=5mm,tip}];
    \chainin (p03b) [join=with p02a by {skip loop=-5mm,tip}];

    \chainin (p21a);
    \chainin (charOctal) [join=by tip];
    \chainin (p22b) [join=by tip];

    \chainin (p21b);
    \chainin (p11a) [join];
    \chainin (charEscape) [join=by tip];
    \chainin (p12a) [join];
    \chainin (p22a) [join=by tip];

    \chainin (p21b);
    \chainin (p31a) [join];
    \chainin (charNormal) [join=by tip];
    \chainin (p32a) [join];
    \chainin (p22a) [join=by tip];

    \chainin (p40a);
    \chainin (backslash) [join=by tip];
    \chainin (quote) [join=by tip];
    \chainin (p42b) [join=by tip];

    \chainin (p41a);
    \chainin (p50a) [join];
    \chainin (innerbackslash) [join=by tip];
    \chainin (p51a) [join];
    \chainin (p42a) [join=by tip];

    \chainin (p50a);
    \chainin (p60a) [join];
    \chainin (/) [join=by tip];
    \chainin (p61a) [join];
    \chainin (p51a) [join];

    \chainin (p60a);
    \chainin (p70a) [join];
    \chainin (b) [join=by tip];
    \chainin (p71a) [join];
    \chainin (p61a) [join];

    \chainin (p70a);
    \chainin (p80a) [join];
    \chainin (f) [join=by tip];
    \chainin (p81a) [join];
    \chainin (p71a) [join];

    \chainin (p80a);
    \chainin (p90a) [join];
    \chainin (n) [join=by tip];
    \chainin (p91a) [join];
    \chainin (p81a) [join];

    \chainin (p90a);
    \chainin (p100a) [join];
    \chainin (r) [join=by tip];
    \chainin (p101a) [join];
    \chainin (p91a) [join];

    \chainin (p100a);
    \chainin (p110a) [join];
    \chainin (t) [join=by tip];
    \chainin (p111a) [join];
    \chainin (p101a) [join];

    \chainin (p120a);
    \chainin (backslashu) [join=by tip];
    \chainin (4hexdigits) [join=by tip];
    \chainin (p121a) [join=by tip];

    \chainin (p130a);
    \chainin (anycharacter) [join=by tip];
    \chainin (p131a) [join=by tip];
  }
}

Parsing numbers is only slightly simpler as a number can be positive
or negative and integral or decimal. Additionally, a decimal number
can be expressed with a floating number syntax.

\begin{jsonscript}{number}
PPJsonGrammar>>numberToken
  ^ number token trim
PPJsonGrammar>>number
  ^ $- asParser optional ,
  ($0 asParser / #digit asParser plus) ,
  ($. asParser , #digit asParser plus) optional ,
  (($e asParser / $E asParser) , ($- asParser / $+ asParser) optional , #digit asParser plus) optional
\end{jsonscript}
% $ <-- to cancel previous one for Emacs highlighting

The attentive reader will have noticed a small difference between the
syntax diagram in \syntaxjsonref{number} and the code in
\scrref{json-number}. Numbers in JSON can not contain leading zeros:
\ie{} strings such as \ct{"01"} do not represent valid numbers. The
syntax diagram makes that particularly explicit by allowing either a 0
or a digit between 1 and 9. In the above code, the rule is made
implicit by relying on the fact that the parser combinator \ct{$/} is
ordered: the parser on the right of \ct{$/} is only tried if the
parser on the left fails: thus, \ct{($0 asParser / #digit asParser plus)}
defines numbers as being just a 0 or a sequence of digits not
starting with 0.

 % $ <-- to compensate

\tikzgrammarjsonfig{number}{
  {
    \node (number) [production] {number:}; \&
    \node (p01a) [point] {}; \&
    \node (p01b) [point] {}; \&
    \node (-) [terminal] {-}; \&
    \node (p01c) [point] {}; \&
    \node (p01d) [point] {}; \&
    \node (0) [terminal] {0}; \&
    \node (p02a) [point] {}; \& \&
    \node (p02b) [point] {}; \&
    \node (.) [terminal] {.}; \&
    \node (p03a) [point] {}; \&
    \node (digit1) [terminal] {digit}; \&
    \node (p04a) [point] {}; \&
    \node (p04b) [point] {}; \&
    \node (p04c) [point] {}; \&
    \node (p04d) [point] {}; \\

    \& \& \& \& \&
    \node (p12b) [point] {}; \&
    \node (digit2) [terminal, align=center, style={text height=3.5ex}] {digit\\1--9}; \&
    \node (p13a) [point] {}; \&
    \node (p13b) [point] {}; \&
    \node (digit3) [terminal] {digit}; \&
    \node (p14a) [point] {}; \\

    \&
    \node (p21a)  [point] {};
    \& \& \& \& \& \& \& \& \& \& \& \& \& \&
    \node (p22a) [point] {}; \&
    \node (p23a) [point] {}; \\

    \&
    \node (p31a)  [point] {}; \&
    \node (p31b) [point] {}; \&
    \node (ee) [terminal] {e / E}; \&
    \node (p32a) [point] {}; \&
    \node (p32b) [point] {}; \&
    \node (+-) [terminal] {+ /  -}; \&
    \node (p33a) [point] {}; \&
    \node (p33b) [point] {}; \&
    \node (digit4) [terminal] {digit}; \&
    \node (p34a) [point] {}; \&
    \node (p34b) [point] {}; \&
    \& \& \&
    \node (p35a) [point] {}; \&
    \&
    \node (p35b) [point] {};\\
  };
  { [start chain]
    \chainin (p01a) [join=by tip];
    \chainin (-) [join=by tip];
    \chainin (0) [join=by tip];
    \chainin (.) [join=by tip];
    \chainin (digit1) [join=by tip];
    \chainin (p04d) [join];
    \chainin (p23a) [join];
    \chainin (p21a) [join];
    \chainin (p31a) [join];
    \chainin (ee) [join=by tip];
    \chainin (+-) [join=by tip];
    \chainin (digit4) [join=by tip];
    \chainin (p35b) [join=by tip];

    \chainin (p04b) [join=with p02b by {skip loop=-2.5ex,tip}];
    \chainin (p03a) [join=with p04a by {skip loop=2.5ex,tip}];
    \chainin (p33a) [join=with p32b by {skip loop=-2.5ex, tip}];
    \chainin (p33b) [join=with p34a by {skip loop=2.5ex, tip}];
    \chainin (p01c) [join=with p01b by {skip loop=-2.5ex, tip}];

    % Float expressions starting with e/E are optional:
    \chainin (p34b) [join=with p31b by {skip loop=-3.5ex, tip}];

    \chainin (p12b) [join=with p01d];
    \chainin (digit2) [join=by tip];
    \chainin (digit3) [join=by tip];
    \chainin (p14a) [join];
    \chainin (p13b) [join=by {skip loop=2.5ex,tip}];
    \chainin (p13a) [join];
    \chainin (p02a) [join=by tip];
  }
}

The other parsers are fairly trivial:

\begin{script}{Defining missing JSON parsers}
PPJsonGrammar>>falseToken
  ^ 'false' asParser token trim
PPJsonGrammar>>nullToken
  ^ 'null' asParser token trim
PPJsonGrammar>>trueToken
  ^ 'true' asParser token trim
\end{script}

The only piece missing is the \ct{start} parser.

\begin{script}{Defining the JSON start parser as being a value (\syntaxjsonref{value}) with nothing following}
PPJsonGrammar>>start
  ^ value end
\end{script}


\section{PetitParser Browser}

PetitParser is shipped with a powerful browser that can help to develop complex parsers.
The PetitParser Browser provides graphical visualization, debugging support, refactoring support, and some other features discussed later in this chapter.
You will see that these features could be very useful while developing your own parser.
Pay attention to have Glamour already loaded in your system. To load Glamour, see~\ref{cha:glamour}. Then to open the PetitParser simply evaluate this expression:
\begin{script}{Opening PetitParser browser}
PPBrowser open.
\end{script}

\subsection{PetitParser Browser overview}

In \figref{pp/browser} you can see the \clsind{PPBrowser} window.
The left panel, named Parsers, contains the list of all parsers in the system.
You can see \clsind{ExpressionGrammar} and its subclasses as well as the \clsind{PPJsonGrammar} that we defined earlier in this chapter.
Selecting one of the parsers in this pane activates the upper-right side of the browser.
For each rule of the selected parser (\eg \ct{prim}) you can see 5 tabs related to the rule.

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{PPBrowser}
    \caption{PetitParser Browser window. \label{fig:pp/browser}}
  \end{center}
\end{figure}

\begin{description}
\item[Source] shows the source code of the rule.
  The code can be updated and saved in this window.
  Moreover, you can add a new rule simply by defining the new method name and body.
\item[Graph]  shows the graphical representation of the rule.
  It is updated as the rule source is changed.
  You can see the \ct{prim} visual representation in \figref{pp/browserGraph}.
  \begin{figure}[ht]
    \begin{center}
      \includegraphics[width=.4\linewidth]{PPBrowserGraph}
      \caption{Graph visualization of the \ct{prim}
        rule. \label{fig:pp/browserGraph}}
    \end{center}
  \end{figure}
\item[Example] shows an automatically generated example based on the
  definition of the rule (see \figref{pp/browserExample1} for an
  example for the \ct{prim} rule). In the top-right corner, the reload
  button generates a new example for the same rule (see
  \figref{pp/browserExample2} for another automatically generated
  example of the \ct{prim} rule, this time with a parenthesized
  expression).
  \begin{figure}[ht]
    \begin{center}
      \includegraphics[width=.4\linewidth]{PPBrowserExample1}
      \caption{An automatically generated example of the \ct{prim}
        rule. In this case, the \ct{prim} example is a
        number. \label{fig:pp/browserExample1}}
    \end{center}
  \end{figure}
  \begin{figure}[ht]
    \begin{center}
      \includegraphics[width=.4\linewidth]{PPBrowserExample2}
      \caption{Another automatically generated example of the
        \ct{prim} rule, after having clicked the reload button. In
        this case, the \ct{prim} example is a parenthesized
        expression. \label{fig:pp/browserExample2}}
    \end{center}
  \end{figure}

\item[First] shows set of terminal parsers that can be activated directly 
    after the rule started.
  As you can see on \figref{pp/browserFirst}, the first set of \ct{prim} is 
    either digit or opening parenthesis \ct{'('}. 
  This means that once you start parsing \ct{prim} the input should continue 
    with either digit or \ct{'('}.
  
  One can use first set to double-check that the grammar is specified correctly.
  For example, if you see \ct{'+'} in the first set of \ct{prim}, there is 
    something wrong with the definitions, because the \ct{prim} rule was never 
    ment to start with binary operator.
  
  Terminal parser is a parser that does not delegate to any other parser.
  Therefore you don't see \ct{parens} in \ct{prim} first set because \ct{parens}
    delegates to another parsers -- trimming and sequence parsers 
    (see \scrref{pp/expressionGrammarPrimAndParens}).
  You can see \ct{'('} which is first set of \ct{parens}.
  The same states for \ct{number} rule which creates action parser delegating to
    trimming parser delegating to flattening parser delegating to repeating parser 
    delegating to \ct{#digit} parser
    (see \scrref{pp/expressionGrammarPrimAndParens}).
  The \ct{#digit} parser is terminal parser and therefore you can see 
    'digit expected' in a first set.
  In general, computation of first set could be complex and therefore
    \ct{PPBrowser} computes this information for us.

  \begin{figure}[ht]
    \begin{center}
      \includegraphics[width=.4\linewidth]{PPBrowserFirst}
      \caption{The first set of the \ct{prim}
        rule. \label{fig:pp/browserFirst}}
    \end{center}
  \end{figure}

  \begin{script}{\ct{prim} rule in \clsind{ExpressionGrammar} \label{scr:pp/expressionGrammarPrimAndParens}}
ExpressionGrammar>>prim
    ^ parens / number

ExpressionGrammar>>parens
    ^ $( asParser trim, term, $} asParser trim

ExpressionGrammar>>number
    ^ #digit asParser plus flatten trim ==> [:str | str asNumber ]
\end{script}


\item[Follow] shows set of terminal parsers that can be activated directly 
    after the rule finished.
  As you can see on \figref{pp/browserFollow}, the follow set of \ct{prim} is 
    closing bracket character parser \ct{')'}, star character parser \ct{'*'}, 
    plus character parser \ct{'+'} or \ct{epsilon} parser (which states for empty string).
  In other words, once you finished parsing \ct{prim} rule the input should
    continue with one of \ct{')'}, \ct{'*'}, \ct{'+'} characters or the input should be completely consumed.
  
  One can use follow set to double-check that the grammar is specified correctly.
  For example if you see \ct{'('} in \ct{prim} follow set, something is wrong
    in the definition of your grammar. 
  The \ct{prim} rule should be followed by binary operator or closing bracket, not 
    by opening bracket.
  
  \begin{figure}[ht]
    \begin{center}
      \includegraphics[width=.4\linewidth]{PPBrowserFollow}
      \caption{The follow set of the \ct{prim}
        rule. \label{fig:pp/browserFollow}}
    \end{center}
  \end{figure}
  
  In general, computation of follow could be even more complex than computation
    of first and therefore \ct{PPBrowser} computes this information for us.  

\end{description}

\noindent The lower-right side of the browser is related to a particular parsing input.
You can specify an input sample by filling in the text area in the Sample tab.
One may  parse the input sample by clicking the \ct{play} \textsf{\small{$\blacktriangleright$}} button or by pressing Cmd-s or Ctrl-s.
You can then gain some insight on the parse result by inspecting the
tabs on the bottom-right pane:

\begin{description}

\item[Result] shows the result of parsing the input sample  that can be inspected by
  clicking either the \ct{Inspect} or \ct{Explore} buttons. Figure
  \figref{pp/browserResult} shows the result of parsing \ct{(1+2)}.

  \begin{figure}[ht]
    \begin{center}
      \includegraphics[width=.7\linewidth]{PPBrowserResult}
      \caption{Result of parsing the \ct{(1+2)} sample expression \label{fig:pp/browserResult}}
    \end{center}
  \end{figure}

\item[Debugger] shows a tree view of the steps that were performed
  during parsing. This is very useful if you don't know what exactly
  is happening during parsing. By selecting the step the subset of
  input is highlighted, so you can see which part of input was parsed
  by a particular step. 

  For example, you can inspect how the \clsind{ExpressionGrammar} works, 
    what rules are called and in which order.
  This is depicted in \figref{pp/debugger}. 
  The grey rules are rules that failed. 
  This usually happens for choice parsers and you can see an example for the \ct{prod} rule 
    (the definition is in \scrref{pp/expressionGrammarProd}). 
  When parser was parsing $12 + 3 * 4$ term, the parser tried to parse \ct{mul} rule 
    as a first option in \ct{prod}.
  But \ct{mul} required star character \ct{'*'} at position 2 which is not present, so that the 
    \ct{mul} failed and instead the \ct{prim} with value $12$ was parsed.

  \begin{script}{\ct{prod} rule in \clsind{ExpressionGrammar} \label{scr:pp/expressionGrammarProd}}
ExpressionGrammar>>prod
	^ mul / prim
ExpressionGrammar>>mul
	^ prim, $* asParser trim, prod 
\end{script}

% $ <-- please don't remove, that is used to close the \$ in the
% previous script (bug in Emacs)

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=.8\linewidth]{PPBrowserDebugger3}
    \caption{Debugger output of \clsind{ExpressionGrammar} for input $12+3*4$. \label{fig:pp/debugger}}
  \end{center}
\end{figure}

  Compare what happens during parsing when we change from $12 + 3 * 4$ to $12 * 3 * 4$.
  What rules are applied know, which of them fails?
  The second debugger output is in \figref{pp/debugger2}, but give it your own try.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=.8\linewidth]{PPBrowserDebugger4}
    \caption{Debugger output of \clsind{ExpressionGrammar} for input $12*3*4$. \label{fig:pp/debugger2}}
  \end{center}
\end{figure}

\item[Tally] shows how many times a particular parser got called
  during the parsing. The percentage shows the number of calls to total number
  of calls ratio. This might be useful while optimizing performance of
  your parser (see \figref{pp/tally}).
    
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=.8\linewidth]{tally}
    \caption{Tally of \clsind{ExpressionGrammar} for input $12*3*4$. \label{fig:pp/tally}}
  \end{center}
\end{figure}
    
\item[Profile] shows how much time was spent in particular parser
  during parsing of the input. The percentage shows the ratio of time
  to total time. This might be useful while optimizing performance of
  your parser (see \figref{pp/profile}).
    
\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=.8\linewidth]{profile}
    \caption{Profile of \clsind{ExpressionGrammar} for input $12*3*4$. \label{fig:pp/profile}}
  \end{center}
\end{figure}
    
\item[Progress] visually shows how a parser consumes input. The x-axis
  represents how many characters were read in the input sample,
  ranging from 0 (left margin) to the number of characters in the
  input (right margin). The y-axis represents time, ranging from the
  beginning of the parsing process (top margin) to its end (bottom
  margin). A line going from top-left to bottom-right (such as the one
  in \figref{pp/progressLinear}) shows that the parser completed its
  task by only reading each character of the input sample once. This
  is the best case scenario, parsing is linear in the length of the
  input: In another words, input of $n$ characters is parsed in $n$
  steps. 

  When multiple lines are visible, it means that the parser had
  to go back to a previously read character in the input sample to try
  a different rule. This can be seen in
  \figref{pp/progressBacktracking}. In this example, the parser had to
  go back several times to correctly parse the whole input sample: all
  input was parsed in $n!$ steps which is very bad. %\dc{it would be
%    nice to have an example here so that the reader can reproduce your
%    experiment}
%  \jk{I added example further}
  % but in the end the backtracking returns position
  % of the input almost to the beginning and we have to start again.
  % So that we parsed input of $n$ characters but there was a failure
  % in
  % step $n$ and therefore we returned to position $1$ and again
  % performed $n-1$ steps and in the end returned to the position $2$.
  If you see many backward jumps for a grammar, you should
  reconsider the order of choice parsers, restructure your grammar
  or use a memoized parser.
  We will have a detailed look on a backtracking issue in the
  following section.

  \begin{figure}[ht]
    \begin{center}
      \includegraphics[scale=0.5]{PPBrowserProgressLinear}
      \caption{Progress of Petit Parser that parses input in linear amount of steps. \label{fig:pp/progressLinear}}
    \end{center}
  \end{figure}

  \begin{figure}[ht]
    \begin{center}
      \includegraphics[scale=0.5]{PPBrowserProgressBacktracking}
      \caption{Progress of Petit Parser with a lot of backtracking. \label{fig:pp/progressBacktracking}}
    \end{center}
  \end{figure}
\end{description}


\subsection{Debugging example}
  As an exercise, we will try to improve a \clsind{BacktrackingParser} from \scrref{pp/backtrackingParser}. 
  The \ct{BacktrackingParser} was designed to accept input corresponding to the
  regular expressions \ct{'a*b'} and \ct{'a*c'}.
  The parser gives us correct results, but there is a problem with performance.
  The \ct{BacktrackingParser} does too much backtracking.
  %So let us try to parse \ct{'aaaaaaaaaaaaaab'}.

  %Try \ct{'aaaaaaaaaaaaac'} and \ct{'aaaaaaaaaaaaaab'} as input and observe what happens.
  %Do not forget to use debugger to understand what is going on. 



\begin{script}{A parser accepting \ct{'a*b'} and \ct{'a*c'} with too much backtracking. \label{scr:pp/backtrackingParser}}
PPCompositeParser subclass: #BacktrackingParser
	instanceVariableNames: 'ab ap c p'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PetitTutorial'

BacktrackingParser>>ab
  ^  'b' asParser / 
     ('a' asParser, ab)

BacktrackingParser>>c
  ^ 'c' asParser

BacktrackingParser>>p
  ^ ab / ap / c

BacktrackingParser>>start
  ^ p


BacktrackingParser>>ap
  ^ 'a' asParser, p
\end{script}

Let us get some overview to better understand, what is happening.
First of all, try to parse $input_b$ = \ct{'aaaaaaaaab'} and $input_c$ = \ct{'aaaaaaaaac'}.
As we can see from progress depicted in \figref{pp/example-progressAaab}, the $input_b$ is parsed in more or less linear time and there is no backtracking.
But the progress depicted in \figref{pp/example-progressAaac} looks bad.
The $input_c$  is parsed with a lot of backtracking and in much more time.
We can even compare the tally output for both inputs $input_b$ and $input_c$ (see \figref{pp/example-tallyAaab} and \figref{pp/example-tallyAaac}).
In case of $input_b$, the total invocation count of the parser \ct{b} is 19 and invocation count of the parser \ct{a} is 9.
It is much less than 110 invocations for the parser \ct{b} and 55 invocations for the parser \ct{a} in case of $input_c$.

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-progressAaab}
    \caption{Progress of the \ct{BacktrackingParser} for $input_b$. \label{fig:pp/example-progressAaab}}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-progressAaac}
    \caption{Progress of the \ct{BacktrackingParser} for $input_c$. \label{fig:pp/example-progressAaac}}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-tallyAaab}
    \caption{Tally output of the \ct{BacktrackingParser} for $input_b$. \label{fig:pp/example-tallyAaab}}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-tallyAaac}
    \caption{Tally output of the \ct{BacktrackingParser} for $input_c$. \label{fig:pp/example-tallyAaac}}
  \end{center}
\end{figure}

We can see there is some problem with $input_c$.
If we still don't know what is the problem, the debugger window might give us more hints.
Let us have a look at the debugger window for $input_b$ as depicted in \figref{pp/example-debugAaab}.
We can see that in each step, one \ct{'a'} is consumed and the parser \ct{ab} is invoked until it reaches the \ct{'b'}.
The debugger window for $input_c$ as depicted in \figref{pp/example-debugAaac} looks much different.
There is a progress within the \ct{p} -> \ct{ab} -> \ct{ap} -> \ct{p} loop but the parser \ct{ab} fails in each repetition of the loop.
Since the parser \ct{ab} fails after having read all the string to the end and seen \ct{'c'} instead of \ct{'b'}, we have localized the cause of the backtracking.
We know the problem now, so what can we do?
We may try to update \ct{BacktrackingParser} so that the \ct{'a*c'} strings are parsed in a similar way as the \ct{'a*b'} strings.
You can see such a modification in \scrref{pp/backtrackingParser-update-1}.


\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-debugAaab}
    \caption{Debugging output of \ct{BacktrackingParser} for $input_b$. \label{fig:pp/example-debugAaab}}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-debugAaac}
    \caption{Debugging output of \ct{BacktrackingParser} for $input_c$. \label{fig:pp/example-debugAaac}}
  \end{center}
\end{figure}


\begin{script}{A slightly better parser accepting \ct{'a*b'} and \ct{'a*c'}. \label{scr:pp/backtrackingParser-update-1}}
PPCompositeParser subclass: #BacktrackingParser
	instanceVariableNames: 'ab ac'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PetitTutorial'

BacktrackingParser>>ab
  ^  'b' asParser / 
     ('a' asParser, ab)

BacktrackingParser>>ac
  ^  'c' asParser / 
     ('a' asParser, ac)

BacktrackingParser>>start
  ^ ab / ac
\end{script}

We can check the new metrics for $input_c$ in both \figref{pp/example-progressAaac-update-1} and \figref{pp/example-tallyAaac-update-1}. There is significant improvement.
For $input_c$, the tally shows only 20 invocations of the parser \ct{b} and 9 invocations of the parser \ct{a}.
This is very good improvement compared to the 110 invocations of the parser \ct{b} and 55 invocations of the parser \ct{a} in the original version of \ct{BacktrackingParser} (see \figref{pp/example-tallyAaac}).

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-progressAaac-update-1}
    \caption{Progress of \ct{BacktrackingParser} for $input_c$ after the first update. \label{fig:pp/example-progressAaac-update-1}}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-tallyAaac-update-1}
    \caption{Tally of \ct{BacktrackingParser} for $input_c$ after the first update. \label{fig:pp/example-tallyAaac-update-1}}
  \end{center}
\end{figure}

Yet, we might try to do even better.
There is still one backtracking happening for $input_c$.
It happens when the parser \ct{ab} tries to recognize the \ct{'a*b'} input and fails (and backtracks) so that the parser \ct{ac} can recognize the \ct{'a*c'} input.
What if we try to consume all the \ct{'a'}s and then we choose between \ct{'b'} and \ct{'c'} at the very end?
You can see such a modification of the \ct{BacktrackingParser} in \scrref{pp/backtrackingParser-update-2}.
In that case, we can see the progress without any backtracking even for $input_c$ as depicted in \figref{pp/example-progressAaac-update-2}.

On the other hand, the number of parser invocations for $input_b$ increased by 18 (the \tabref{example-tally} summarizes the total number of invocations for each version of the \ct{BacktrackingParser}).
It is up to the developer to decide which grammar is more suitable for his needs.
It is better to use the second improved version in case \ct{'a*b'} and \ct{'a*c'} occur with the same probability in the input.
If we expect more \ct{'a*b'} strings in the input, the first version is better.

\begin{script}{An even better parser accepting \ct{'a*b'} and \ct{'a*c'}. \label{scr:pp/backtrackingParser-update-2}}
PPCompositeParser subclass: #BacktrackingParser
	instanceVariableNames: 'abc'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PetitTutorial'

BacktrackingParser>>abc
  ^  ('b' asParser / 'c' asParser) /
     ('a' asParser, abc)

BacktrackingParser>>start
  ^ abc
\end{script}


\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-progressAaac-update-2}
    \caption{Progress of the \ct{BacktrackingParser} after the second update for $input_c$. \label{fig:pp/example-progressAaac-update-2}}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-tallyAaac-update-2}
    \caption{Tally of the \ct{BacktrackingParser} after the second update for $input_c$. \label{fig:pp/example-tallyAaac-update-2}}
  \end{center}
\end{figure}

\begin{table}
  \centering
  \begin{tabular}{lcc}
    \toprule
                       & \multicolumn{2}{c}{\textbf{\# of invocations}} \\
    \textbf{Version}   & ${input_b}$                                    & ${input_c}$ \\
    \midrule
    Original           & 28                                             & 233         \\
    First improvement  & 28                                             & 70          \\
    Second improvement & 46                                             & 48          \\
    \bottomrule
  \end{tabular}
  \caption{Number of parser invocations for $input_b$ and $input_c$ depending on the version of \ct{BacktrackingParser}.}
  \label{tab:example-tally}
\end{table}


\section{Packrat Parsers}

In the beginning of the chapter, we have mentioned four parser methodologies, one of them was \emph{Packrat Parsers}.
We claimed that packrat parsing gives linear parse times.
But in the debugging example we saw that original version of the \ct{BacktrackingParser} parsed $input_c$ of length 10 in 233 steps.
And if you try to parse $longinput_c$ = \ct{'aaaaaaaaaaaaaaaaaaaac'} (length 20), you will see that the original parser needs 969 steps.
Indeed, the progress is not linear.

The PetitParser framework does not use packrat parsing by default.
You need to send the \ct{memoized} message to enable packrat parsing.
The memoized parser ensures that the parsing for the particular position in an input and the particular parser will be performed only once and the result will be remembered in a dictionary for a future use.
The second time the parser wants to parse the input, the result will be looked up in the dictionary.
This way, a lot of unnecessary parsing can be avoided.
The disadvantage is that PetitParser needs much more memory to remember all the results of all the possible parsers at all the possible positions.

To give you an example with a packrat parser, let us return back to the \ct{BacktrackingParser} once again (see \scrref{pp/backtrackingParser}).
As we have analyzed before, the problem was in the parser \ct{ab} that constantly failed in the \ct{p} -> \ct{ab} -> \ct{ap} -> \ct{p} loop.
Now we can do the trick and memoize the parser \ct{ab} by updating the method \ct{ab} as in \scrref{pp/backtrackingParser-memo}.
When the memoization is applied, we get the progress as in \figref{pp/example-progressAaac-memo} with the total number of 63 invocations for $input_c$ and the 129 invocations for $longinput_c$.
With the minor modification of \ct{BacktrackingParser} we got a linear parsing time (related to the length of the input)  with a factor around 6.

\begin{script}{Memoized version of the parser \ct{ab}. \label{scr:pp/backtrackingParser-memo}}
BacktrackingParser>>ab
  ^ ( 'b' asParser / 
	   ('a' asParser, ab)
     ) memoized
\end{script}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{example-progressAaac-memo}
    \caption{Progress of the memoized version of the \ct{BacktrackingParser}. \label{fig:pp/example-progressAaac-memo}}
  \end{center}
\end{figure}

\section{Chapter summary}

This concludes our tutorial of PetitParser. We have reviewed the following points:


\begin{itemize}
\item A parser is a composition of multiple smaller parsers combined with combinators.
\item To parse a string, use the method \ct{parse:}.
\item To know if a string matches a grammar, use the method \ct{matches:}.
\item The method \ct{flatten} returns a String from the result of the parsing.
\item The method \ct{==>} performs the transformation given in the block given in parameter.
\item Compose parsers (and create a grammar) by subclassing \ct{PPCompositeParser}.
\item Test your parser by subclassing \ct{PPCompositeParserTest}.
\end{itemize}


For a more extensive view of PetitParser, its concepts and
implementation, the Moose book\footnote{\url{http://www.themoosebook.org/book/internals/petit-parser}} and Lukas Renggli's
PhD\footnote{\url{http://scg.unibe.ch/archive/phd/renggli-phd.pdf}} have both a dedicated chapter.

%=============================================================
\ifx\wholebook\relax\else

% To avoid warning message about undefined labels (that should be
% defined by other chapters)
\label{cha:glamour}

\bibliographystyle{jurabib}
\nobibliography{scg}

\end{document}

\fi
%=============================================================




%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:

% LocalWords:  subclassing PetitParser JSON Wikipedia hexa combinator
