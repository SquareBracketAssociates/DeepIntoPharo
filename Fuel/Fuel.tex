% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% HISTORY:
% 2011-09-08: addressed mariano + nicolas paez comments
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
% could change returns by answers 
% 2011-09-28 - Alexandre doing a pass


%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================

\chapter{Fuel: a Fast Object Serializer}


%=========================================================
\section{What is it?}

An open-source\footnote{Developed under the MIT license} general-purpose object serialization framework.

\martin{write something about what means serialisation}


\begin{description}

\item[Concrete]
We don't aspire to have a dialect-interchange format. This enables us to serialize special objects like contexts, block closures, exceptions, compiled methods and classes. Although there are ports to other dialects, Fuel development is Pharo-centric.

\item[Flexible]
Depending on the context, there could be multiple ways of serializing the same object. For example, a class can be considered either a global or a regular object. In the former case, it will be encoded just its name; in the latter case, the class will be encoded in detail, with its method dictionary, etc.

\item[Fast]
We worry about to have the best performance. We developed a complete benchmark suite to help analyse the performance with diverse sample sets, as well as compare against other serializers. Our pickling algorithm allows outstanding materialization performance, as well as very good serialization performance too.

\item[Object-Oriented Design]
From the beginning it was a constraint to have a good object-oriented design and to do not need any special support from the VM. In addition, Fuel has a complete test suite, with a high coverage. We also worry about writing comments on classes and methods.

\end{description}


\subsection{Features} 

\begin{itemize}

\item Is a fast, well-designed, concrete, general-purpose and flexible binary serializer.
\item Can serialize/materialize not only plain objects but also classes, traits, methods, closures, contexts, packages, etc.
\item Support for global references.
\item Large number of hooks: ignore certain instance variables, substitute objects by others, post and pre serialization and materialization actions.
\item Supports class rename and class reshape.
\item 90\% (approx. 500 unit tests) of test coverage.
\item Large suite of benchmarks.
\item Object-Oriented design.
\item No VM support needed.
\item Modular (clear division of packages).

\end{itemize}


\martin{put some subtitle}

\begin{code}{A first example}
| sourceArray loadedArray |
sourceArray := Array with: 'a string' with: Transcript.
"Store to a file"
FLSerializer serialize: sourceArray toFileNamed: 'example.FL'.
"Load from the file"
loadedArray := FLMaterializer materializeFromFileNamed: 'example.FL'.
"Check that the materialized Transcript is the right singleton instance."
loadedArray second show: loadedArray first; flush.
\end{code}



%=========================================================
\section{Basic Examples}


\sd{show how do we save the stack in Pharo 2.0 and reload it in another image}


%=========================================================
\section{Managing Globals}

Let us assume a class is referenced from the graph to serialize. Sometimes we may be interested in storing just the name of the class because we know it will be present when materializing the graph. However, sometimes we want to really store the class with full detail, including its method dictionary, methods, class variables, etc. When serializing a package, we are interested in a mixture of both: for external classes, just the name but, for the internal ones, full detail.

This means that given an object graph, there is not an unique way of serializing it. Fuel offers dynamic and static mechanisms to customize this


\subsection{Default globals}

By default, Fuel considers following objects as globals, i.e. will store just its name:

\begin{itemize}

\item \ct{nil}, \ct{true}, \ct{false}, and the \emph{System Dictionary}.

\item All Classes and Traits.

\item All Metaclasses and ClassTraits.

\item All CompiledMethods.

\item Some well-known global variables (\ct{Smalltalk SourceFiles Transcript Undeclared Display TextConstants ActiveWorld ActiveHand ActiveEvent Sensor Processor ImageImports SystemOrganization World}).

\end{itemize}


\subsection{Adding custom globals}

User can customize this using \ct{considerGlobal:} to add more globals. A demo:

\begin{code}{Demo: adding custom globals}
| aSerializer anArray materializedArray |
"Prepare an array whose two elements are system globals."
anArray := Array with: Set new with: Set new.
Smalltalk at: #GlobalSet1 put: anArray first.
Smalltalk at: #GlobalSet2 put: anArray second.
"Serialize considering *only first* as a global object."
FileStream forceNewFileNamed: 'demo.fuel' do: [:aStream |
	aSerializer := FLSerializer newDefault.
	aSerializer analyzer considerGlobal: #GlobalSet1.
	aSerializer serialize: anArray on: aStream binary].

"Materialize"
FileStream oldFileNamed: 'demo.fuel' do: [:aStream |
	materializedArray := (FLMaterializer newDefault 
		materializeFrom: aStream binary) root].
	
"Check that second element is a new Set."
[ (Smalltalk at: #GlobalSet1) == materializedArray first ] assert.
[ (Smalltalk at: #GlobalSet2) ~~ materializedArray second ] assert.
\end{code}


\subsection{Light vs. Full Serialization}

In Fuel, we split the possible use scenarios on these two:

\begin{description}

\item[Light]
For users who need to store plain objects, and if the graph points to a \ct{CompiledMethod} or a \ct{Class}, for example, always the intention will be to store them as globals (so, not in detail). Most users should fall in this scenario.

\item[Full]
When more complete and sophisticated serialization is needed, and you can specify to store certain behaviours and methods with full detail. This is used by experimental projects like package loaders, an object swapper, or remote execution. For more information, you can install \ct{DevelopmentGroup} configuration and look at \ct{FuelMetalevelTests} packages for examples. Don't hesitate to ask us.

\end{description}


%=========================================================
\section{Customizing the Graph}


\subsection{Ignoring Instance Variables}

By this hook you can specify a list of instance variables that won't be serialized. The way to do it is to implement in a particular class the method \ct{fuelIgnoredInstanceVariableNames}. Let's say we have the class \ct{User} and we do not want to serialize the instance variables \ct{'acumulatedLogins'} and \ct{'applications'}. So we implement:

\begin{code}
User class >> fuelIgnoredInstanceVariableNames
    ^#('acumulatedLogins' 'applications')
\end{code}

When materialized, such instance variables will be nil. If you want to re-initialize and set values to those instance variables, you can use \ct{fuelAfterMaterialization} for that.

Be aware that in case of renaming those instance variables, you should rename that method as well. Notice also that the method \ct{fuelIgnoredInstanceVariableNames} is implemented at class side. This means that ""all"" instances of such class will ignore the defined instances variables. 

In \ct{StOMP} serializer this same hook is called \ct{stompTransientInstVarNames} and in \ct{SIXX} it is \ct{sixxIgnorableInstVarNames}. 

We test this feature in \ct{FLIgnoredVariablesTest}.


\subsection{Post-Materialization Action}

The method \ct{fuelAfterMaterialization} let us execute something once an object has been materialized. For example, let's say we would like to set back the instance variable \ct{'acumulatedLogins'} during materialization. Hence, we can implement:

\begin{code}
User >> fuelAfterMaterialization
 acumulatedLogins := 0. 
\end{code}


\subsection{Substitutes on Serialization}

Sometimes you may want to serialize something different than the original object, without altering them.


\subsubsection{Dynamic way}

You can establish a pluggable substitution to a particular serializer instance. 

Let's illustrate with an example, where your graph includes a \ct{Stream} and you want to serialize \ct{nil} instead. 

\begin{code}
objectToSerialize := Array with: 'hello' with: '' writeStream.

FileStream forceNewFileNamed: 'demo.fuel' do: [ :aStream |
    aSerializer := FLSerializer newDefault.
    aSerializer analyzer 
        when: [ :o | o isStream ] 
        substituteBy: [ :o | nil ].
    aSerializer         
        serialize: objectToSerialize
        on: aStream binary ].
\end{code}

So, when loading you will get \ct{#('hello' nil)}, without any instance of a stream.

You can find this code in \ct{FLUserGuidesTest>>testPluggableSubstitution}.


\subsubsection{Static way}

You have to override \ct{fuelAccept:} in the class of the object to be substituted. Fuel visits each object in the graph by sending this message, to determine how to trace and serialize it.

As an example, imagine we want to replace an object directly with nil. In other words, we want to make a whole object transient, say \ct{CachedResult}. For that, we should implement:

\begin{code}
CachedResult >> fuelAccept: aGeneralMapper
    ^ aGeneralMapper visitSubstitution: self by: nil
\end{code}

As another example, we have a \ct{Proxy} class and when serializing we want to serialize its \ct{target} instead of the proxy. So we implement:

\begin{code}
Proxy >> fuelAccept: aGeneralMapper
    ^ aGeneralMapper visitSubstitution: self by: target
\end{code}

Notice that \ct{fuelAccept:} is the same as the previous example. The last example is when an object needs to change the value of its instance variables. Say we have again the class \ct{User} and we want to \ct{nil} the instance variable \ct{'history'} when its size is greater than 100. 

\begin{code}
User >> fuelAccept: aGeneralMapper
    ^self history size > 100 
        ifTrue: [ 
            aGeneralMapper 
                visitSubstitution: self 
                by: (self copy history: Array new) ].
        ifFalse: [ super fuelAccept: aGeneralMapper ]
\end{code}

Note: we are substituting the original user by another instance of \ct{User}, which Fuel will visit with the same \ct{fuelAccept:} method. We could easily fall in an infinite sequence of substitutions if we don't take care. To avoid this problem, it is useful \ct{visitSubstitution:by:onRecursionDo:}, where you define an alternative mapping for the case of mapping an object which is already a substitute of another one:

\begin{code}
User >> fuelAccept: aGeneralMapper
    aGeneralMapper 
        visitSubstitution: self 
        by: (self copy history: #())
        onRecursionDo: [ super fuelAccept: aGeneralMapper ]
\end{code}

In the case, the substitute user (i.e. the one with the empty history) is will be visited via its super implementation.

You can see tests for this functionality at \ct{FLHookedSubstitutionTest}.


\subsection{Substitutes on Materialization}


\subsubsection{Global Sends}

Suppose we have a special instance of \ct{User} that represents the admin user, and it is an unique instance in the image. In case the admin user is referenced in our graph, we want to treat that object as a global. We can do that in this way:

\begin{code}
User >> fuelAccept: aGeneralMapper
    ^self == User admin
        ifTrue: [ 
            aGeneralMapper 
                visitGlobalSend: self 
                name: #User 
                selector: #admin ]
        ifFalse: [ super fuelAccept: aGeneralMapper ]
\end{code}

So what will happen is that during serialization, the admin user won't be completly serialized (with all its intance variables) but instead its global name and selector are stored. Then, at materialization time, Fuel will send \ct{admin} to the class \ct{User}, and use what that answers as the admin user of the materialized graph. 

We test this feature in \ct{FLGlobalSendSerializationTest}.


\subsection{Not Serializable Objects}

You may want to be sure that some objects are not serialized. For this case we provide \ct{visitNotSerializable:}, which in next example forbids serialization of any instance of \ct{MyNotSerializableObject}.

\begin{code}
MyNotSerializableObject >> fuelAccept: aGeneralMapper
    aGeneralMapper visitNotSerializable: self
\end{code}

We test this feature in \ct{FLBasicSerializationTest>>testNotSerializableObject}.


%=========================================================
\section{Errors}

\sd{sounds a bit dry. What do we do!}


%=========================================================
\section{Class Migration}

Often, we need to load objects whose class has changed since it was saved. In this document how to load them in the different cases. The examples in \figref{ClassChanges} illustrate some of them. Imagine we serialized an instance of \ct{Point} and we need to materialize it when \ct{Point} class has changed.

\begin{figure}[t]\centering
        \includegraphics[width=\linewidth]{ClassChanges.png}
        \caption{Some usual changes during class evolution which require migration.\figlabel{ClassChanges}}
\end{figure}

Let's start with the easier cases. If a variable was \emph{inserted}, its value will be \ct{nil}. If \emph{removed}, it is also obvious: the serialized value will be ignored. In the case the variables are the same the the \emph{order changed}, Fuel also tolerates it automatically.

A more interesting case is when a variable was \emph{renamed}, where the user can map old names to new ones. In our example:

\begin{code}
FLMaterializer newDefault
	migrateClassNamed: #Point
	variables: {'x' -> 'posX'. 'y' -> 'posY'}.
\end{code}

Not surprisingly, if nothing specified the change will be understood by Fuel as two independent operations, an insertion and a removal.

The last change in the figure is a \emph{class rename}. This should be specified this way:

\begin{code}
FLMaterializer newDefault
	migrateClassNamed: #Point
	toClass: Coordinate.
\end{code}

It is also available \ct{migrateClassNamed:toClass:variables:} to combine both \emph{class and variable rename}.

Although not illustrated in the figure, a class could also change its \emph{layout}. For example, Point could change from being \emph{fixed} to \emph{variable}. This should be also automatically tolerated by Fuel. Unfortunately, the inverse (variable to fixed) is not supported so far.

You can find tests related to this guide in \ct{FLMigrationTest}.


%=========================================================
\section{Fuel Format Change and Migration}

\sd{you have a file in format version 1 and you want to migrate to version 2 of the internal encodings.}


%=========================================================
\section{Core Design and Package Structure}


%=========================================================
\section{Customization Hooks}


%=========================================================
\section{Debugging}




%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
