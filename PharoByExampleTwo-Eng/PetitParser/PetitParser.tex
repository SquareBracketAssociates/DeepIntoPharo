% $Author$
% $Date$
% $Revision$

% HISTORY:
% Chapter started by Damien C (2011-07-11)
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
% could change returns by answers 


%=================================================================
\ifx%
\wholebook%
\relax%
\input{PetitParser/visual-grammar}%
\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
    \input{visual-grammar}
    \begin{document}
\fi
%=================================================================
%\renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{PetitParser}
\chalabel{petitparser}

\chapterauthor{\authorlukas{}}

\newcommand{\ppmthind}[1]{\clsmthind{PPParser}{#1}}

Building parsers to analyse data is a common tasks in software
development. In this chapter we present a powerful parser frameworks
named PetitParser. And contrary to its name, PetitParser is a really
powerful parsing framework combining several technologies (scannerless
parsers, parser combinators..). PetitParser is written by Lukas
Renggli as part of his work on the Helvetia system but it can be used
as a standalone tool.

Building parsers to analyse data is a common tasks in software
development. In this chapter we present a powerful parser frameworks
named PetitParser. And contrary to its name, PetitParser is a really
powerful parsing framework combining several technologies (scannerless
parsers, parser combinators..). PetitParser is written by Lukas
Renggli as part of his work on the Helvetia system but it can be used
as a standalone tool.

\section{Writing Parsers with PetitParser}

 PetitParser is a parsing framework different
to many other popular parser generators. For example, it is not table
based such as SmaCC or ANTLR. Instead it uses a unique combination of
four alternative parser methodologies: scannerless parsers, parser
combinators, parsing expression grammars and packrat parsers. As such
PetitParser is more powerful in what it can parse and it arguably fits
better the dynamic nature of Smalltalk. Let's have a quick look at
these four parser methodologies:

\begin{description}
\item[Scannerless Parsers] combine what is usually done by two
  independent tools (scanner and parser) into one. This makes writing
  a grammar much simpler and avoids common problems when grammars are
  composed.

\item[Parser Combinators] are building blocks for parsers modeled as a
  graph of composable objects; they are modular and maintainable, and
  can be changed, recomposed, transformed and reflected upon.

\item[Parsing Expression Grammars] (PEGs) provide ordered choice. Unlike in
  parser combinators, the ordered choice of PEGs always follows the
  first matching alternative and ignores other alternatives. Valid
  input always results in exactly one parse-tree, the result of a
  parse is never ambiguous.

\item[Packrat Parsers] give linear parse time guarantees and avoid
  common problems with left-recursion in PEGs.
\end{description}


\subsection{Loading PetitParser}

Enough theory, let's get started. PetitParser is developed in Pharo,
but is also available on other Smalltalk platforms. A ready made image
can be
downloaded.\footnote{\url{http://hudson.lukas-renggli.ch/job/PetitParser/lastSuccessfulBuild/artifact/petitparser}}
To load PetitParser into an existing image evaluate the following
Gofer expression:

\begin{script}{Installing PetitParser}
Gofer new
  renggli: 'petit';
  package: 'PetitParser';
  package: 'PetitTests';
  load.
\end{script}

There are other packages in the same repository that provide
additional features, for example PetitSmalltalk is a Smalltalk
grammar, PetitXml is an XML grammar, PetitJson is a JSON grammar,
PetitAnalyzer provides functionality to analyze and transform
grammars, and PetitGui is a Glamour IDE (see \charef{glamour}) for
writing complex grammars. We are not going to use any of these
packages for now.

More information on how to get PetitParser can be found on the website
of the
project.\footnote{\url{http://scg.unibe.ch/research/helvetia/petitparser}}

\subsection{Writing a Simple Grammar}

Writing grammars with PetitParser is as simple as writing Smalltalk
code. For example a grammar parsing identifiers that start with a
letter followed by zero or more letters or digits is defined as
follows:

\begin{script}[identifier]{Creating our first parser to parse identifiers}
identifier := #letter asParser , #word asParser star.  
\end{script}

\tikzgrammarfig{identifier}{
  {
    \node (identifier) [production] {identifier:}; \&
    \node (p1)     [point]       {};           \& 
    \node (letter) [terminal]    {letter};     \&
    \node (p3a)    [point]       {};           \& 
    \node (p3b)    [point]       {};           \& 
    \node (word)   [terminal] {word};       \&
    \node (p11a)    [point]       {};           \& 
    \node (p11b)   [point]       {};           \& 
    \node (p11c)    [point]       {};           \\
  };
  { [start chain]
    \chainin (p1);
    \chainin (letter) [join=by tip];
    \chainin (word)  [join=by tip];
    \chainin (p11c)     [join=by tip];
    \chainin (p11b)   [join,join=with p3a by {skip loop=-5mm,tip}];
    \chainin (p3b)    [join=with p11a by {skip loop=5mm,tip}];
  }
}

\syntaxref{identifier} presents a graphical representation, called a
syntax diagram, of the identifier parser. Such a syntax diagram
contains squared boxes that represent non terminals (parsers composed
of other parsers), round boxes that represent terminals (all other
kinds of parsers), arrows between these boxes, some entry points and
some exit points. The idea behind this representation is that if an
input can go from the entry point to the exit point by following the
arrows and being consumed by the boxes, this input is matched by the
represented parser.

If you inspect the object identifier you'll notice that it is an
instance of a \clsind{PPSequenceParser}. If you dive further into the
object you notice the following simple tree of different parser
objects:

\begin{script}{Composition of parsers used for the identifier parser}
PPSequenceParser (accepts a sequence of parsers)
    PPPredicateObjectParser (accepts a single letter)
    PPPossessiveRepeatingParser (accepts zero or more instances of another parser)
       PPPredicateObjectParser (accepts a single word character)  
\end{script}

The root parser is a sequence parser because the \#, operator (comma)
created a sequence of a letter and zero or more word character
parser. The first child of the root parser is a predicate object
parser created by the \ct{#letter asParser} expression. This parser is
capable of parsing a single letter as defined by the
\clsmthind{Character}{isLetter} method. %
The second child of the root parser is a repeating parser created by
the \ct{star} call. This parser uses its child parser (another
predicate object parser) as much as possible on the input (\ie{} it is
a \emph{greedy} parser). Its child parser is a predicate object parser
created by the \ct{#word asParser} expression. This parser is capable
of parsing a single digit or letter as defined by the
\clsmthind{Character}{isDigit} and \clsmthind{Character}{isLetter}
methods.

\subsection{Parsing Some Input}

To actually parse a string (or stream) we can use the method
\ppmthind{parse:}:

\begin{script}{Parsing some input strings with the identifier parser}
identifier parse: 'yeah'.          --> #($y #($e $a $h))
identifier parse: 'f123'.           --> #($f #($1 $2 $3))
\end{script}

While it seems odd to get these nested arrays with characters as a
return value, this is the default decomposition of the input into a
parse tree. We'll see in a while how that can be customized.

If we try to parse something invalid we get an instance of
\clsind{PPFailure} as an answer:

\begin{script}{Parsing invalid input results in a failure}
identifier parse: '123'.           --> letter expected at 0
\end{script}

This parsing results in a failure because the first character (\ct{1})
is not a letter. Instances of \clsind{PPFailure} are the only objects in
the system that answer with true when you send the message
\ct{#isPetitFailure}. Alternatively you can also use
\ppmthind{parse:onError:} to throw an exception in case of an error:

\begin{code}{}
identifier
   parse: '123'
   onError: [ :msg :pos | self error: msg ].  
\end{code}

If you are only interested if a given string (or stream) matches or
not you can use the following constructs:

\begin{script}{Checking that some inputs are identifiers}
identifier matches: 'foo'.        --> true
identifier matches: '123'.        --> false
identifier matches: 'foo()'.      --> true
\end{script}

The last result can be quite surprising:%
indeed, a parenthesis is neither a digit nor a letter as was specified
by the \ct{#word asParser} expression. In fact, the \ct{identifier}
parser matches ``aa'' and this is enough for the \ct{matches:} call to
return \ct{true}. The result would be similar with the use of
\ct{parse:} which would return \ct{#($f #($o $o))}. %$
If you want to be sure that the complete input is matched, use
\ppmthind{end}:

\begin{script}{Ensuring that the whole input is matched}
identifier end matches: 'foo()'.   --> false
\end{script}

The \ct{end} call creates a new parser that matches the end of input.
To be able to compose parsers easily, it is important that parsers do
not match the end of input by default. Because of this, you might be
interested to find all the places that a parser can match:

\begin{script}{Finding all matches in an input}
identifier matchesSkipIn: 'foo 123 bar12'.  
identifier matchesIn: 'foo 123 bar12'.  
identifier matchingSkipRangesIn: 'foo 123 bar12'.  
identifier matchingRangesIn: 'foo 123 bar12'.  
\end{script}

The \ppmthind{matchesSkipIn:} method returns a collection of arrays
containing what has been matched (\eg{} \ct{#($f #($o $o))} and
\ct{#($b #($a $r $1 $2))} in this case. This function avoids parsing
the same character twice. The method \ppmthind{matchesIn:} does a
similar job but returns a collection which also contains sub-parsed
elements: \eg{} evaluating \ct{identifier matchesIn: 'foo 123 bar12'}
returns a collection of 6 elements: \ct{#($f #($o $o))},%
\ct{#($o #($o))}, \ct{#($o #())}, \ct{#($b #($a $r $1 $2))},%
\ct{#($a #($r $1 $2))}, and \ct{#($r #($1 $2))}. Similarly, to find
all the matching ranges (index of first character and index of last
character) in the given input one can use either
\ppmthind{matchingSkipRangesIn:} or \ppmthind{matchingRangesIn:}:
\eg{} evaluating %
\ct{identifier matchingSkipRangesIn: 'foo 123 bar12'} returns a
collection with \ct{(1 to: 3)} and \ct{(9 to: 13)}.

\subsection{Different Kinds of Parsers}

PetitParser provide a large set of ready-made parser that you can
compose to consume and transform arbitrarily complex languages. The
terminal parsers are the most simple ones. We've already seen a few of
those, some more are defined in \tabref{terminal-parsers}.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \textbf{Terminal Parsers} & \textbf{Description}                                \\
    \midrule
    \$a asParser              & Parses the character \$a.                           \\
    'abc' asParser            & Parses the string 'abc'.                            \\
    \#any asParser            & Parses any character.                               \\
    \#digit asParser          & Parses one digit (0..9).                            \\
    \#letter asParser         & Parses one letter (a..z and A..Z).                  \\
    \#word asParser           & Parses a digit or letter.                           \\
    \#blank asParser          & Parses a space or a tabulation.                     \\
    \#newline asParser        & Parses the carriage return or line feed characters. \\
  \end{tabular}
  \caption{PetitParser pre-defines a multitude of terminal parsers}
  \label{tab:terminal-parsers}
\end{table}

The class side of \clsind{PPPredicateObjectParser} provides a lot of other
factory methods that can be used to build more complex terminal
parsers. To use them, send the message \ct{asParser} to a symbol
containing the name of the factory method (such as \ct{#punctuation}
\ct{asParser}).

The next set of parsers are used to combine other parsers together and
is defined in \tabref{parser-combinators}.

\begin{table}
  \centering
  \begin{tabular}{lp{.6\textwidth}}
    \textbf{Parser Combinators} & \textbf{Description}                                                \\
    \midrule
    p1 , p2                     & Parses p1 followed by p2 (sequence).                                \\
    p1 / p2                     & Parses p1, if that doesn't work parses p2.                          \\
    p star                      & Parses zero or more p.                                              \\
    p plus                      & Parses one or more p.                                               \\
    p optional                  & Parses p if possible.                                               \\
    p and                       & Parses p but does not consume its input.                            \\
    p negate                    & Parses p and succeeds when p fails.                                 \\
    p not                       & Parses p and succeeds when p fails, but does not consume its input. \\
    p end                       & Parses p and succeeds only at the end of the input.                 \\
  \end{tabular}
  \caption{PetitParser pre-defines a multitude of parser combinators}
  \label{tab:parser-combinators}
\end{table}

So instead of using the \ct{#word} predicate we could have written
our identifier parser like this (see also \syntaxref{identifier2}):

\begin{script}[identifier2]{Another way of defining the identifier parser}
identifier2 := #letter asParser , (#letter asParser / #digit asParser) star.
\end{script}

\tikzgrammarfig{identifier2}{
  {
    \node (identifier2) [production] {identifier2:}; \&
    \node (p1)     [point]       {};           \& 
    \node (letter1) [terminal]    {letter};     \&
    \node (p2a)    [point]       {};           \& 
    \node (p2b)    [point]       {};           \& 
    \node (letter2)   [terminal] {letter};       \&
    \node (p3a)    [point]       {};           \& 
    \node (p3b)   [point]       {};           \& 
    \node (p3c)    [point]       {};           \\


    \& \& \& \& 
    \node (p10)   [point]       {};           \& 
    \node (digit)   [terminal] {digit};       \& 
    \node (p11)   [point]       {};           \& \\
  };
  { [start chain]
    \chainin (p1);
    \chainin (letter1) [join=by tip];
    \chainin (letter2)  [join=by tip];
    \chainin (p3c)     [join=by tip];
    \chainin (p2a)    [join=with p3b by {skip loop=5mm,tip}];
    \chainin (p10)    [join=with p2b];
    \chainin (digit)  [join=by tip];
    \chainin (p11)  [join];
    \chainin (p3a)    [join=with p11 by tip];
  }
}

To attach an action or transformation to a parser we can use one of
the methods defined in \tabref{action-parsers}.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \textbf{Action Parsers} & 	\textbf{Description}                                                  \\
    \midrule
    p ==> aBlock            & Performs the transformation given in \lct{aBlock}.                          \\
    p flatten               & Creates a string from the result of p.                                      \\
    p token                 & Similar to \lct{flatten} but returns a \lct{PPToken} with more information. \\
    p trim                  & Trims whitespaces before and after p.                                       \\
  \end{tabular}
  \caption{PetitParser pre-defines a multitude of action parsers}
  \label{tab:action-parsers}
\end{table}

To return a string of the parsed identifier, we can modify our parser
like this:

\begin{script}{Using flatten so that the parsing result is a string}
identifier3 := (#letter asParser , (#letter asParser / #digit asParser) star) flatten.
\end{script}

These are the basic elements to build parsers. There are a few more
well documented and tested factory methods in the \ct{operators}
protocols of \clsind{PPParser}. If you want to know more about these
factory methods, browse these protocols.

\subsection{Writing a More Complicated Grammar}

Now we are able to write a more complicated grammar for evaluating
simple arithmetic expressions. Within a workspace we start with the
grammar for a number (actually an integer):

\begin{script}[number]{Parsing integers}
number :=  #digit asParser plus token trim ==> [ :token | token value asNumber ].
number parse: '123'             --> 123
\end{script}

\tikzgrammarfig{number}{
  {
    \node (number) [production] {number:}; \&
    \node (p1a)     [point]       {};           \& 
    \node (p1b)     [point]       {};           \& 
    \node (digit) [terminal]    {digit};     \&
    \node (p2a)    [point]       {};           \& 
    \node (p2b)    [point]       {};           \\
  };
  { [start chain]
    \chainin (p1a);
    \chainin (digit) [join=by tip];
    \chainin (p2b)     [join=by tip];
    \chainin (p1b)    [join=with p2a by {skip loop=5mm,tip}];
  }
}

The \ct{token} call allows to get a token in the action block instead
of an array. The \ct{trim} call allows the parser to accept spaces
before and after the number such as in \ct{' 123 '}. The action block
asks the parser to convert any parsed string (fetched from the token
using \clsmthind{PPToken}{value}) to a number using the
\clsmthind{String}{asNumber} method.

The next step is to define the productions for addition and
multiplication in order of precedence. Note that we instantiate the
productions as \clsind{PPDelegateParser} upfront, because they recursively
refer to each other. The method \ct{#setParser:} then resolves this
recursion. The following script defines three parsers for the
addition, multiplication and parenthesis (see \syntaxref{arithmetic}
for the related syntax diagram):

\begin{script}[arithmetic]{Parsing arithmetic expressions}
term := PPDelegateParser new.
prod := PPDelegateParser new.
prim := PPDelegateParser new.
 
term setParser: (prod , $+ asParser trim , term ==> [ :nodes | nodes first + nodes last ])
                     / prod.
prod setParser: (prim , $* asParser trim , prod ==> [ :nodes | nodes first * nodes last ])
                     / prim.
prim setParser: ($( asParser trim , term , $) asParser trim ==> [ :nodes | nodes second ])
                     / number.
\end{script}

The term parser is defined as being either (1) a prod followed by '+',
followed by another term or (2) a prod. In case (1), an action block
asks the parser to compute the arithmetic addition of the value of the
first node (a prod) and the last node (a term). The prod parser is
similar to the term parser. The prim parser is interesting in that it
accepts left and right parenthesis before and after a term and has an
action block that simply ignores them.

\begin{figure}
  \centering
\tikzgrammar{
  {
    \node (term) [production] {term:};           \&
    \node (p1a)     [point]       {};           \& 
    \node (p1b)     [point]       {};           \& 
    \node (p1c)     [point]       {};           \& 
    \node (prod1) [nonterminal]    {prod};      \&
    \node (p2)     [point]       {};            \& 
    \node (plus) [terminal]    {+};             \&
    \node (p3)    [point]       {};             \\

    \& 
    \& 
    \& 
    \node (p10)     [point]       {};           \& 
    \node (prod2) [nonterminal]    {prod};     \&
    \&
    \&
    \&
    \node (p11)    [point]       {};           \\
    \\
    \node (prod) [production] {prod:}; \&
    \node (p21a)     [point]       {};           \& 
    \node (p21b)     [point]       {};           \& 
    \node (p21c)     [point]       {};           \& 
    \node (prim1) [nonterminal]    {prim};     \&
    \node (p22)     [point]       {};           \& 
    \node (mult) [terminal]    {*};     \&
    \node (p23)    [point]       {};           \\

    \& 
    \& 
    \& 
    \node (p30)     [point]       {};           \& 
    \node (prim2) [nonterminal]    {prim};     \&
    \&
    \&
    \&
    \node (p31)    [point]       {};           \\
    \\
    \node (prim) [production] {prim:}; \&
    \node (p41a)     [point]       {};           \& 
    \node (p41b)     [point]       {};           \& 
    \node (lpar) [terminal]    {(};     \&
    \node (term4) [nonterminal]    {term};     \&
    \node (p43)    [point]       {};         \&
    \node (rpar) [terminal]    {)};     \&
    \node (p44a)     [point]       {};           \& 
    \node (p44b)     [point]       {};             \\
    \&
    \& 
    \node (p51)     [point]       {};           \& 
    \&
    \node (number5) [nonterminal]    {number};     \&
    \&
    \&
    \node (p52)     [point]       {};           \\
  };
    {[start chain]
    \chainin (p1a);
    \chainin (prod1) [join=by tip];
    \chainin (plus) [join=by tip];
    \chainin (p3)    [join];
    \chainin (p1b)    [join=with p3 by {skip loop=5mm,tip}];
    \chainin (p10)    [join=with p1c];
    \chainin (prod2)    [join=by tip];
    \chainin (p11)    [join=by tip];

    \chainin (p21a);
    \chainin (prim1) [join=by tip];
    \chainin (mult) [join=by tip];
    \chainin (p23)    [join];
    \chainin (p21b)    [join=with p23 by {skip loop=5mm,tip}];
    \chainin (p30)    [join=with p21c];
    \chainin (prim2)    [join=by tip];
    \chainin (p31)    [join=by tip];

    \chainin (p41a);
    \chainin (lpar) [join=by tip];
    \chainin (term4) [join=by tip];
    \chainin (rpar) [join=by tip];
    \chainin (p44b)    [join=by tip];
    \chainin (p51) [join=with p41b];
    \chainin (number5) [join=by tip];
    \chainin (p52) [join];
    \chainin (p44a) [join=by tip];
  }
}
  \caption{Syntax diagram representation for the term, prod, and prim parsers defined in \scrref{arithmetic}}
  \label{fig:syntax-arithmetic}
\end{figure}

To make sure that our parser consumes all input we wrap it with the
\ct{end} parser into the \ct{start} production:

\begin{code}{}
start := term end.
\end{code}

That's it, we can now test our parser:

\begin{script}{Trying our arithmetic expressions evaluator}
start parse: '1 + 2 * 3'.       --> 7
start parse: '(1 + 2) * 3'.     --> 9
\end{script}

\section{Composite Grammars with PetitParser}

In the previous section we saw the basic principles of PetitParser and
gave some introductory examples. In this section we are going to
present a way to define more complicated grammars. We continue where
we left off with the arithmetic expression grammar.

Writing parsers as a script as we did previously can be cumbersome,
especially when grammar productions are mutually recursive and refer
to each other in complicated ways. Furthermore a grammar specified in
a single script makes it unnecessary hard to reuse specific parts of
that grammar. Luckily there is \clsind{PPCompositeParser} to the rescue.

\section{Defining the Grammar}

As an example let's create a composite parser using the same
expression grammar we built in the last section:

\begin{script}{Creating a class to hold our arithmetic expression grammar}
PPCompositeParser subclass: #ExpressionGrammar
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PetitTutorial'
\end{script}

Again we start with the grammar for an integer number. Define the
method \clsmthind{ExpressionGrammar}{number} as follows:

\begin{script}{Implementing our first parser as a method}
ExpressionGrammar>>number
   ^ #digit asParser plus token trim ==> [ :token | token value asNumber ]
\end{script}

Every production in \ct{ExpressionGrammar} is specified as a method
that returns its parser. Next we define the productions \ct{term},
\ct{prod}, and \ct{prim}. Productions refer to each other by reading
the respective instance variable of the same name. This is important
to be able to create recursive grammars. The instance variables
themselves are typically not written to as PetitParser takes care to
initialize them for you automatically. We let Pharo automatically add
the necessary instance variables as we refer to them for the first
time.

\begin{script}{Defining more expression grammar parsers, this time with no associated action}
ExpressionGrammar>>term
   ^ add / prod

ExpressionGrammar>>add
   ^ prod , $+ asParser trim , term

ExpressionGrammar>>prod
   ^ mul / prim

ExpressionGrammar>>mul
   ^ prim , $* asParser trim , prod

ExpressionGrammar>>prim
   ^ parens / number

ExpressionGrammar>>parens
   ^ $( asParser trim , term , $) asParser trim
\end{script}

Contrary to our previous implementation we do not define the
production actions yet (what we previously did by using
\ppmthind{==>}); and we factor out the parts for addition (\ct{add}),
multiplication (\ct{mul}), and parenthesis (\ct{parens}) into separate
productions. This will give us better reusability later on. Usually,
production methods are categorized in a protocol named \ct{grammar}
(which can be refined into more specific protocol names when necessary
such as \ct{grammar-literals}).

Last but not least we define the starting point of the expression
grammar. This is done by overriding
\clsmthind{PPCompositeParser}{start} in the \ct{ExpressionGrammar}
class:

\begin{script}{Defining the starting point of our expression grammar parser}
ExpressionGrammar>>start
   ^ term end
\end{script}

Instantiating the \ct{ExpressionGrammar} gives us an expression parser
that returns a default abstract-syntax tree:

\begin{script}{Testing our parser on simple arithmetic expressions}
parser := ExpressionGrammar new.
parser parse: '1 + 2 * 3'.       --> #(1 $+ #(2 $* 3))
parser parse: '(1 + 2) * 3'.     --> #(#($( #(1 $+ 2) $)) $* 3)
\end{script}

\section{Defining the Evaluator}

Now that we have defined a grammar we can reuse this definition to
implement an evaluator. To do this we create a subclass of
\ct{ExpressionGrammar} called \ct{ExpressionEvaluator}.

\begin{script}{Separating the grammar from the evaluator by creating a subclass}
ExpressionGrammar subclass: #ExpressionEvaluator
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'PetitTutorial'
\end{script}

We then redefine the implementation of \ct{add}, \ct{mul} and
\ct{parens} with our evaluation semantics. This is accomplished by
calling the super implementation and adapting the returned parser as follows:

\begin{script}{Refining the definition of some parsers to evaluate arithmetic expressions}
ExpressionEvaluator>>add
   ^ super add ==> [ :nodes | nodes first + nodes last ]

ExpressionEvaluator>>mul
   ^ super mul ==> [ :nodes | nodes first * nodes last ]

ExpressionEvaluator>>parens
   ^ super parens ==> [ :nodes | nodes second ]
\end{script}

The evaluator is now ready to be tested:

\begin{script}{Testing our evaluator on simple arithmetic expressions}
parser := ExpressionEvaluator new.
parser parse: '1 + 2 * 3'.       --> 7
parser parse: '(1 + 2) * 3'.     --> 9
\end{script}

Similarly a pretty printer can be defined by subclassing
\ct{ExpressionGrammar} as follows:

\begin{script}{Separating the grammar from the pretty printer by creating a subclass}
ExpressionGrammar subclass: #ExpressionPrinter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'

ExpressionPrinter>>add
  ^ super add ==> [:nodes | nodes first, ' + ', nodes third]

ExpressionPrinter>>mul
  ^ super mul ==> [:nodes | nodes first, ' * ', nodes third]

ExpressionPrinter>>number
  ^ super number ==> [:num | num printString]

ExpressionPrinter>>parens
  ^ super parens ==> [:node | '(', node second, ')']
\end{script}

This pretty printer can be tried out as follows:

\begin{script}{Testing our pretty printer on simple arithmetic expressions}
parser := ExpressionPrinter new.
parser parse: '1+2 *3'.          --> '1 + 2 * 3'
parser parse: '(1+ 2 )* 3'.      --> '(1 + 2) * 3'
\end{script}

\section{Testing a Grammar}

The PetitParser contains a framework dedicated to testing your
grammars. Testing a grammar is done by subclassing
\clsind{PPCompositeParserTest} as follows:

\begin{script}{Creating a class to hold the tests for our arithmetic expression grammar}
PPCompositeParserTest subclass: #ExpressionGrammarTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'
\end{script}

It is then important that the test case class references the parser
class: this is done by overriding the
\clsmthind{PPCompositeParserTest}{parserClass} method in
\ct{ExpressionGrammarTest}:

\begin{script}{Linking our test case class to our parser}
ExpressionGrammarTest>>parserClass
  ^ ExpressionGrammar
\end{script}

Writing a test scenario can be done by implementing new methods in
\ct{ExpressionGrammarTest}:

\begin{script}{Implementing tests for our arithmetic expression grammar}
ExpressionGrammarTest>>testNumber
  self parse: '123 ' rule: #number.

ExpressionGrammarTest>>testAdd
  self parse: '123+77' rule: #add.
\end{script}

These tests ensure that the \ct{ExpressionGrammar} parser can parse
some expressions using a specified production rule. Testing the
evaluator and pretty printer is similarly easy:

\begin{script}{Testing the evaluator and pretty printer}
ExpressionGrammarTest subclass: #ExpressionEvaluatorTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'

ExpressionEvaluatorTest>>parserClass
  ^ ExpressionEvaluator 

ExpressionEvaluatorTest>>testAdd
  super testAdd.
  self assert: result equals: 200

ExpressionEvaluatorTest>>testNumber
  super testNumber.
  self assert: result equals: 123

ExpressionGrammarTest subclass: #ExpressionPrinterTest
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''
  category: 'PetitTutorial'

ExpressionPrinterTest>>parserClass
  ^ ExpressionPrinter 

ExpressionPrinterTest>>testAdd
  super testAdd.
  self assert: result equals: '123 + 77'

ExpressionPrinterTest>>testNumber
  super testNumber.
  self assert: result equals: '123'
\end{script}

\section{Debugging a Grammar}

PetitParser comes with tools to help debug a grammar. These tools are
mostly written by Tudor Girba using the Glamour framework (see
\charef{glamour}).

\section{Example Grammars}

In this section we illustrate PetitParser through the presentation of
various parsers.

\subsection{Parsing Java annotations}

% ask fabrizio

\subsection{Parsing Smalltalk}

\section{Chapter Conclusion}

This concludes our tutorial of PetitParser. Please note that this
tutorial is not meant to give an exhaustive overview of PetitParser,
but is merely intended to introduce the reader to the usage and to our
intent for our approach. For a more extensive view of PetitParser, its
concepts and implementation, the Moose
book\footnote{\url{http://www.themoosebook.org/book}} and Lukas
Renggli's PhD have a dedicated chapter dedicated.

%=============================================================
\ifx\wholebook\relax\else
% To avoid warning message about undefined labels (that should be
% defined by other chapters)
\label{cha:glamour}
\bibliographystyle{jurabib}
\nobibliography{scg}
\end{document}
\fi
%=============================================================




%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
% LocalWords:  subclassing PetitParser
