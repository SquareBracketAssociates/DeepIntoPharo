% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% 2011-08-23 - Memento addition Stef chating with dale at ESUG.
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng

%% todo: Stef should go over all the text with the memento in mind and verify all the snippets and stress the right usage in the text

%%%%
% should integrate that.
%%The #blessing: is different from the #version:. For blessings there are only three values that have meaning:
%
%- #baseline - declaring a baseline version
%- #development - meaning the the version definition is in 
%  flux and may change over time. With any other value 
%  of blessing, the spec should never be changed.
%- #broken - meaning that the version is simply ignored ...
%
%No other blessing values have meaning within Metacello, so #release or #stable may be used

%
%
%
%
%
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
       \documentclass[a4paper,10pt,twoside]{book}
       \usepackage[
              papersize={6.13in,9.21in},
              hmargin={.75in,.75in},
              vmargin={.75in,1in},
              ignoreheadfoot
       ]{geometry}
       \input{../common.tex}
       \setboolean{lulu}{true}
% --------------------------------------------
% A4:
%       \documentclass[a4paper,11pt,twoside]{book}
%       \input{../common.tex}
%       \usepackage{a4wide}
% --------------------------------------------
     \graphicspath{{figures/} {../figures/}}
       \begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy

%=================================================================
%\renewcommand{\nnbb}[2]{#2} % Disable editorial comments


\chapter{Managing projects with Metacello}
\chalabel{metacello}
\chapterauthor{\authordale{} \\ \authormariano{}}

\noindent
Have you ever had this problem when trying to load a project: you get an error because a package that you were not even aware of is missing?  Or worse\,---\,it is present, but you have the wrong version? This situation can easily occur, even though the project loads fine for its developers, when the developers are working in a context that is different from yours. 

The solution is for the project developers to use a \emph{package management system} to explicitly manage the dependencies between the packages that make up a project.  
This chapter shows you how to use Metacello, Pharo's package management system, and the benefits of using it. 

\section{Introduction}

We say that Metacello is a \emph{package management system} for Monticello. 
But what, exactly, does that mean?
A package management system is a collection of tools that automate the process of installing, upgrading, configuring, and removing \emph{sets} of software packages. Metacello groups packages to simplify things for the user, and manages dependencies, \ie which versions of what components should be loaded to make sure that the whole set of packages is coherent. 

A package management system provides a consistent way to install packages. 
Indeed, package management systems are sometimes incorrectly referred to as installers. This can lead to confusion, because a package management system does a lot more than install software.  You may have used package management systems in other contexts: examples include Envy (in VisualAge Smalltalk), Maven (in Java), and apt-get/aptitude (in Debian and Ubuntu).

One of the key features of a package management system is that it should \emph{correctly load any package}: you should never need to manually install anything.  To make this possible, each dependency, and the dependencies of the dependencies, and so on, must be specified in the description of the package, with enough information to allow the package management tools to load them in the correct order. 

As an example of the power of Metacello, you can take a PharoCore image, and load {\em any} package of {\em any} project without any problems with dependencies. Of course, Metacello does not do magic: this only works as long as the package developers have properly defined the dependencies.

% The software is often downloaded from a number of software repositories. It is also common to have a central repository where all the software is submitted but this is totally orthogonal issue.

\section{One tool for each job}

Pharo provides three tools for managing software packages; they are closely related, but each has its own purpose. The tools are Monticello, which manages versions of source code, Gofer, which is a scripting interface for Monticello, and Metacello, which is a package management system.
% it might make sense to talk about Monticello as a Source Code Management system or SCM here? %


%As a principle, we have to know that we need {\em a tool for each job}. A tool cannot do everything. Each tool satisfies a limited amount of problems and it will probably delegate to another tool to do certain tasks. If you read the first Pharo By Example book you may noticed that this concept is quite similar to Object-Oriented Design: we don't want to have only one object that does everything and we rather to have multiple objects where each object has certain behavior and they collaborate together to do a specific task. 
%So we have 

\begin{description}

\item[Monticello: source code versioning.]
Source code versioning is the process of assigning unique versions to particular software states.  It is also called revision control.  
In particular, source code versioning incrementally keeps track of different versions, also known as revisions, of ``pieces of software''. 
In object-oriented programming, these ``pieces of software'' are methods, classes or packages. A source code versioning system lets you commit a new version, update to a new version committed by someone else, merge changes, look at the differences between versions,  revert to an older version, etc. 

Pharo uses the Monticello source code versioning system, which manages Monticello packages.  Monticello lets us do all of the above operations on individual packages, but Monticello does not provide a good way to easily specify dependencies \emph{between} packages, identify stable versions of a package, or group packages into meaningful units. \charef{Monticello} describes it. 

\item[Gofer: Monticello's scripting interface.]
Gofer is a small tool that sits on top of Monticello: it is used to load, update, merge, difference, revert, commit, recompile and unload groups of Monticello packages. Gofer also makes sure that these operations are performed as cleanly as possible. 
For more information, see \charef{gofer}.



\item[Metacello: package management.] Metacello introduces the notion of a project as a set of related Monticello packages, and is used to manage projects,   their dependencies, and their metadata. 
Metacello also manages dependencies between packages.
\end{description}




\section{Metacello features}

Metacello is consistent with the important features of Monticello. It is based on the following ideas.

\begin{description}
\item[Declarative project descriptions.] A Metacello project has named versions consisting of lists of Monticello package \emph{versions}. Dependencies are explicitly expressed in terms of named versions of required projects. A \emph{required project} is a reference to another Metacello project.  Collectively, all of these descriptions are called the project metadata.

\item[Project metadata are versioned.] Metacello project metadata is represented as instance methods in a class. Managing such metadata as code brings a lot of power in comparison to XML, which is what most package management systems use. Metacello project metadata can themselves be stored as a Monticello package, and are thus subject to version control. 
% As a result, it is easy for distributed groups of developers to collaborate on ad-hoc projects.
% apb --- this doesn't seem like a result to me!  Whether the distributed group can collaborate easily seems to depend on a lot more, like, do they share the same values and goals, speak the same language ...
As a result,
concurrent updates to the project metadata can be managed easily: parallel versions of the metadata can be merged just like parallel versions of the code base itself. 


%\ab{These last two ideas seem like the same idea to me.  But there is an important idea --- that project descriptions should themselves be under version control --- that shows through only implicitly.  Maybe this section should be refactored?}
% So: I refactored it.  Does it make sense to you?  Is there a third idea that's missing?

\end{description}

Metacello has the following features:

\begin{description}
\item[Cross-platform:] Metacello  runs on all platforms that support Monticello, which currently means Pharo, Squeak and GLASS.

\item[Conditional package loading:] to enable projects to run on multiple platforms, Metacello supports conditional loading of platform-specific Monticello packages. 

\item[Configurations:] Metacello manages \emph{configurations of projects}.  Large projects frequently have multiple variations with different sets of packages and projects required for each platform.  Each unique configuration is labeled with a version string.

% Pulled out the following sentence ... it is starting to introduce the idea of symbolic versions but if we're introducing symbolic versions now, I think it is worth going into more detail ...
  
% Moreover, there might be stable, released configurations as well as experimental configurations that have cool new features but also more bugs.

\end{description}



Metacello supports the definition of two kinds of entities (represented as methods): \emph{baselines} and \emph{versions}.

\begin{description}
\item[Baselines.] A baseline defines the basic structure of a project. The baseline lists the packages and required projects that compose the project. The baseline defines the order in which packages are to be loaded and the repositories from which the packages are to be loaded.

\item[Versions.] A version identifies the exact version of each package and project that should be loaded. A version is based upon a baseline version. For each package in the baseline version, the Monticello file name (e.g., Metacello-Base-dkh.152) is specified. For each project in the baseline version, the Metacello version number is specified. 

\end{description}


 
\begin{figure}
\begin{center}
\includegraphics[width=0.8\linewidth]{configurations}
\caption{Configurations: groups of baselines and versions with dependencies.\label{configurations}}
\end{center}
\end{figure} 


ConfigurationOfProjectA (See Figure~\ref{configurations}) contains two baselines (baseline 0.4 and 0.5) and four versions (version 0.4, 0.4.1, 0.5, and 0.6). Baseline 0.4 is composed of two packages (PackageA and PackageB). Version 0.4 is based on baseline 0.4 and specifies the version for each of the packages (PackageA-version.5 and PackageB-version.3). Version 0.4.1 is also based on baseline 0.4, but specifies different a different version for PackageA (Package-version.7).

Baseline 0.5 is composed of 3 packages (PackageA, PackageB, and PackageC) and it depends on an external project (ProjectB). A new package (PackageC) and a project dependency (ProjectB) was added to the project so a new baseline version reflecting the new structure needed to be created. Version 0.5 is based on baseline 0.5 and specifies the versions of the packages (PackageA-version.6, PackageB-version.4 and PackageC-version.1) and version of the dependent project (ProjectB-version3).



\section{A Simple Case Study}

In this example we start with a really simple configuration expressed only with versions and then we gradually add baselines. In normal life, it is better to start by definining a baseline followed by the version.

Let's start using Metacello to manage a software project called \emph{CoolBrowser}. The first step is to create a Metacello configuration for the project by simply copying the class \ct{MetacelloConfigTemplate} and naming it \ct{ConfigurationOfCoolBrowser}. A configuration is a class that describes the currently available configurations of a project (set of baselines and versions), \ie what we previously called metadata. A configuration represents different versions of projects so that you can load a project in a different environment or in different versions of Pharo. 
By convention, the name of a Metacello configuration is constructed by prefixing the name of the project with \ct{'ConfigurationOf'}. To do this, find the class \ct{MetacelloConfigTemplate} in the system browser, right click on the class name, and select the option \menu{copy}. 

This is the class definition:
\begin{code}{}
Object subclass: #ConfigurationOfCoolBrowser
       instanceVariableNames: 'project'
       classVariableNames: 'LastVersionLoad'
       poolDictionaries: "
       category: 'Metacello-MC-Model'
\end{code}

You will notice that \ct{ConfigurationOfCoolBrowser} has some instance- and class-side methods; we will explain later how they are used. Notice also that this class inherits from \ct{Object}.  This is deliberate: it's important that Metacello configurations can be loaded without any prerequisites, including Metacello itself, so Metacello configurations cannot rely on a common superclass.

Now imagine that the project \ct{CoolBrowser} has several versions, for example, 1.0, 1.0.1, 1.4, and 1.67. 
With Metacello, you create configuration methods, instance-side methods that describe the contents of each version of the project. Method names for version methods are unimportant as long as the method is annotated with the \ct{<version: >} pragma (method tagging or annotations for Pharo), as shown below.  However, there is a  convention that  version methods are named \ct{versionXXX:}, where \ct{XXX} is the version number with illegal characters (like '.') removed.


\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version01}
\caption{Simple version.\label{version01}}
\end{center}
\end{figure}

Suppose for the moment that the project \ct{CoolBrowser} contains two packages: \ct{CoolBrowser-Core} and \ct{CoolBrowser-Tests} (see Figure~\ref{version01}). A configuration method (here a version) method might look like the following one.

\begin{code}{}
ConfigurationOfCoolBrowser>>version01: spec 
	!\textbf{<version:}! '0.1'!\textbf{>}!
       
	spec for: !\textbf{\#common}! do: [
    spec !\textbf{blessing:}! #release.
		spec !\textbf{repository:}! 'http://www.example.com/CoolBrowser'.
		spec 
		    !\textbf{package:}! 'CoolBrowser-Core'  !\textbf{with:}! 'CoolBrowser-Core-BobJones.10';
			package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.3' ]
\end{code}

\noindent
The  method \ct{version01: spec} builds a description of version 0.1 of the project in the object \ct{spec}.
The common code for version \ct{0.1} (specified using the message \ct{for:do:}) consists of particular versions of the packages named \ct{'CoolBrowser-Core'} and \ct{'CoolBrowser-Tests'}.
These are specified with the message \ct{package:} \emph{packageName} \ct{with:} \emph{versionName}.
These versions are available in the Monticello repository \ct{'http://www.example.com/CoolBrowser'}, which is specified using the message \ct{repository:}. The  \ct{blessing:} method is used to denote that this is a released version and that the specification will not be changed in the future. The blessing \#development should be used when the version has not stabilized.

Now let us look at more details.

\begin{itemize}
\item Immediately after the method selector you see the pragma definition:  \ct{<version: '0.1'>}. The pragma \ct{version:} indicates that the version created in this method should be associated with version 0.1 of the CoolBrowser project. That's why we said that the name of the method is not that important. Metacello uses the pragma, not the method name, to identify the version being defined.

\item The argument of the method, \ct{spec}, is the only variable in
the method and it is used as the receiver of four different messages: \ct{for:do:}, \ct{blessing:},    \ct{package:with:}, and  \ct{repository:}.

\item Each time a block is passed as argument of the messages (\ct{for:do:}, \ct{package:with:}\dots) a new object is pushed on a stack and the messages within the block are sent to the object on the top of the stack.

\item The symbol \ct{#common} indicates that this project version is common to all platforms.  In addition to \ct{#common}, there are pre-defined attributes for each of the platforms on which Metacello runs (\ct{#pharo}, \ct{#squeak}, \ct{#gemstone}, \ct{#squeakCommon}, \ct{#pharo}, \ct{#pharo1.3.x}, etc.). In Pharo, the method \mthind{metacelloPlatformAttributes}{metacelloPlatformAttributes} defines the attribute values that you can use. 
\end{itemize}

\paragraph{About passwords.} Sometimes, a Monticello repository requires a username and password. In this case,  you can use the message \mthind{repository:username:password:}{repository:username:password:} instead of \mthind{repository:}{repository:},.

\begin{code}{}
         spec repository: 'http://www.example.com/private' username: 'foo' password: 'bar' 
\end{code}

%\ab{Leave the above until later?  Or to a reference section?}

\paragraph{Specification objects.}
A spec object is an object representing all the information about a given version. A version is just a number 
while the specification is the object. You can access (normally this is not needed) the specification using the \ct{spec} message. 

\begin{code}{}
	(ConfigurationOfCoolBrowser project version: '0.1') spec
\end{code}

This  answers an object (instance of class \ct{MetacelloMCVersionSpec}) that contains exactly the information of the method that defines version '0.1'.


%\ab{At this point, I'm also a bit confused by the nomenclature.  The Class ``ConfigurationOfCoolBrowser'' seems to define ALL of the possible CoolBrowsers, so it really represents the project, not a particular configuration of the project.  Of course, we then get teh normal class-instance dichotomy, so an Instance of ConfigurationOfCoolBrowser does indeed describe a single configuration (called a version??)}\sd{I added some text to clarify that}



\paragraph{Creating a new version.}
Let us assume that version \ct{0.2} of our project consists of the package versions \mbox{\ct{'CoolBrowser-Core-BobJones.15'}} and \mbox{\ct{'CoolBrowser-Tests-JohnLewis.8'}} and a new package \ct{'CoolBrowser-Addons'} with version \ct{'CoolBrowser-Addons-JohnLewis.3'}. We specify this new configuration by creating the following method named \ct{version02:}.

\begin{code}{}
ConfigurationOfCoolBrowser>>version02: spec 
      <version: '0.2'>
       
      spec for: #common do: [
            spec repository: 'http://www.example.com/CoolBrowser'.
            spec 
                  package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-BobJones.15';
                  package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                  package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.3']
\end{code}
 
\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version02}
\caption{Two versions of a project.}
\end{center}
\end{figure} 
 

\paragraph{Naming your Configuration.}

Previously, we learned the convention to name configuration classes. In our example, \ct{ConfigurationOfCoolBrowser}. There is also a convention to create a Monticello package with the same name as the configuration class, and to put the class in that package. So in this example you will create a package \ct{ConfigurationOfCoolBrowser} containing exactly one class, \ct{ConfigurationOfCoolBrowser}. 

By making the package name and the configuration class name the same, and by starting them with the string \ct{ConfigurationOf},  we make it easy to scan through a repository listing the available projects. It is also very convenient to have the configurations stored in their own Monticello repository. 
%That is why the repositories \ct{http://www.squeaksource.com/Pharo10MetacelloRepository} and \ct{http://www.squeaksource.com/Pharo11MetacelloRepository} exist: they contain the configurations of various tools and applications, making them easy to find. 
%\mmp{well, the truth is that so far those repos has nothing, everything is in MetacelloRepository}

%Having all configurations in the same place has several advantages:
%\begin{itemize}
%\item Finding the configuration package is easier in the Monticello browser package list.
%\item Do not have any conflict with Monticello package naming (for example, you can have the %CoolBrowser package and this might conflict with the CoolBrowserConfiguration).
%\item When you have to manage multiple Configurations in the PackageBrowser.
%\item Given that the name is slightly counter intuitive, it also has very few chances to %collide with other names.
%\end{itemize}

As a general practice, we suggest that initially you save the Configuration package in your working project. When you decide it is ready for release, you can copy it into the MetacelloRepository. A process for publishing configurations in specific distribution repositories (like the previously mentioned) is currently being defined.



\section{Loading a Metacello Configuration}
Of course, the point of specifying project configurations in Metacello is to be able to load exactly that configuration into your image, and thus to be sure that you have a coherent set of package versions. 
To load versions, you send the message \ct{load} to a version. Here are some examples for loading versions of the CoolBrowser: 

\begin{code}{}
  (ConfigurationOfCoolBrowser project version: '0.1') load.
  (ConfigurationOfCoolBrowser project version: '0.2') load.
\end{code}

Note that in addition, if you print the result of each expression, you get a list of packages \emph{in load order}: Metacello manages not only which packages are loaded, but also the order. It can be handy to debug configurations.

\paragraph{Selective Loading.} By default, the \mthind{load}{load} message loads all the packages associated with the version (as we will se later, we can change that by defining a particular group called 'default'). If you want to load a subset of the packages in a project, you should list 
the names of the packages that you are interested in as an argument to the \ct{load:} method:

\begin{code}{}
  (ConfigurationOfCoolBrowser project version: '0.2') load: 
  		{ 'CoolBrowser-Core' . 
  		'CoolBrowser-Addons' }.
\end{code}


\paragraph{Debugging Configuration.}
If you want to simulate the loading of a configuration, without actually loading it, you should use \ct{record:} instead of \ct{load:}. Then to get the result of the simulation, you should send it the message \mthind{loadDirective}{loadDirective} as follows:

\begin{code}{}
  ((ConfigurationOfCoolBrowser project version: '0.2') !\textbf{record:}! 
  		{ 'CoolBrowser-Core' .
		'CoolBrowser-Addons' }) !\textbf{loadDirective}!.
\end{code} 

Apart from \ct{load:} and \ct{record:}, there is also another useful method  which is \ct{fetch}. As explained, \ct{record:} simply records which Monticello files should be downloaded and in which order. \ct{fetch:}  accesses and downloads all the needed Monticello files. Just for the record, in the implementation \ct{load:} first does a \ct{fetch:} and then a \ct{doLoad}. 

\section{Managing Dependencies between Packages}

A project is generally composed of several packages, which often have dependencies to other packages.  It is also likely that a certain package depends on a specific version of another package. Handling dependencies correctly is really important and  is one of the major benefits of Metacello. There are two types of dependencies:
\begin{description}
\item[Internal dependencies.] There are several packages inside a project; some of them depend on other packages of the same project. 
\item[Dependencies between projects.] it is common for a project to depend on another project, or on some packages from another project. 
For example, Pier (a meta-described content management system depends on Magritte (a metadata modeling framework) and Seaside (a framework for web application development).
\end{description}



\paragraph{Internal Dependencies.} Let us focus on internal dependencies for now: imagine that the packages \ct{CoolBrowser-Tests} and \ct{CoolBrowser-Addons} both depend on \ct{CoolBrowser-Core} as described in \figref{version03}. The specifications for versions 0.1 and 0.2 did not capture this dependency. Here is a new configuration that does:

\begin{code}{}
ConfigurationOfCoolBrowser>>version03: spec 
       <version: '0.3'>
       
       spec for: #common do: [
              spec repository: 'http://www.example.com/CoolBrowser'.
              spec 
                     package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-BobJones.15';
                     package: 'CoolBrowser-Tests' with: [
                            spec 
                                   file: 'CoolBrowser-Tests-JohnLewis.8';
                                   !\textbf{requires:}! 'CoolBrowser-Core' ];
                     package: 'CoolBrowser-Addons' with: [
                            spec 
                                   file: 'CoolBrowser-Addons-JohnLewis.3';
                                   !\textbf{requires:}! 'CoolBrowser-Core' ]].
\end{code}

\noindent
In \ct{version03:} we've added dependency information using the \ct{requires:} directive.

We have also introduced the \ct{file:} message \sd{dale could we rename this file: into package:?}, which refers to a specific version   of the package. Both \ct{CoolBrowser-Tests} and  \ct{CoolBrowser-Addons} require \ct{CoolBrowser-Core}, which must be loaded before they are loaded. 
Notice that we did not specify the exact version of \ct{Cool-Browser-Core} on which they depend.  This can cause problems\,---\,but don't worry, we'll address this deficiency soon!.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version03}
\caption{Version \ct{0.3} expresses internal dependencies between packages in the same project.\label{fig:version03}}
\end{center}
\end{figure} 


With this version we are mixing structural information (required packages and repository) with version information (the exact number version). 
We can expect that, over time, the version information will change frequently while the structural information will remain more or less the same. 
To capture this, Metacello introduces the concept of \emph{Baselines}.


\section{Baselines}
A baseline represents the skeleton or architecture of a project in terms of the structural dependencies between packages or projects. A baseline defines the structure of a project using just package names. When the structure changes, the baseline should be updated. In the absence of structural changes, the changes are limited to picking specific versions of the packages in the baseline.

Now, let's continue with our example. First we modify it to use baselines: we create one method for our baseline.
\dc{I wrote the following, is it correct? The version pragma must be used so that versions can depend on a particular baseline}. Note that the method name and the version pragma can take any form. Still, for readability purposes, we add 'baseline' to both of them.
It is the argument of the \mthind{blessing:}{blessing:} message that is mandatory and defines a baseline. 
\needspace{17ex}
\begin{code}{}
ConfigurationOfCoolBrowser>>baseline04: spec 				"convention"
       <version: '0.4-baseline'> 					              		"convention"
       
       spec for: #common do: [
              spec !\textbf{blessing: \#baseline.}!    "mandatory to declare a baseline"
              spec repository: 'http://www.example.com/CoolBrowser'.
              spec 
                  package: 'CoolBrowser-Core';
                  package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core'];
                  package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core']]
\end{code}

The method \ct{baseline04:} defines the structure of \ct{'0.4-baseline'},
which may be used by several versions. For example, the version \ct{'0.4'} defined below uses it, as shown in \figref{version04}.  The baseline specifies a repository, the packages, and the  dependencies between those packages, but it does not specify the specific versions of the packages.  

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version04}
\caption{Version 0.4 now imports a baseline that expresses the dependencies between packages.\label{fig:version04}}
\end{center}
\end{figure} 

To define a version in terms of a baseline, we use the pragma \mbox{\ct{<version:imports:>}}, as follows:

\begin{code}{}
ConfigurationOfCoolBrowser>>version04: spec 
      !\textbf{<version: '0.4' imports:}! #('0.4-baseline')>
       
      spec for: #common do: [
             spec 
                   package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-BobJones.15';
                   package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                   package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.3' ].
\end{code}

In the method \ct{version04:}, we specify the specific versions of the packages. The pragma \ct{version:imports:} specifies the list of versions that this version (version '0.4') is based upon. Once a specific version is specified, it is loaded in the same way as before, regardless of the fact that it uses a baseline.

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.4') load.
\end{code}

\subsection{Loading Baselines}
Even though version \ct{'0.4-baseline'} does not contain explicit package version information, you can still load it!   
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.4-baseline') load.
\end{code}
\noindent
When the loader encounters a package without version information, it attempts to load the most recent version of the package from the repository.

Sometimes, especially when several developers are working on a project, it may be useful to load a \emph{baseline} version to access the most recent work of all of the developers.  In such a case, the \ct{baseline} version is really the ``bleeding edge'' version.

\paragraph{Declaring a new version.}
Now suppose that we want to create a new version of our project, version \ct{'0.5'}, that has the same structure as version \ct{'0.4'}, but contains different  versions of the packages.  We can capture this intent by importing the same baseline; this relationship is depicted in \figref{version05}.


\begin{code}{} 
ConfigurationOfCoolBrowser>>version05: spec 
       <!\textbf{version: '0.5' imports: \#('0.4-baseline')}>!
       
      spec for: #common do: [
            spec 
                  package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-BobJones.20';
                  package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                  package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ].
\end{code}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\linewidth]{version05}
\caption{A second version (0.5) imports the same baseline as version 0.4.}\label{fig:version05}
\end{center}
\end{figure} 

Creating a baseline for a big project will often require some time and effort, since it must capture all the dependencies of all the packages, as well as some other things that we will look at later.
However, once the baseline is defined, creating new versions of the project is greatly simplified and takes very little time. 

\section{Groups}
Suppose that now that the CoolBrowser project grows, a developer writes some tests for \ct{CoolBrowser-Addons}.  These constitute a new package named \ct{'CoolBrowser-AddonsTests'}, which naturally depends on \ct{'CoolBrowser-Addons'} and \ct{'CoolBrowser-Tests'}, as shown in \figref{version06}.

We may want to load projects with or without tests. In addition, it would be convenient to be able to load all of the tests with a simple expression like:

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load: 'Tests'.
\end{code}

instead of having to explicitly list all of the test packages, like this:
 
\begin{code}{} 
(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests').
\end{code}
 
Metacello provides the notion of \emph{group}. A group is a collection of items; each item may be a package, a project, or even another group.  
 
Groups are useful because they let you name sets of items for various purposes. Maybe you want to offer the  user the possibility of installing just the core, or the core with add-ons and development features: you can make this easy be defining appropriate groups.  Let's go back to our example, and look at how we might define a new baseline, \ct{'0.6-baseline'} that defines 6 groups, as shown in \figref{version06}. In this example, we create a group called \ct{'Tests'} that comprises \ct{'CoolBrowser-Tests'} and \ct{'CoolBrowser-AddonsTests'}. 


\begin{figure}
\begin{center}
\includegraphics[width=0.9\linewidth]{version06}
\caption{A baseline with six groups: default, Core, Extras, Tests, CompleteWithoutTests and CompleteWithTests.\label{fig:version06}}
\end{center}
\end{figure} 


To define a group we use the method \mbox{\ct{group: groupName with: group elements}.} The \ct{with:} argument can be a package name, a project, another group, or a collection of those things.  Here is the code corresponding to \figref{version06}.

 
\begin{code}{}
ConfigurationOfCoolBrowser>>baseline06: spec 
     <version: '0.6-baseline'>
     spec for: #common do: [
          spec blessing: #baseline.
          spec repository: 'http://www.example.com/CoolBrowser'.
          spec 
                 package: 'CoolBrowser-Core';
                 package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
                 package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ;
                 package: 'CoolBrowser-AddonsTests' with: [ 
                      spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
          spec 
                 !\textbf{group: 'default' with: \#('CoolBrowser-Core' 'CoolBrowser-Addons')}!;
                 group: 'Core' with: #('CoolBrowser-Core');
                 group: 'Extras' with: #('CoolBrowser-Addons');
                 group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests');
                 group: 'CompleteWithoutTests' with: #('Core' 'Extras');
                 group: 'CompleteWithTests' with: #('CompleteWithoutTests' 'Tests')
               ].
\end{code}


 
We are defining the groups in the baseline version, since a group is a structural component. Note that the default group will be used in the subsequent sections. Here the default group mentions that the two packages 'CoolBrowser-Core' and 'CoolBrowser-Addons' will be loaded when the method \ct{load} is used.

Using this baseline, we can now define version \ct{0.6} to be the same as version\ct{0.5}, except for the addition of the new package \ct{CoolBrowser-AddonsTests}.
 
\begin{code}{}
ConfigurationOfCoolBrowser>>version06: spec 
       <!\textbf{version: '0.6' imports: \#('0.6-baseline')}!>
!\vspace{-0.7ex}!
      spec for: #common do: [
            spec 
                  package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-BobJones.20';
                  package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                  package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                  package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}

 

\paragraph{Examples.} Once you have defined a group, you can use its name anywhere you would use the name of a project or package. The \ct{load:}  method takes as parameter the name of a package, a project, a group, or a collection of those items.  So all of the following statements are possible:

 
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load: 'CoolBrowser-Core'. 
       "Load a single package"

(ConfigurationOfCoolBrowser project version: '0.6') load: 'Core'. 
       "Load a single group"

(ConfigurationOfCoolBrowser project version: '0.6') load: 'CompleteWithTests'.  
       "Load a single group"
 
(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Core' 'Tests').    
       "Loads a package and a group"

(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Core' 'CoolBrowser-Addons' 'Tests'). 
       "Loads two packages and a group" 

(ConfigurationOfCoolBrowser project version: '0.6') 
       load: #('CoolBrowser-Core' 'CoolBrowser-Tests').
       "Loads two packages"
  
(ConfigurationOfCoolBrowser project version: '0.6') load: #('Core' 'Tests'). 
       "Loads two groups"
\end{code}


\paragraph{The groups \lct{'default'} and \lct{'ALL'}.} 
The \ct{'default'} group is special one.  The \ct{load} message loads the members of the \ct{'default'} groups while the group \ct{'ALL'} 
will load all the packages. Moreover, by default, 'default' loads 'ALL'!

    
\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load.
\end{code}

\noindent
loads just \ct{'CoolBrowser-Core'} and \ct{'CoolBrowser-Addons'}.

In the presence of a \ct{'default'} group, how do you load all the packages of a project?  You use the predefined group \ct{'ALL'} \index{ALL}, as shown below: 

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.6') load: 'ALL'.
\end{code}
 

\section{Dependencies Between Projects}

In the same way that a package can depend on other packages, a project can depend on other projects.  For example, Pier, which is a content management system that uses meta-description, depends on Magritte and Seaside.  A project can depend on the entirety of one or more other projects, on a group of packages from another project, or on just one or two packages from another project.

How we describe project dependencies depends on whether or not the other projects are described using Metacello. 

\subsection{Depending on a project \emph{without} a Metacello description}

Suppose that package A from Project X depends on package B from project Y, and that project Y has not been described using Metacello (this might be because there is only one package in project Y). 
In this case we can describe the dependency as follows:

\begin{code}{}
      "In a baseline method"
      spec 
             package: 'PackageA' with: [  spec requires: #('PackageB')];
             package: 'PackageB' with: [  spec 
                   repository: 'http://www.squeaksource.com/ProjectB' ].       
\end{code}

\begin{code}{}
      "In the version method"
      package: 'PackageB' with: 'PackageB-JuanCarlos.80'.
\end{code}

This works, up to a point.  The shortcoming of this approach is that because  project B is not described by a Metacello configuration the dependencies of B are not managed. 
That is, any dependencies of package B will not be loaded. So, our recommendation is that in this case, you take the time to create a configuration for the project B.

\subsection{Depending on a project \emph{with} a Metacello configuration}
Now let us look at the case where the projects on which we depend are described using Metacello.
Let's introduce a new project called \ct{CoolToolSet} that uses the packages from the \ct{CoolBrowser} project.  Its configuration class is called \ct{ConfigurationOfCoolToolSet}.   Suppose that there are two packages in \ct{CoolToolSet} called \ct{CoolToolSet-Core} and \ct{CoolToolSet-Tests}. These packages depend on packages from \ct{CoolBrowser}. 

Version \ct{'0.1'} of \ct{CoolToolSet} is just a normal version that imports a baseline:
\begin{code}{}
ConfigurationOfCoolToolSet>>version01: spec 
       <version: '0.1' imports: #('0.1-baseline')>
       spec for: #common do: [
              spec 
                     package: 'CoolToolSet-Core' with: 'CoolToolSet-Core-AlanJay.1';
                     package: 'CoolToolSet-Tests' with: 'CoolToolSet-Tests-AlanJay.1'.].       
\end{code}       

\noindent
If the project you depend on followed the  conventions (\ie class \ct{ConfigurationOfCoolBrowser} in package \ct{ConfigurationOfCoolBrowser}), the definition of the baseline is simple. By default you just need to specify the version (using \mthind{versionString:}{versionString:}) you want to load and the project repository (using \mthind{repository:}{repository:}).

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline01: spec 
       <version: '0.1-baseline'>
       spec for: #common do: [
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec project: 'CoolBrowser ALL' with: [
                            spec 
                                 !\textbf{repository:}! 'http://www.example.com/CoolBrowser';
                                 !\textbf{versionString:}! '2.5' ]
              spec 
                     package: 'CoolToolSet-Core' with: [ spec !\textbf{requires:}! 'CoolBrowser ALL' ];
                     package: 'CoolToolSet-Tests' with: [ spec requires: 'CoolToolSet-Core' ]].
\end{code}
\dc{shouldn't we use a version we defined previously instead of 2.5? The last one is 0.6.}


We've named the project reference 'CoolBrowser ALL'. The name of the project reference is arbitrary, you can select the name you want, although is it recommended to put a name that makes sense to that project reference.  In the specification for the 'CoolToolSet-Core' package, we've specified that 'CoolBrowser ALL' is required. As will be explained later, the message \ct{project:with:} allows one to specify the exact version of the project you want to load.

Now we can now load \ct{CoolToolSet} like this:

\begin{code}{}
(ConfigurationOfCoolToolSet project version: '0.1') load.
\end{code}


\subsection{For unconventional projects}

Now if the project you depend on does not follow the default convention you will have to provide more information to identify
the configuration. Let's assume that the configuration is store in a class \ct{ConfigurationOfCoolBrowser} that is stored in a Monticello package called \ct{CoolBrowser-Metacello} instead of the recommended \ct{ConfigurationOfCoolBrowser}.


\begin{code}{}
ConfigurationOfCoolToolSet >>baseline01: spec 
       <version: '0.1-baseline'>
       spec for: #common do: [
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec project: 'CoolBrowser ALL' with: [
                            spec 
                                   !\textbf{className:}! 'ConfigurationOfCoolBrowser';
                                   loads: #('ALL' );
                                   !\textbf{file:}! 'CoolBrowser-Metacello';
                                   !\textbf{repository:}! 'http://www.example.com/CoolBrowser' ].
              spec 
                     package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser ALL' ];
                     package: 'CoolToolSet-Tests' with: [ spec requires: 'CoolToolSet-Core' ]].
\end{code}       

\begin{itemize}
\item The message \ct{className:} specifies the name of the class that contains the project metadata; in this case \ct{'ConfigurationOfCoolBrowser'}.

\item The messages \ct{file:} and \ct{repository:} give Metacello the information  that it might need to search for and load class \ct{'ConfigurationOfCoolBrowser'}, if it is not present in the image.  The argument of \ct{file:} is the name of the Monticello package that contains the metadata class, and the argument of \ct{repository:} is the URL of the Monticello repository that contains that package.
If the Monticello repository is protected, then you should use the message: \ct{repository:username:password:} instead.
%\ab{I've taken a guess at the meaning of \ct{file:}.  If I'm right, then the name of this message should be changed to \ct{package:}.}
%\sd{I agree. Dale could we change file: into package:?}
%\mmp{I have already asked this one year ago. You can read the answer here: http://forum.world.st/I-think-file-is-quite-confusing-td1471992.html}\sd{we should change it.}
In this example, it is mandatory to specify the package name with \ct{file:} because \ct{'ConfigurationOfCoolBrowser'} is not placed according to the convention (it is in a package called 'CoolBrowser-Metacello' rather than 'ConfigurationOfCoolBrowser'). If you follow the convention, then it is not necessary to specify it using \ct{file:}.

\item The message \ct{loads:} specify which packages or groups to load.  The parameter of \ct{loads:} can be the same as \ct{load}, \ie name of a package, or the name of a group, or a collection of these things. Notice that \ct{loads:} is optional, you only need it if you want to load something different from the default. 

\ab{So I could have said \ct{loads: 'ALL';} and that would have meant the same thing?  If so, why didn't I?  And why is this message \ct{loads:} rather than \ct{load:} like the others?}

\end{itemize}

Pay attention that when you have multiple dependencies you should specify them using something like \ct{spec package: 'CoolToolSet-Core' with: [ spec requires: #('CoolBrowser ALL' 'XML') ]}.
It is not equivalent to \ct{spec requires: 'CoolBrowser ALL'; requires: 'XML'}
The example in the next section shows such use.


Now we can now load \ct{CoolToolSet} like this:

\begin{code}{}
(ConfigurationOfCoolToolSet project version: '0.1') load.
\end{code}

                

\begin{figure}
\begin{center}
\includegraphics[width=0.9\linewidth]{version07}
\caption{Dependencies between configurations.\label{fig:version07}}
\end{center}
\end{figure} 



\subsection{Depending on Multiple Projects}

Using 'ALL' will cause the entire \ct{CoolBrowser} project to be loaded before \ct{'CoolToolSet-Core'}. 
If we wanted to specify dependencies on CoolBrowser's test package separately from those on the core package, we might define this baseline:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
       <version: '0.2-baseline'>
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec
                    project: 'CoolBrowser default' with: [
                            spec
                                   className: 'ConfigurationOfCoolBrowser'; ''this is optional''
                                   loads: #('default');  ''this is optional''
                                   repository: 'http://www.example.com/CoolBrowser' ].
                    project: 'CoolBrowser Tests' with: [
                            spec
                                   loads: #('Tests' ); 
                                   repository: 'http://www.example.com/CoolBrowser' ].
              spec 
                     package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser default' ];
                     package: 'CoolToolSet-Tests' with: [ 
                            spec !\textbf{requires: \#('CoolToolSet-Core'  'CoolBrowser Tests')}! ].].                     
\end{code}

This baseline creates \emph{two} project references: the reference named \ct{'CoolBrowser default'} loads the 'default' group and the reference named 'CoolBrowser Tests'  loads the 'Tests' group of the configuration of CoolBrowser. We declared that \ct{'CoolToolSet-Core'} requires \ct{'CoolBrowser default'} and \ct{'CoolToolSet-Tests'} require \mbox{\ct{'CoolToolSet-Core'}} and \ct{'CoolBrowser Tests'}. Note also the use of \ct{requires:} with a collection of dependent projects.

Now it is possible to load just the core packages:

\begin{code}{}
(ConfigurationOfCoolToolSet project version: '0.2') load: 'CoolToolSet-Core'.
\end{code}

\noindent
or the tests (which will also load the core):
\begin{code}{}
  (ConfigurationOfCoolToolSet project version: '0.2') load: 'CoolToolSet-Tests'.
\end{code}

As we did for internal dependencies, baseline \ct{02-baseline} (and also in \ct{01-baseline}) does not specify the version of the project it depends on. Instead, we do this in the version method using the message \mthind{project:with:}: 
\sd{It would be nice to have a clear message that project: with: may  be project:version: and to rename versionString: as version:}
\begin{code}{}
ConfigurationOfCoolToolSet>>version02: spec 
       <version: '0.2' imports: #('0.2-baseline' )>
       spec for: #common do: [
              spec blessing: #beta.
              spec 
                     package: 'CoolToolSet-Core' with: 'CoolToolSet-Core-AlanJay.1';
                     package: 'CoolToolSet-Tests' with: 'CoolToolSet-Tests-AlanJay.1';
                     !\textbf{project:}! 'CoolBrowser default' !\textbf{with:}! '1.3';
                     !\textbf{project:}! 'CoolBrowser Tests' !\textbf{with:}! '1.3'].
\end{code}

\subsection{Loading specific packages}

In addition to baseline methods, version methods can specify
which packages to load. Here in the \ct{ConfigurationOfSoup}, we say
that we want to load in the version 1.2 the packages 'XML-Parser' and
'XML-Tests-Parser'.

\begin{code}{}
ConfigurationOfSoup>>version10: spec 
	<version: '1.0' imports:  #('1.0-baseline')>
	 
	spec for: #common do: [	
		spec 
			project: 'XMLSupport' 
			with: [spec 
						!\textbf{loads: \#('XML-Parser' 'XML-Tests-Parser'); }!
						!\textbf{versionString: '1.2.0'}!].
	
		spec 
			package: 'Soup-Core' with: 'Soup-Core-sd.11'; 
			package: 'Soup-Tests-Core' with: 'Soup-Tests-Core-sd.3';
			package: 'Soup-Help' with: 'Soup-Help-StephaneDucasse.2' ].
\end{code}


\dc{I don't understand what follows and how it is different from above} What you can also do is to use the \ct{loads:} message in the project reference to specify which packages of the project you want to load. Such solution is nice because you factor the information in the project reference and you do not have to duplicate it in all the versions.

\begin{code}{}
ConfigurationOfSoup>>version10: spec 
	<version: '1.0' imports:  #('1.0-baseline')>
	 
	spec for: #pharo do: [	
		spec project: 'XMLSupport' with: [
                       spec 
                          versionString: #stable;
                          !\textbf{loads:}! #('XML-Parser' 'XML-Tests-Parser') 
                          repository: 'http://www.squeaksource.com/XMLSupport' ].

	spec 
			package: 'Soup-Core' with: 'Soup-Core-sd.11'; 
			package: 'Soup-Tests-Core' with: 'Soup-Tests-Core-sd.3';
			package: 'Soup-Help' with: 'Soup-Help-StephaneDucasse.2' ].
\end{code}



\paragraph{Version in Baselines.} Even if this is not recommended, nothing prevents you from specifying versions from baselines. The same happens with project references. So, in addition to messages like \ct{file:}, \ct{className:}, \ct{repository:}, etc., there is a message called \ct{versionString:} which lets you specify the version of the project directly in the project reference. Example:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline011: spec 
       <version: '0.1.1-baseline'>
       spec for: #common do: [
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec project: 'CoolBrowser ALL' with: [
                            spec 
                                   className: 'ConfigurationOfCoolBrowser';
                                   loads: #('ALL' );
                                   !\textbf{versionString:}! '0.6' ;
                                   file: 'CoolBrowser-Metacello';
                                   repository: 'http://www.example.com/CoolBrowser' ].
              spec 
                     package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser ALL' ];
                     package: 'CoolToolSet-Tests' with: [ spec requires: 'CoolToolSet-Core' ]].
\end{code}       

If we don't define a version for the references \ct{'CoolBrowser default'}  and \ct{'CoolBrowser Tests'} in the version method, then the version specified in the baseline (using \ct{versionString:}) is used.  If there is no version specified in the baseline method, then Metacello loads the most recent version of the project.


In general this is not a good idea to add version information in a baseline. Now you can override the information into the version. Imagine that Kozen depends on Citezen. Citezen has two versions one stable and one under development. Now Kozen has a stable version and you want to build the development 
version and turn both development versions into stable ones. If you specify the baseline as follow.

\begin{code}{}
ConfigurationOfKozen>>baseline103: spec
	<version: '1.3-baseline'>
 	
 	spec for: #common do: [
 		spec blessing: #baseline.
 		spec repository: 'http://ss3.gemstone.com/ss/Kozen'.
 		spec package: 'Kozen'.
 		spec package: 'KoCizen' with: [spec requires: 'Citezen'].
 				
 		spec group: 'default' with: #('Kozen').
 		spec group: 'full' with: #('Kozen' 'KoCizen').
 		
 	spec project: 'Citezen' with: [
 			spec 
 			   versionString: #stable;
 			   loads: #('NoWeb' );
 			   repository: 'http://ss3.gemstone.com/ss/citezen'.	]].
\end{code}

In the version you 
\begin{code}{}
ConfigurationOfKozen>>version12: spec
       <version: '1.2' imports: #('1.3-baseline')>

       spec for: #common do: [
               spec description: 'Honoring hooks (defaultTitle -> title)'.
               spec blessing: #release.
               spec author: 'StephaneDucasse'.
               spec timestamp: '12/03/2012 21:45'.
			  !\textbf{spec project: 'Citezen' with: \#'develoment'.}!
               spec 
                       package: 'Kozen' with: 'Kozen-StephaneDucasse.32';
                       package: 'KoCizen' with: 'KoCizen-StephaneDucasse.6'.]
\end{code}



\paragraph{Reusing information.}
As you can see, in \ct{baseline02:} information is duplicated in the two project references. To remove that duplication, we can use the \ct{project:copyFrom:with:} method.  For example:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
       <version: '0.2-baseline'>
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec
                    project: 'CoolBrowser default' with: [
                            spec
                                   loads: #('default');
                                   repository: 'http://www.example.com/CoolBrowser';
                                   file: 'CoolBrowser-Metacello']
                    project: 'CoolBrowser Tests' 
                            !\textbf{copyFrom:}! 'CoolBrowser default' 
                            !\textbf{with:}! [ spec loads: #('Tests').].
              spec 
                     package: 'CoolToolSet-Core' with: [ spec requires: 'CoolBrowser default' ];
                     package: 'CoolToolSet-Tests' with: [ 
                            spec requires: #('CoolToolSet-Core' 'CoolBrowser Tests') ].].                                   
\end{code}



\section{Executing code before and after installation}
Occasionally, you may find that you need to execute some code either before or after a package or project is loaded. For example, if you are installing a System Browser it would be a good idea to register it as default after it is loaded. Or maybe you want to open some workspaces after the installation. 

Metacello provides this feature by means of the messages \ct{preLoadDoIt:} and \ct{postLoadDoIt:}.  The arguments to these messages are selectors of methods defined on the configuration class as shown below. For the moment, these pre- and post-scripts can be defined for a single package or for an entire project. 
%Revisar cuando Dale soporte esto en grupos o a referencias de projectos. 

Continuing with our example:

\begin{code}{}
ConfigurationOfCoolBrowser>>version08: spec 
       <version: '0.8' imports: #('0.7-baseline')>
       
       spec for: #common do: [
              spec 
                     package: 'CoolBrowser-Core' with: [
                            spec 
                                   file: 'CoolBrowser-Core-BobJones.20';
                                   !\textbf{preLoadDoIt:}! #preloadForCore;
                                   !\textbf{postLoadDoIt:}! #postloadForCore:package: ];
                     ....
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}

\begin{code}{}
ConfigurationOfCoolBrowser>>preloadForCore
         Transcript show: 'This is the preload script. Sorry I had no better idea'. 
\end{code}

\begin{code}{}
ConfigurationOfCoolBrowser>>postloadForCore: loader package: packageSpec
       Transcript cr; 
              show: '#postloadForCore executed, Loader: ', loader printString, 
                     ' spec: ', packageSpec printString.
       
       Smalltalk at: #SystemBrowser ifPresent: [:cl | cl default: (Smalltalk classNamed: #CoolBrowser)].
\end{code}

As you can notice there, both methods, \ct{preLoadDoIt:} and \ct{postLoadDoIt:} receive a selector that will be performed before or after the load. You can also note that the method  \ct{postloadForCore:package:} takes two parameters. The pre/post load methods may take 0, 1 or 2 arguments. The {\em loader} \sd{should explain that} is the first optional argument and the loaded packageSpec is the second optional argument. Depending on your needs you can choose which of those arguments do you want.

These pre and post load scripts can be used not only in version methods but also in baselines. If a script depends on a version, then you can put it there. If it is likely not to change among different versions, you can put it in the baseline method exactly in the same way.

As we said before, these pre and post it can be at package level, but also at project level. For example, we can have the following configuration:

\begin{code}{} 
ConfigurationOfCoolBrowser>>version08: spec 
       <version: '0.8' imports: #('0.7-baseline')>
       
       spec for: #common do: [
              spec blessing: #release.
              
              spec !\textbf{preLoadDoIt:}! #preLoadForCoolBrowser.
              spec !\textbf{postLoadDoIt:}! #postLoadForCoolBrowser.
       
              spec 
                     package: 'CoolBrowser-Core' with: [
                            spec 
                                   file: 'CoolBrowser-Core-BobJones.20';
                                   preLoadDoIt: #preloadForCore;
                                   postLoadDoIt: #postloadForCore:package: ];
                     package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                     package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}

In this example, we added pre and post load scripts at project level. Again, the selectors can receive 0, 1 or 2 arguments. 

%Mostrar ejemplos con scripts a nivel de projecto o referencia a projectos.

\section {Platform specific package}

Suppose that we want to have different packages loaded depending on the platform the configuration is loaded in. In the context of our example our Cool Browser we can have a package called \ct{CoolBrowser-Platform}. There we can define abstract classes, APIs, etc. And then, we can have the following packages: \ct{CoolBrowser-PlatformPharo}, \ct{CoolBrowser-PlatformGemstone}, etc.

Metacello \emph{automatically loads the package of the used platform}. But to do that, we need to specify platform specific information using the method \ct{for:do:} as shown in the following example. Here we define that different package version will be loaded depending on the platform. The platform specific packages will be loaded in addition to the common ones depending on which system you are executing the script. 

\begin{code}{} 
ConfigurationOfCoolBrowser>>version09: spec 
       <version: '0.9' imports: #('0.9-baseline')>
       
       !\textbf{spec for: \#common do: [}!
              ...
              spec 
                 ...
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
       
       !\textbf{spec for: \#gemstone do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone-BobJones.4'.].
       !\textbf{spec for: \#pharo do: [}!
              spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo-JohnLewis.7'.].
\end{code}

Specifying versions is one aspect, you should also specify baseline specific information. 

\begin{code}{}
ConfigurationOfCoolBrowser>>baseline09: spec 
      <version: '0.9-baseline'>
      
      !\textbf{spec for: \#common do: [}!
            spec blessing: #baseline.
            spec repository: 'http://www.example.com/CoolBrowser'.
            
            spec 
                  package: 'CoolBrowser-Core';
                  package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
                  package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ];
                  package: 'CoolBrowser-AddonsTests' with: [ 
                        spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
            spec 
                  group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                  group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
                  group: 'Extras' with: #('CoolBrowser-Addon');
                  group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
                  group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
                  group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
                  
      !\textbf{spec for: \#gemstone do: [}!
            spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone'].
      !\textbf{spec for: \#pharo do: [}!
            spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo'].
\end{code}

Notice that we add the package \ct{CoolBrowser-Platform} in the \ct{Core} group. As you can see, we can manage this package as any other and in a uniform way. Thus, we have a lot of flexibility. At runtime, when you load CoolBrowser, Metacello automatically detects in which dialect the load is happening and loads the specific package for that dialect. The \ct{for:do:} is not only for dialects but also for specific versions of those dialects. For example, we can have:

\begin{code}{}
ConfigurationOfCoolBrowser>>baseline09: spec 
      <version: '0.9-baseline'>
      
      !\textbf{spec for: \#common do: [}!
            spec blessing: #baseline.
            spec repository: 'http://www.example.com/CoolBrowser'.
            
            spec 
                  package: 'CoolBrowser-Core';
                  package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
                  package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ];
                  package: 'CoolBrowser-AddonsTests' with: [ 
                        spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
            spec 
                  group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                  group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
                  group: 'Extras' with: #('CoolBrowser-Addon');
                  group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
                  group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
                  group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
                  
      !\textbf{spec for: \#gemstone do: [}!
            spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone'].
      !\textbf{spec for: \#pharo do: [}!
            spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo'].
\end{code}



\paragraph{Loading order.}
\sd{dale is it correct?} Notice that if you 
in a system where the platform attributes are (\ct{#common} \ct{#squeakCommon} \ct{#pharo} \ct{#'pharo2.x'} \ct{#'pharo2.0.x'}) (you can obtain this information doing \ct{ConfigurationOf project attributes}) and you have specified three sections such as \ct{#common}, \ct{#pharo} and \ct{#pharo2.0.x}, these sections will loaded one after the other.

\begin{code}{}
ConfigurationOfCoolBrowser>>baseline09: spec 
      <version: '0.9-baseline'>
      
      !\textbf{spec for: \#common do: [}!
            spec blessing: #baseline.
            spec repository: 'http://www.example.com/CoolBrowser'.
            
            spec 
                  package: 'CoolBrowser-Core';
                  package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
                  package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ];
                  package: 'CoolBrowser-AddonsTests' with: [ 
                        spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
            spec 
                  group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                  group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
                  group: 'Extras' with: #('CoolBrowser-Addon');
                  group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
                  group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
                  group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
                  
      !\textbf{spec for: \#gemstone do: [}!
            spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformGemstone'].
      !\textbf{spec for: \#pharo do: [}!
            spec package: 'CoolBrowser-Platform' with: 'CoolBrowser-PlatformPharo'].
      !\textbf{spec for: \#pharo2.0.x do: [}!
            spec package: 'CoolBrowser-Addons' with: 'CoolBrowser-Core20'].
\end{code}    
    

Finally, note that the method \ct{for:do:} is not only used to specify a platform specific package, but also for anything that has to do with different dialects. You can put whatever you want from the configuration inside that block. So, for example, you can define, change and customize groups, packages, repositories, etc, for each dialect dialect. For example, you can do this:


  \begin{code}{}
 ConfigurationOfCoolBrowser>>baseline010: spec 
       <version: '0.10-baseline'>
       
       spec for: #common do: [
              spec blessing: #baseline.].
       
       spec for: #pharo do: [
              spec repository: 'http://www.pharo.com/CoolBrowser'.
              
              spec 
                     ...
              spec 
                     group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                     group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' );
                     group: 'Extras' with: #('CoolBrowser-Addon');
                     group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests' );
                     group: 'CompleteWithoutTests' with: #('Core', 'Extras' );
                     group: 'CompleteWithTests' with: #('CompleteWithoutTests', 'Tests' )].
                     
       spec for: #gemstone do: [
              spec repository: 'http://www.gemstone.com/CoolBrowser'.
              
              spec 
                     package: 'CoolBrowser-Core';
                     package: 'CoolBrowser-Tests' with: [ spec requires: 'CoolBrowser-Core' ];
              spec 
                     group: 'default' with: #('CoolBrowser-Core' 'CoolBrowser-Addons' );
                     group: 'Core' with: #('CoolBrowser-Core' 'CoolBrowser-Platform' )].                     

\end{code}       
       
In this example, for Pharo we use a different repository than for Gemstone. However, this is not mandatory, since both can have the same repository and differ in other things like versions, post and pre code executions, dependencies, etc. 

In addition, the addons and tests are not available for Gemstone, and thus, those packages and groups are not included. So, as you can see, all what we have been doing inside the \ct{for: #common: do:} can be done inside another \ct{for:do:} for a specific dialect. 


\section{Symbolic Versions}
In any large evolving application, it is difficult to know which version of a configuration to use with a specific version. 
\ct{ConfigurationOfOmniBrowser} provides a good example of the problem: version 1.1.3 is used in the Pharo1.0 one-click image,  version 1.1.3 cannot be loaded into Pharo1.2, version 1.1.5 is for Pharo1.1, version 1.2.3 is for Pharo1.2, and it cannot load in Pharo1.0, etc. 

Metacello introduces \emph{symbolic versions} to describe versions in terms of existing literal versions (like 1.1.3, 1.1.5, and 1.2.3). Symbolic versions are specified using the \ct{symbolicVersion:} pragma. Here we defined the stable versions for OmniBrowser for each version of Pharo.

\begin{code}{}
OmniBrowser>>stable: spec
     <symbolicVersion: #stable>
     spec for: #'pharo1.0.x' version: '1.1.3'.
     spec for: #'pharo1.1.x' version: '1.1.5'.
     spec for: #'pharo1.2.x' version: '1.2.3'.
\end{code}

Symbolic versions can be used anywhere that a literal version can be used. From a load expressions such as 

\begin{code}{}
(ConfigurationOfOmniBrowser project version: #stable) load
\end{code}

to a project reference in a baseline version:

\begin{code}{}
baseline10: spec
     <version: '1.0-baseline'>
     spec for: #squeakCommon do: [
          spec blessing: #baseline.
          spec repository: 'http://seaside.gemstone.com/ss/GLASSClient'.
     spec
          project: 'OmniBrowser' with: [
          spec
               className: 'OmniBrowser';
               !\textbf{versionString: \#stable;}!
               repository: 'http://www.squeaksource.com/MetacelloRepository' ].
     spec
         package: 'OB-SUnitGUI' with: [
               spec requires: #('OmniBrowser') ];
         package: 'GemTools-Client' with: [
               spec requires: #('OB-SUnitGUI') ];
         package: 'GemTools-Platform' with: [
               spec requires: #('GemTools-Client') ]].
\end{code}

Note that the \ct{#stable} here override the bleeding edge loading behavior that you would get if you would be (fool enough) to load a baseline (remember loading a baseline loads bleeding edge versions). Here we make sure that the stable version of OmniBrowser for your platform will be loaded (and not the latest one). The next section is about the different symbolic versions.
    
   
    


\subsection{Standard Symbolic Versions}
%%version number
%%stable = I do not care except that I want a certified version for the platform.
%%development = I do not care except that I want a certified version for the platform but in dev mode.
%%bleedingEdge = latest (file) 

A couple of standard symbolic versions are defined:

\begin{description}
\item[stable.] A symbolic version that specifies the stable literal version for a particular platform and version of such a platform. The stable version is the version that should be used for loading. With the exception of the \ct{bleedingEdge} version (which has a pre-defined default defined), you will need to edit your configuration to add the \ct{stable} or \ct{development} version information. \emph{I want a certified version for the platform.}

\item[development.] A symbolic version that specifies the literal version to use under development (i.e., whose blessing is \ct{development}). Typically a \ct{development} version is used by developers for managing pre-release activities as the project transitions from \ct{bleedingEdge} to \ct{stable}. There are a number of \ct{MetacelloToolBox} methods that take advantage of the \ct{development} symbolic version. \emph{I want a certified version for the platform but in development mode.}

\mmp{did we speak already about MetacelloToolBox?}


\item[bleedingEdge.]  A symbolic version that specifies the latest mcz files and project versions. By default the \ct{bleedingEdge} symbolic version is defined as the latest \emph{baseline} version available. The default specification for \ct{bleedingEdge} is defined for all projects. The \ct{bleedingEdge} version is primarily for developers who know what they are doing. There are no guarantees that the \ct{bleedingEdge} version will even load, let alone function correctly. \emph{I want the latest published file.}

\end{description}

\sd{I have the impression that this is not clear. it would be good to have an example from something stable and may from moose?}
\sd{How do I say that default is load stable? should I say it? same question for the other ones like bleedingEdge}
\mmp{default for what EXACTLY? The only 'default' we talked so far is just to now which packages to load by default, that is, when using load. But that is to an especific version. But this (bleedingEdge, stable, etc) is about which version to load. There is no default. I mean...what do you want to do it exactly?  Lets say I have ConfigurationOfProject project version: xxx.  Where is the default? what do you want to do? ConfigurationOfProject load  ??   I dont understand....  }



When specifying a symbolic version with a \ct{symbolicVersion:} pragma it is legal to use another symbolic version like the following definition for the symbolic version \ct{stable}:

\begin{code}{}
stable: spec
       <symbolicVersion: #stable>

       spec for: #gemstone version: '1.5'.
       spec for: #'squeak' version: '1.4'.
       spec for: #'pharo1.0.x' version: '1.5'.
       spec for: #'pharo1.1.x' version: '1.5'.
       spec for: #'pharo1.2.x' version: #development.
\end{code}

Or to use the special symbolic version \ct{notDefined}: as in the following definition of the symbolic version \ct{development}:

\begin{code}{}
development: spec
       <symbolicVersion: #development>

       spec for: #common version: #notDefined.
       spec for: #'pharo1.1.x' version: '1.6'.
       spec for: #'pharo1.2.x' version: '1.6'.
\end{code}

Here this indicates that there is no version for the \ct{common} tag. 
Using a symbolic version that resolves to \ct{notDefined} will result in a \ct{MetacelloSymbolicVersionNotDefinedError} being signaled.







%%%%%%%%%    
\subsection{Project Blessing and Loading}
Packages or projects pass through several stages or steps during the software development process or life cycle such as for example, development, alpha, beta, release. Sometimes we want to refer also to the state of a project.

\sd{Not sure if the following is up to date}
\mmp{from what I could see, it is.}
Blessings are taken into account by the load logic. The result of the following expression:
\begin{code}{}
ConfigurationOfCoolBrowser project latestVersion.
\end{code}
is not always the last version.  This is because \ct{latestVersion} answers the latest version whose blessing is {\em not} \ct{#development}, \ct{#broken}, or \ct{#blessing}. To find the latest \ct{#development} version for example, you should execute this expression:

\begin{code}{}
ConfigurationOfCoolBrowser project latestVersion: #development.
\end{code}

Nevertheless, you can get the very last version independently of blessing using the \ct{lastVersion} method as illustrated below

\begin{code}{}
ConfigurationOfCoolBrowser project lastVersion.
\end{code}

In general, the \ct{#development} blessing should be used for any version that is unstable. Once a version has stabilized, a different blessing should be applied.

The following expression will load the latest version of all of the packages for the latest \ct{#baseline} version:
 \begin{code}{}
(ConfigurationOfCoolBrowser project latestVersion: #baseline) load.
\end{code}

Since the latest \ct{#baseline} version should reflect the most up-to-date project structure, executing the previous expression loads the absolute bleeding edge version of the project. 


\subsubsection{Hints.}
Some patterns emerge when working with Metacello. Here is a good one: 
Create a baseline version and use the \ct{#stable} version for all of the projects in the baseline. In the literal version, use the explicit version, so that you get an explicit repeatable specification for a set of projects that were known to work together.

Here is an example, the pharo 1.2.2-baseline would include specs that look like this:

\begin{code}{}
 spec
    project: 'OB Dev' with: [
      spec
         className: 'ConfigurationOfOmniBrowser';
         versionString: #stable;
         ...];
    project: 'ScriptManager' with: [
      spec
         className: 'ConfigurationOfScriptManager';
         versionString: #stable;
         ...];
    project: 'Shout' with: [
      spec
         className: 'ConfigurationOfShout';
         versionString: #stable;
         ...];
    ....].
    
 \end{code}

Loading Pharo 1.2.2-baseline would cause the \ct{#stable} version for each of those projects to be loaded ... 
but remember over time the \ct{#stable} version will change and incompatibilities between packages can creep in. 
By using \ct{#stable} versions you will be in better shape than using \ct{#bleedingEdge} because the \ct{#stable} version is known to work.

Pharo 1.2.2 (literal version) will have corresponding specs that look like this:

\begin{code}{}
 spec
    project: 'OB Dev' with: '1.2.4';
    project: 'ScriptManager' with: '1.2';
    project: 'Shout' with: '1.2.2';
    ....].
\end{code}

So that you have driven a stake into the ground stating that these versions are known to work together (have passed tests as a unit). 5 years in the future, you will be able to load Pharo 1.2.2 and get exactly the same packages every time, whereas the \ct{#stable} versions may have drifted over time.

If you are just bringing up a PharoCore1.2 image and would like to load the Pharo dev code, you should load the \ct{#stable} version of Pharo (which may be 1.2.2 today and 1.2.3 tomorrow).
If you want to duplicate the environment that someone is working in, you will ask them for the version of Pharo and load that explicit version to reproduce the bug or whatever. 


\subsection{How to Deal with Package Structure Changes?}
Imagine that you want to develop an application on both Pharo13 and Pharo14, and that your application has only a package for one version: either because 
you changed your application or because the package was integrated into the base system. 

The solution is to define the dependencies and use the symbolic tag as a marker, as follows: 

\begin{code}{}
spec for: #'pharo' do: [
   spec package: 'that depends upon zinc' with: [
     "the common required packages for your package"
   ].
   
spec for: #'pharo1.3.x' do: [
   spec project: 'Zinc' with: [
       spec
           className: 'ConfigurationOfZinc';
           versionString: #'stable';
           repository: 'http://www.squeaksource.com/MetacelloRepository' ].
   spec package: 'that depends upon zinc' with: [
       spec requires: #('Zinc') ].
].
\end{code}

If you use the \ct{stable} version in your baseline there is no need to anything special in your version specification.




\section{Load types}
Metacello lets you specify the way packages are loaded through its ``load types". For the time of this writing, there are only two possible load types: \emph{atomic} and \emph{linear}. 

Atomic loading is used where packages have been partitioned in such a way that they can't be loaded individually. The definitions from each package are munged together into one giant load by the Monticello package loader. Class side \ct{initialize} methods and pre/post code execution are performed for the whole set of packages, not individually. 

If you use a linear load, then each package is loaded in order. Class side \ct{initialize} methods and pre/post code execution are performed just before or after loading that specific package.

It is important to notice that managing dependences does not imply the order packages will be loaded. That a package \emph{A} depends on package \emph{B} doesn't mean that B will be loaded before \emph{A}. It just guarantees that if you want to load \emph{A}, then \emph{B} will be loaded too. 

A problem with this happens also with methods override. If a package overrides a method from another package, and the order is not preserved, then this can be a problem because we are not sure the order they will load, and thus, we cannot be sure which version of the method will be finally loaded. 

When using atomic loading the package order is lost and we have the mentioned problems. However, if we use the linear mode, then each package is loaded in order. Moreover, the methods override should be preserved too. 

A possible problem with linear mode is the following: suppose project \emph{A} depends on other two projects \emph{B} and \emph{C}. \emph{B} depends on the project \emph{D} version 1.1 and \emph{C} depends on project \emph{D} version 1.2 (the same project but another version). First question, which \emph{D} version does \emph{A} have at the end?  By default (you can change this using the method \ct{operator:} in the \ct{project} method), Metacello will finally load version 1.2, \ie the latest one.

However, and here is the relation with load types, in atomic loading \emph{only} 1.2 is loaded. In linear loading, \emph{both} versions may (depending on the dependency order) be loaded, although 1.2 will be finally loaded. But this means that 1.1 may be loaded first and then 1.2. Sometimes this can be a problem because an older version of a package or project may not even load in the Pharo image we are using. 

For all the mentioned reasons, the default mode is linear. Users should use atomic loading in particular cases and when they are completely sure. 

Finally, if you want to explicitly set a load type, you have to do it in the \ct{project} method. Example:

\begin{code}{}
ConfigurationOfCoolToolSet >>project

       ^ project ifNil: [ | constructor |
              "Bootstrap Metacello if it is not already loaded"
              self class ensureMetacello.
              "Construct Metacello project"
              constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
              project := constructor project.
              !\textbf{project loadType: \#linear. '"or \#atomic'"}!
              project ]

\end{code}


\section{Conditional loading}
When loading a project, usually the user wants to decide whether to load or not certain packages depending on a specific condition, for example, the existence of certain other packages in the image. Suppose you want to load Seaside in your image. Seaside has a tool that depends on OmniBrowser and it is used for managing instances of web servers. What can be done with this little tool can also be done by code. If you want to load such tool you need OmniBrowser. However, other users may not need such package. An alternative could be to provide different groups, one that includes such package and one that does not. The problem is that the final user should be aware of this and load different groups in different situations.  With conditional loading you can, for example, load that Seaside tool only if OmniBrowser is present in the image. This will be done automatically by Metacello and there is no need to explicitly load a particular group. 

Suppose that our CoolToolSet starts to provide much more features. We first split the core in two packages: 'CoolToolSet-Core' and 'CoolToolSet-CB'. CoolBrowser can be present in one image but not in another one. We want to load the package 'CoolToolSet-CB' by default only and if CoolBrowser is present. 

The mentioned conditionals are achieved in Metacello by using the \emph{project attributes} we saw in the previous section. They are defined in the \ct{project} method. 
\sd{to me it looks really bad and I'm sure that we want to document that}
\mmp{We should not put things under the carpet. The only way to improve is to understand the current limitations and think how to make them better. }
Example:


\begin{code}{}
ConfigurationOfCoolBrowser >>project
       |  | 
       ^ project ifNil: [ | constructor |
              "Bootstrap Metacello if it is not already loaded"
              self class ensureMetacello.
              "Construct Metacello project"
              constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.
              project := constructor project.
              !\textbf{projectAttributes :=  ((Smalltalk at: \#CBNode ifAbsent: []) == nil}!
                    !\textbf{ifTrue: [ \#( \#'CBNotPresent' ) ]}!
                    !\textbf{ifFalse: [ \#( \#'CBPresent' ) ]).}!              
              project projectAttributes:  projectAttributes.
              project loadType: #linear.
              project ]

\end{code}

As you can see in the code, we check if CBNode class (a class from CoolBrowser) is present and depending on that we set an specific project attribute.
This is flexible enough to let you define your own conditions and set the amount of project attributes you wish (you can define an array of attributes).  
Now the question is how to use these project attributes. In the following baseline we see an example:

\begin{code}{}
ConfigurationOfCoolToolSet >>baseline02: spec 
       <version: '0.2-baseline'>
       
       spec for: #common do: [
              spec blessing: #baseline.
              spec repository: 'http://www.example.com/CoolToolSet'.
              spec project: 'CoolBrowser default' with: [
                            spec
                                   className: 'ConfigurationOfCoolBrowser';
                                   versionString: '1.0';
                                   loads: #('default' );
                                   file: 'CoolBrowser-Metacello';
                                   repository: 'http://www.example.com/CoolBrowser' ];
                     project: 'CoolBrowser Tests' 
                            copyFrom: 'CoolBrowser default' 
                            with: [ spec loads: #('Tests').].
              spec 
                     package: 'CoolToolSet-Core';
                     package: 'CoolToolSet-Tests' with: [ 
                            spec requires: #('CoolToolSet-Core') ];
                     package: 'CoolToolSet-CB';       
                     
             !\textbf{spec for: \#CBPresent do: [}!   
                     spec
                            group: 'default' with: #('CoolToolSet-CB' )
                            yourself ].
              
             !\textbf{spec for: \#CBNotPresent do: [}!                 
                     spec 
                            package: 'CoolToolSet-CB' with: [ spec requires: 'CoolBrowser default' ];
                            yourself ].
                     ].
              
\end{code}

You can notice that the way to use project attributes is through the existing method \ct{for:do:}. Inside that method you can do whatever you want: define groups, dependencies, etc. In our case, if CoolBrowser is present, then we just add 'CoolToolSet-CB' to the default group. If it is not present, then 'CoolBrowser default' is added to dependency to 'CoolToolSet-CB'. In this case, we do not add it to the default group because we do not want that. If desired, the user should explicitly load that package also. 

Again, notice that inside the \ct{for:do:} you are free to do whatever you want.

\section{Project version attributes}
 
% First, let us tell you something. Metacello not only includes all what we have been learning and what we will be still learning along this chapter, but also a complete set of tools with UI (user interface). These tools are based on OmniBrowser (OB), and thus, they are called OB-Metacello. This tool lets you save packages, spawn new versions, update package methods, load latest packages, save projects, update projects, among others. Unfortunately, this topic is not covered in this chapter. That's all you need to know for the moment.  
 
A configuration can have several optional attributes such as    
an author, a description, a blessing and a timestamp.  Let's see an example with a new version 0.7 of our project.
 
\begin{code}{}
ConfigurationOfCoolBrowser>>version07: spec 
       <version: '0.7' imports: #('0.7-baseline')>
       
       spec for: #common do: [
              spec blessing: #release.
              !\textbf{spec description: 'In this release .....'.}!
              !\textbf{spec author: 'JohnLewis'.}!
              !\textbf{spec timestamp: '10/12/2009 09:26'.}!
              spec 
                     package: 'CoolBrowser-Core' with: 'CoolBrowser-Core-BobJones.20';
                     package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                     package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                     package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1' ].
\end{code}
 
We will describe each attribute in detail:
 
\begin{description}

\item[Description:] a textual description of the version. This may include a list of bug fixes or new features, changelog, etc.
\item[Author:] the name of the author who created the version. When using the OB-Metacello tools or MetacelloToolbox, the author field is automatically updated to reflect the current author as defined in the image.
\item[Timestamp:] the date and time when the version was completed. When using the OB-Metacello tools or MetacelloToolbox, the timestamp field is automatically updated to reflect the current date and time. Note that the timestamp must be a String.

\end{description}

To end this section, we show you can query this information. This illustrates that most of the information that you define in a Metacello version can then be queried. For example, you can evaluate the following expressions:

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.7') blessing.
(ConfigurationOfCoolBrowser project version: '0.7') description.
(ConfigurationOfCoolBrowser project version: '0.7') author.
(ConfigurationOfCoolBrowser project version: '0.7') timestamp.
\end{code}


\section{Conclusion}
Metacello is an important part of Pharo. It will allow your project to scale. It allows you to control when you want to migrate to new version and for which packages. It is an important architectural backbone.


\newpage

\section{Metacello Memento}

\begin{footnotesize}
\begin{code}{}
ConfigurationOfCoolToolSet>>baseline06: spec 						!\emph{"could be called differently just a convention"}!
       <version: '0.6-baseline'> 						                        !\emph{"Convention. Used in the version: method"}!
       spec for: !\textbf{\#common}! do: [                                    !\emph{"\#common/\#pharo/\#gemstone/\#pharo'1.4'"}!     
              spec blessing: !\textbf{\#baseline}!.				                       !\emph{"Important: identifies a baseline"}!  
              spec repository: 'http://www.example.com/CoolToolSet'.
              
              !\emph{"When we depend on other projects"}!
              spec !\textbf{project:}! 'CoolBrowser default' !\textbf{with:}! [
                        spec
                            className: 'ConfigurationOfCoolBrowser';           !\emph{"Optional if convention followed"}!
                            !\textbf{versionString:}! #bleedingEdge;	!\emph{"Optional. Could be \#stable/\#bleedingEdge/specific version"}!
                            loads: #('default');			           	!\emph{"which packages or groups to load"}!
                            file: 'CoolBrowser-Metacello';               !\emph{"Optional when same as class name"}!
                            repository: 'http://www.example.com/CoolBrowser' ];
                     !\textbf{project:}! 'CoolBrowser Tests'         
                            !\textbf{copyFrom:}! 'CoolBrowser default'       !\emph{"Just to reuse information"}!
                            !\textbf{with:}! [ spec loads: #('Tests').].             !\emph{"Just to reuse information"}!
             
             !\emph{"Our internal package dependencies"}!
              spec 
                 !\textbf{package:}! 'CoolToolSet-Core';
                 !\textbf{package:}! 'CoolToolSet-Tests' !\textbf{with:}! [ spec requires: #('CoolToolSet-Core') ];
                 package: 'CoolBrowser-Addons' with: [ spec requires: 'CoolBrowser-Core' ] ;
                 package: 'CoolBrowser-AddonsTests' with: [ 
                      spec requires: #('CoolBrowser-Addons' 'CoolBrowser-Tests' ) ].
                      
      		 spec 
                 !\textbf{group: 'default' with: \#('CoolBrowser-Core' 'CoolBrowser-Addons')}!;
                 group: 'Core' with: #('CoolBrowser-Core');
                 group: 'Extras' with: #('CoolBrowser-Addon');
                 group: 'Tests' with: #('CoolBrowser-Tests' 'CoolBrowser-AddonsTests');
                 group: 'CompleteWithoutTests' with: #('Core' 'Extras');
                 group: 'CompleteWithTests' with: #('CompleteWithoutTests' 'Tests')
          ].  
\end{code}\end{footnotesize} 

\begin{footnotesize}
\begin{code}{}
ConfigurationOfCoolBrowser>>version07: spec 					!\emph{"could be called differently just a convention"}!
       <version: '0.7' imports: #('0.6-baseline')>				!\emph{"Convention. No baseline so this is version"}!
															!\emph{"do not import baseline from other baselines"}!
    
       spec for: !\textbf{\#common}! do: [                            !\emph{"\#common/\#pharo/\#gemstone/\#pharo'1.4'"}! 
              spec !\textbf{blessing:}! #release.		!\emph{"Required \#development/\#release: release means that it will not change anymore"}!
              spec description: 'In this release .....'.
              spec author: 'JohnLewis'.
              spec timestamp: '10/12/2009 09:26'.
              spec 
                 !\textbf{package:}! 'CoolBrowser-Core' !\textbf{with:}! 'CoolBrowser-Core-BobJones.20';                     
                 package: 'CoolBrowser-Tests' with: 'CoolBrowser-Tests-JohnLewis.8';
                 package: 'CoolBrowser-Addons' with: 'CoolBrowser-Addons-JohnLewis.6' ;
                 package: 'CoolBrowser-AddonsTests' with: 'CoolBrowser-AddonsTests-JohnLewis.1']
\end{code}
\end{footnotesize} 

\newpage
\begin{footnotesize}
\begin{code}{}
ConfigurationOfGemToolsExample>>development: spec        !\emph{"note that the selector can be anything"}!
       <symbolicVersion: #development>    				!\emph{"\#stable/\#development/\#bleedingEdge"}!
       spec for: #common version: '1.0'.	                   !\emph{"'1.0' is the version of your development version"}!
       !\emph{"\#common or your platform attributes: \#gemstone, \#pharo, or \#'pharo1.4'"}!
\end{code}
\end{footnotesize} 


\begin{footnotesize}
\begin{code}{}
ConfigurationOfGemToolsExample>>baseline10: spec
  <version: '1.0-baseline'>
  spec for: #common do: [
     spec blessing: #'baseline'.                 !\emph{"required see above"}!
     spec repository: 'http://seaside.gemstone.com/ss/GLASSClient'.
     spec
        !\textbf{project:}! 'FFI' !\textbf{with:}! [
          spec
             className: 'ConfigurationOfFFI';
             !\textbf{versionString:}! #bleedingEdge;					!\emph{"Optional. \#stable/\#development/\#bleedingEdge/specific version"}!
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'OmniBrowser' with: [
          spec
             className: 'ConfigurationOfOmniBrowser';
             versionString: #stable;									!\emph{"Optional. \#stable/\#development/\#bleedingEdge/specific version"}!
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'Shout' with: [
          spec
             className: 'ConfigurationOfShout';
             versionString: #stable;
             repository: 'http://www.squeaksource.com/MetacelloRepository' ];
        project: 'HelpSystem' with: [
          spec
             className: 'ConfigurationOfHelpSystem';
             versionString: #stable;
             repository: 'http://www.squeaksource.com/MetacelloRepository'].
     spec
        !\textbf{package:}! 'OB-SUnitGUI' !\textbf{with:}! [spec requires: #('OmniBrowser')];
        package: 'GemTools-Client' with: [ spec requires: #('OmniBrowser' 'FFI' 'Shout' 'OB-SUnitGUI' ).];
        package: 'GemTools-Platform' with: [ spec requires: #('GemTools-Client' ). ];
        package: 'GemTools-Help' with: [
          spec requires: #('HelpSystem' 'GemTools-Client' ). ].
     spec !\textbf{group:}! 'default' !\textbf{with:}! #('OB-SUnitGUI' 'GemTools-Client' 'GemTools-Platform' 'GemTools-Help')].
\end{code}         
\end{footnotesize} 







\begin{footnotesize}
\begin{code}{}
ConfigurationOfGemToolsExample>>version10: spec
     <!\textbf{version:}! '1.0' !\textbf{imports:}! #('1.0-baseline' )>
     spec !\textbf{for:}! #common !\textbf{do:}! [
          spec blessing: #development.
          spec description: 'initial development version'.
          spec author: 'dkh'.
          spec timestamp: '1/12/2011 12:29'.
     spec 
          !\textbf{project:}! 'FFI' !\textbf{with:}! '1.2';
          project: 'OmniBrowser' with: #stable;
          project: 'Shout' with: #stable;
          project: 'HelpSystem' with: #stable.
     spec
          !\textbf{package:}! 'OB-SUnitGUI' !\textbf{with:}! 'OB-SUnitGUI-dkh.52';
          package: 'GemTools-Client' with: 'GemTools-Client-NorbertHartl.544';
          package: 'GemTools-Platform' with: 'GemTools-Platform.pharo10beta-dkh.5';
          package: 'GemTools-Help' with: 'GemTools-Help-DaleHenrichs.24'. ].
\end{code}
\end{footnotesize} 

\paragraph{Loading.} \ct{load}, \ct{load:} The \ct{load} method loads the default group and if there is no default group defined, then all packages are loaded. The \ct{load:}  method takes as parameter the name of a package, a project, a group, or a collection of those items.

\begin{code}{}
(ConfigurationOfCoolBrowser project version: '0.1') load.
(ConfigurationOfCoolBrowser project version: '0.2') load: {'CBrowser-Core' . 'CBrowser-Addons'}.
\end{code}

\paragraph{Debugging.}
\ct{record}, \ct{record:} \ct{loadDirectives} The message \ct{record} does the record for the default group and if you want a specific group of items, you can use \ct{record:}, just as it is for \ct{load}.

\begin{code}{}
((ConfigurationOfCoolBrowser project version: '0.2') !\textbf{record:}! 
  		{ 'CoolBrowser-Core' .
		'CoolBrowser-Addons' }) !\textbf{loadDirective}!.
\end{code} 


\paragraph{Proposed development process.}
Using metacello we suggest the following development steps.


\begin{code}{}
Baseline						"first we define a baseline"
Version development			"Then a version tagged as development"
Validate the map				"Once it is validated and the project status arrives to the desired status"
Version release				"We are ready to tag a version as release"	

Version development			"Since development continue we create a new version"
...							"Tagged as development. It will be tagged as release and so on"
Baseline 					"When architecture or structure changes, a new baseline will appear"
Version development			"and the story will continue"
Version release

\end{code}

%=========================================================
\ifx\wholebook\relax\else
    \bibliographystyle{jurabib}
    \nobibliography{scg}
    \end{document}
\fi
%=========================================================



%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: Lint.tex
%%% TeX-PDF-mode: t
%%% End:
