<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- 	
	Cincom Smalltalk Community Blog
	Powered by Cincom Smalltalk
	http://smalltalk.cincom.com
	James A. Robertson, Vassili Bykov

	Structure:

       body
       	#container
			#header
			#main
				#content
					#posts
						.post *
					#referrers
				#menu
-->

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>

	
	
	
	
	
	
	
	
	
	
	

	

	

	
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">


	<style type="text/css" media="screen, projection">@import "/css/water-blog.css";</style>
	<style type="text/css" media="print, handheld">@import "http://www.cincomsmalltalk.com/css/minimal.css";</style>


	
	<title>Making Smalltalk Easier</title>

	<style type="text/css" media="screen, projection">@import "/css/water-blog.css";</style>
	<style type="text/css" media="print, handheld">@import "http://www.cincomsmalltalk.com/css/minimal.css";</style>


	<link rel="alternate" type="text/xml" title="RSS Feed" href="http://www.cincomsmalltalk.com/rssBlog/vbykov-rss.xml" />
	<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.cincomsmalltalk.com/rssBlog/vbykov-rss.xml" />
	<link rel="pingback" href="servlet/PingbackServlet" />

	<meta name="description" content="The best place to find out about Smalltalk" />
	<meta name="keywords" content="Smalltalk, OOP, Object, Object Technology, Object-Oriented Programming, VisualWorks, ObjectStudio, ParcPlace, Cincom, Linux, blog, Cincom Smalltalk" />
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="ICBM" content="39.214103, -76.878807" />
	<meta name="DC.title" content="Cincom Smalltalk Blog - Smalltalk with Rants" /> 

	<script language="JavaScript">
	<!--
	
	function sendMailTo(name, company, domain) {
	  locationstring = 'mai' + 'lto:' + name + '@' + company + '.' + domain;
	  window.location.replace(locationstring);
	}
	//-->
	</script>

</head>


<body>

    <div id="container">

	<div id="header">
	<div class="watermark"></div>	
		
		<p id="communityblogs">
			<a href="/userblogs">Cincom Smalltalk Community Blogs</a>
		</p>
		<a href="/userblogs" title="Cincom Smalltalk Community Blogs">
		 	<div id="logo"></div>
		</a>
		
		
	
		<h1><a href="blogView">Making Smalltalk Easier</a></h1>
		<h2><a href="javascript:sendMailTo('smalltalkbigot', 'gmail', 'com')" title="Email author">Vassili Bykov</a></h2>
		<div id="blurb">
			<p><a href="/" title="Cincom Smalltalk">Powered by Cincom Smalltalk</a></p>
			<p>Opinions expressed in this blog are not necessarily those of Cincom Systems, Inc.</p>
		</div>
	
		<p class="accessibility"><a href="#menu">Skip to Menu</a></p>

	</div> <!-- #header -->

	<div id="main">
	<div class="watermark"></div>	

		<div id="content">
		<div class="watermark"></div>	
		
			<p id="showcomments">
			<a href="blogView?showComments=true">show all comments</a>
			</p>
		
			<div id="posts">	
			<div class="watermark"></div>	
				<a name="3335654616"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Bring_Your_Own_SubscriptionRegistry&entry=3335654616" rel="bookmark">Bring Your Own SubscriptionRegistry</a></h2><p class="timestamp">September 14, 2006 02:43:36 EDT</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>After a long period of stability, there is a new version of Announcements in the public repository, preview-28.0. The change it contains is unusual in that it removes rather than adds functionality. It can therefore affect people who already use announcements.</p>

<p>Removed is the ability for an arbitrary object to remember subscriptions. There is a new class in System-Announcements, called Announcer (which previously was included as an example in the Systems-Announcements-Extras package). In order to be able to accept subscriptions, an object should either inherit from Announcer or implement in a sufficiently similar way the two or three methods that Announcer implements: #subscriptionRegistry:, #subscriptionRegistryOrNil and (typically) #postCopy.</p>

<p>In the original design, any object, including something as primitive as a SmallInteger, could accept subscription requests, remember the subscriptions, and later deliver announcements to the subscribers. This was possible because Object implemented subscription storage using one external global registry, following the tradition set by change/update (DependentsFields) and triggerEvent (EventTable). Only classes that wanted the lower cost of local subscription storage would care to store subscriptions in an instance variable instead of inheriting the global mechanism from Object.</p>

<p>The problem with that tradition are a number of subtle issues in the interaction between the external registry, #become:, and collection growth logic, as well as the risk of garbage accumulating in the global registry. A detailed review would easily make up a post of its own going some fifteen years of VW evolution back, but for now suffice it to say that the issues were bad enough that we decided to explore the alternative approach, more in the spirit of "worse is better". </p>

<p>The common case is that a relatively small number of specialized announcement sources, such as Pollock Panes, does indeed broadcast events. Such objects often replace the default storage management with local storage as a matter of optimization. In the new Announcements, this is no longer an optimization. Now it's strictly Bring Your Own SubscriptionRegistry. Any object that wants to accept subscriptions must make its own arrangements to hold onto its subscription registry.</p>

<p>I've been careful to say that an object has to make these arrangements "to be able to accept subscriptions" rather than "to be able to broadcast announcements". Conceptually, the framework still considers all objects as capable of broadcasting announcements. It's just that not all objects will accept subscriptions. From the framework's point of view, any newly created object starts off with zero subscriptions. It doesn't matter whether the object is an instance of Point or Pane. It is OK to send #unsubscribe: to both of those, which will be a no-op since there are no subscriptions to remove. It is even OK to send #announce: to both, which again will be a no-op as there are no interested recipients. The only difference is that one can send a #when:... message to Pane to create a new subscription, while sending it to Point will cause an error.</p>
</div></div></div><a name="3311592662"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Counting_the_Chickens&entry=3311592662" rel="bookmark">Counting the Chickens</a></h2><p class="timestamp">December 09, 2005 14:51:02 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>This is the last major post in the announcements series. After seeing how announcements are more powerful, flexible and consistent than events, it's interesting to compare the implementations.</p><p>I guess we all are used to the concept that there is never a free lunch, and all those niceties with &quot;real&quot; objects have to cost something. One of the first email responses I got after posting the first message outlining the framework said, &quot;How do announcements compare to the old event system in term of performance? I know CPUs are faster and faster, but....&quot;</p><p>I should say that I never made any concessions to performance in Announcements. I didn't ignore the subject entirely by doing stupid things in the code, of course, but nothing in the API is the way it is because &quot;it's faster this way.&quot; So, I also was interested to know how announcements with their OO purity would compare to triggerEvent in the end.</p><p>The main thing to test is of course the speed of announcement/event delivery, since it is the main overhead events and announcements add to application logic. The tests I used were these:</p><pre>	ObjectMemory garbageCollect.	foo := Object new.	1 to: &lt;N&gt; do: [:i | foo when: #foo send: #yourself to: i].	Time millisecondsToRun: 		[100000 timesRepeat: [foo triggerEvent: #foo]]		ObjectMemory garbageCollect.	foo := Object new.	1 to: &lt;N&gt; do: [:i | foo when: Announcement send: #yourself to: i].	Time millisecondsToRun: 		[100000 timesRepeat: [foo announce: Announcement]]</pre><p>Where &lt;N&gt; would vary to change the number of subscriptions. The memory is reset to the same state before the test to avoid sudden random spikes due to garbage collection. An interesting point is why I'm using #to:do: instead of a simple #timesRepeat:. As said more than once before, the overall policy of Announcements is that the framework is very subscription-centric. A subscription request always sets up a new subscription. If you do</p><pre>	10 timesRepeat: [foo when: Announcement do: [Transcript show: 'gotcha']]</pre><p>you set up ten subscriptions for the same object. Why you want multiple subsriptions is your business, and the framework doesn't care. You ask for it, you get it. With triggerEvent, you only get a subscription if there wasn't another one like it before. So, the ten requests above would create one subscription.</p><p>Here are the millisecond times and the speed ratio depending on the number of subscriptions (times are averages of three runs, after one ignored &quot;warm up&quot; run to fill the VM caches).</p><table cellpadding="5px"><tr><th>&lt;N&gt;</th>	<th>triggerEvent</th>	<th>Announcements</th>	<th>Ratio</th></tr><tr><td>0</td>	<td>267</td>	<td>314</td>	<td>0.850</td></tr><tr><td>1</td>	<td>617</td>	<td>529</td>	<td>1.17</td></tr><tr><td>3</td>	<td>734</td>	<td>610</td>	<td>1.20</td></tr><tr><td>10</td>	<td>1004</td>	<td>741</td>	<td>1.35</td></tr><tr><td>30</td>	<td>1711</td>	<td>1120</td>	<td>1.53</td></tr><tr><td>100</td>	<td>4320</td>	<td>2430</td>	<td>1.78</td></tr></table><p></p><p>These are rather stunning results, and the natural question is why triggerEvent starts with a 15% speed advantage but then the tables are turned so dramatically.</p><p>The answer is that this gap between the ratios for 0 and 1 subscription is the cost of event delivery. With 0 subscriptions there are no deliveries happening, with 1 delivery code starts working. This huge gap shows how expensive event delivery in triggerEvent really is. It is that expensive because of complex argument handling (I wish I could summarize what exactly is so expensive in it but honestly, I never could understand the thing in its entirety). In contrast, all that needs to be done in Announcements is pass the announcements to the subscribers who want it.</p><p>Another interesting point is why triggerEvent has that initial advantage at all. This is simply because triggerEvent cuts corners. As I said in Advanced Announcements, part 5, even though in triggerEvent you can declare the events a class presumably triggers, that declaration is not enforced. Even if the class says it triggers only #a and #b it's free to trigger #c as well. In contrast, the #mayAnnounce: validation hook in announcements is used consistently, and announcements are validated when they are announced.</p><p>Now let's look at the implementation size. Both frameworks have some classes of their own (though you rarely interact with any of those in triggerEvent) and some methods in Object. triggerEvent also has a number of #evaluate and #evaluateWithArguments: methods scattered around the system as part of argument processing implementation (and I consider that generic #evaluate the worst conceptual sin of triggerEvent).</p><p>Here are the counts of all of those, and also the combined byte size of all the involved methods. Byte size is a pretty good indication of how much &quot;real&quot; code is in the system, since it doesn't depend on variable and selector name length, formatting style and other noise simple source code-based metrics suffer from.</p><table cellpadding="5px"><tr><th></th><th>triggerEvent</th>	<th>Announcements</th></tr><tr><td>Classes	</td>	<td>6</td>	<td>7</td></tr><tr><td>methods in those</td>	<td>41</td>	<td>58</td></tr><tr><td>methods in Object</td>	<td>44</td>	<td>12</td></tr><tr><td>other methods</td>	<td>13</td>	<td>0</td></tr><tr><td>total methods</td>	<td>98</td>	<td>70</td></tr><tr><td>byte code size</td>	<td>1130</td>	<td>697</td></tr></table><p></p><p>It appears that Announcements code size is only 61% of that of triggerEvent. I hope this calms another concern I heard after adding weakness support, that Announcements should not become a swiss army knife with solutions for all imaginable problems. The framework is so small because its API is deliberately designed to offer a small set of parts that can be composed, rather than a bunch of monolithic solutions. If anything, Announcements is a knife construction kit with a couple of basic useful knives pre-assembled.</p><p>So on the subject of cost. Since it appears all the extra power of announcements comes with a smaller and faster implementation to boot, is this a free lunch after all?</p><p>In a way yes, because Smalltalk pays for it. triggerEvent could have been implemented in C++. Announcements couldn't, at least not anywhere close in simplicity. I have strong doubts about Java either. As a mini-rant, I think even Smalltalkers often underestimate how much power Smalltalk objects give them at what little cost. The fundamental problem with triggerEvents was that it didn't embrace objects from the start. There was a valid reason for that, when its foundations were laid down in a Smalltalk system running in 640k of memory with a reference counting garbage collector. But it was twenty years ago. Unfortunately, when those constraints stopped being an issue fifteen years ago all the while the framework faced new requirements, it was made more and more complex instead of reviewing the priorities. That is the second main problem. It's a strange fact that simplifying things takes more work and ingenuity than complicating them, and that's another reason why Announcements are so small and simple with all their power. Quite a lot of work went into polishing the basic concepts to make them so.</p><p>To paraphrase J. S. Bach, &quot;Simplifying a framework in Smalltalk is easy. You select the right methods, click 'remove' and Smalltalk simplifies it for you&quot;.</p></div></div></div><a name="3311501005"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=API_update:_R.I.P._veto&entry=3311501005" rel="bookmark">API update: R.I.P. veto</a></h2><p class="timestamp">December 08, 2005 13:23:25 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>As these posts were progressing together with new framework versions published, nothing already described was invalidated by later published versions, until the version preview-16.0.</p><p>That and later versions have the built-in vetoing as described in &quot;announcing and vetoing&quot; removed. All things considered, with announcement object as a natural two-way communication channel between the announcer and the subscriber, vetoing implementation is so trivial that it's better applied as a pattern where needed rather than implemented by the generic Announcement and carried around by all announcements, when most of them are in fact not vetoable.</p><p>All an announcement class needs in order to support vetoing are three simple things:</p><ol>	<li>an instance variable named something like 'vetoed'</li>	<li>a method named something like #veto that sets the variable to a non-nil value, used by subscribers to veto.</li>	<li>a method named somehing like #isVetoed that does &quot;^vetoed notNil&quot;</li></ol><p>The announcer would do this to announce and respond to a veto request:</p><pre>    | announcement |    announcement := AboutToChange new.    self announce: announcement.    announcement isVetoed ifTrue: [^self]    ...</pre><p>or even simpler, using the fact that the #announce: message answers the announcement instance that has just been announced:</p><pre>    (self announce: AboutToChange) isVetoed ifTrue: [^self]    ...</pre><p>Having that variable and methods in generic Announcement when most announcements are in fact not vetoable was a waste, and the extra #isVetoable declaration to enable that support added unnecessary complexity.</p><p>A valid question is why not place this support in a subclass of announcement called VetoableAnnouncement and have vetoable announcements inherit from it. There is no such class provided because with Announcements, the primary purpose of subsclassing is not to reuse code, but to describe how announcements are related in their meaning. For example, if I have something like this:</p><pre>    PropertyChange        PropertyAdded        PropertyRemoved        PropertyValueChanged            PropertyResetToDefault</pre><p>the framework knows that if I say I want to know about PropertyValueChanged then I also want PropertyResetToDefault, because I consider it a kind of the same thing. Making PropertyResetToDefault vetoable shouldn't change that. </p><p>Having said that there is no such class, there is one in System-Announcements-Extras package I mentioned in the previous post--if anything, as an example of how simple it is to make an announcement vetoable.</p><p>Terry could rightfully point out again that traits could solve this by making vetoing a trait, and they would indeed. But even within classic Smalltalk, adding a variable and two one-liners by hand where needed isn't the worst problem to face.</p></div></div></div><a name="3311456955"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Advanced_Announcements,_part_5&entry=3311456955" rel="bookmark">Advanced Announcements, part 5</a></h2><p class="timestamp">December 08, 2005 01:09:15 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>Rich and Travis have already been discussing declarations and reflection. This post is not as much a user's guide as an explanation why the current incarnation of the framework doesn't commit very much to that idea. I can say right away that I am not brimming with excitement regarding declarations. Nor am I rejecting the idea outright.</p><p>I'll start with some definitions and clarifications so we don't entangle ourselves in our own misinterpretations. </p><p>One thing we talk about is <em>reflection.</em> Loosely speaking, reflection is the ability of our Smalltalk image to know and/or modify its structure. In our neck of the woods, reflection is universally considered to be a Very Good Thing.</p><p>The other thing are <em>declarations.</em> One motif that rather bothered me in the discussion was the apparent confusion between declarations and reflection, with an implication that declarations are needed because they provide reflection and reflection is good. Declarations and reflection are entirely different things. You can have one and not the other. Declarations can support reflection, but they are neither required nor automatically enable it. Consider that C++ and similar languages are very declaration-heavy and reflection-light, while Smalltalk is the other way around. </p><p>We can fairly accurately find out what messages methods of a particular class send without having the class declare each message it sends. What we find is not guaranteed to be 100% accurate, but for most tasks in tools 90% is good enough. Enough to say that requiring mandatory declarations of all sent messages so the tools could gain the last 10% is not a very attractive proposition, at least not within our laid-back Smalltalk culture.</p><p>To avoid confusion, it's better to separate reflection into two kinds: <em>introspective reflection</em>, when you muck around with code and figure out what it does, and <em>declarative reflection</em> when you know what the code does because declaration restricts what it could do. (Yes, I've just made these terms up).</p><p>The important difference between these is that introspective reflection follows the code while declarations want the code to follow them. This once again shows why reflection and declarations are not the same. The primary goal of a declaration is limiting what is possible in the code, and reflection is only a byproduct of that. In fact, declarative reflection is <em>not</em> true reflection at all--you know your code won't do what declaration does not allow, but you don't know how much it does of what is allowed. You still need introspective reflection to know that.</p><p>Declarations establish a law for code to follow, and there is no law without law enforcement. Unless you ensure the code only does what the declarations say, any &quot;reflection&quot; based on the declarations is only an educated guess. So, reflection might not go hand-in-hand with declarations, but <em>enforcement</em> does.</p><p>Enforcement can be done at <em>compile time</em> and <em>runtime.</em> Compile-time enforcement is far superior. It's more user-friendly because it points our errors as soon as they are made. It's also more reliable because it catches all errors, while runtime errors can go unnoticed if the particular piece of code runs rarely. This is why even for message sends, the sent selector is verified to at least exist at compile time, with a warning if it doesn't.</p><p>With all the above combined, I think I know what Travis meant when he said about using introspective reflection for finding announcements, &quot;This seemed like a cool idea, because, it's so... I don't know what the right word is.&quot; It's so much more in the spirit of Smalltalk to let the code be free and follow it when needed, rather than establish artificial limits at a high level, with whatever good intentions. Consider how the existing declarations (such as variable, import, pragma) restrict the code only in the most basic ground rules, usually enforced at compile time.</p><p>This is why I am not too keen on embracing announcement declarations outright. They feel alien. They are too high up the food chain. Consider the parallel with Exceptions. There are no declarations of exceptions a class can signal. Do we need them? I'm sure someone could come up with a reason for that. Are we doing well without them? There's the rub.</p><p>If Exceptions are not a good example as far as declarations are concerned, what about #eventsTriggered in triggerEvent? Here is why eventsTriggered are apparently intended to solve an unrelated problem, which Announcements solve much better by different means. </p><p>Let's start with this. Assuming a class has a declaration of announced things of some sort, enforced at runtime, when exactly should it be enforced? The #announce: method is one obvious spot, since otherwise we could announce things we claim we don't announce. What about when accepting subscriptions--should it be ok to subscribe to something an object can't announce? In other words, what precisely does an announcement declaration restrict: only announcements, or both announcements and subscriptions?</p><p>Regardless of the answer, what triggerEvent provides is off the mark. It has something called event checking, turned off by default in Object. A subclass can turn it on and add #eventsTriggered declarations. However, a closer look reveals that what is checked against those declarations are actually the &quot;when:...&quot; subscription messages, while triggerEvent: won't balk at anything. So, despite the &quot;eventsTriggered&quot; name, instances can trigger anything at all--it's just that they won't accept subscriptions to it!</p><p>Obviously, event checking in triggerEvent isn't concerned with any high-level principles like &quot;declarations should limit and describe what the code can do&quot;. It must have been implemented ad-hoc to address some immediate practical needs. And I think the main of those was protecting against typos. When events are symbols, it's easy to mistype one, subscribe to an unexistent event and then wonder why the event is apparently not being triggered. So the true purpose of #eventsTriggered, despite the name, is not to list the events a class triggers, but simply list some symbols the class knows are valid event names it <em>presumably</em> triggers. </p><p>Now, to Announcements.</p><p>If the true purpose of #eventsTriggered appears to be protection against typos, Announcements have it. Only better. If you mistype an announcement name you get an error at compile time, and the error checker can event find the correct name for you.</p><p>With this out of the way and the counter-example of Exceptions, I hope it's getting clear why I am not entirely convinced declarations are the way to go. I believe we simply don't have enough collective experience using them to come to any conclusions right now. Now is the time to let a hundred flowers bloom to get that experience, and not expect an answer in a month--and probably not in a year. </p><p>This is why all the Announcements proper provides is a hook for runtime enforcement of both subscriptions and announcements. All announcements and all subscription requests need to pass a class check implemented by #mayAnnounce: method of the announcer. The method accepts the class being announced or subscribed to as the argument and should answer false if the class is not supported. </p><p>However, there is no &quot;official&quot; way in Object of declaring the supported announcements, and the default implementation of #mayAnnounce: in Object answers true to everything.</p><p>Having said this, I published to the public repository System-Announcements-Extras package with Announcer class implementing announcement declarations--as an example or a superclass to subsclass from for those willing to experiment. As I said, I don't reject the idea outright.</p><p>This is the lay of the land for the near future.</p></div></div></div><a name="3311346152"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Advanced_Announcements,_part_4&entry=3311346152" rel="bookmark">Advanced Announcements, part 4</a></h2><p class="timestamp">December 06, 2005 18:22:32 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>This part's subject are Weak Subscriptions.</p><p>Ladislav Lenart brought up an interesting point about one feature shared by all depedency frameworks so far--change/update, triggerEvent and first publicly available versions of Announcements. The feature is that, in Announcements language, subscribing creates a strong reference from the announcer to the subscriber. Even if any other references to the subscriber are gone, the subscriber will stay alive as long as the announcer it's subscribed to is alive. This is actually what allows the following to work:</p><pre>	anObject when: Announcement do: [Transcript cr; show: 'gotcha']</pre><p>despite the fact that no references to the block closure are saved anywhere.</p><p>On the one hand, allowing code like the above to work the way it does seems like a good thing. Even for &quot;regular&quot; objects rather than blocks as subscribers, sometimes it's convenient to be able to just attach some kind of a logger object to the announcer and let it hang there without bothering to explicitly arrange for a separate reference to it to keep it alive.</p><p>On the other hand, a reverse scenario is also possible, where we don't want subscribers to stay alive unless they have other reasons to exist. We could have relatively short-lived temporary objects, such as components of a UI, subscribe for events from a long-lived model object. Those temporary objects would need to be explicitly unsubscribed before they could become garbage.</p><p>There seem to be two points of view on this subject, one that the Right Thing is to require subscribers to unsubscribe themselves explicitly, as their duty in maintaining the overall solid object structure. The other is that C++ people also say it's good to maintain object structure by hand, while we know that it's nice when things just work. Both sides have their valid convincing arguments, and all together it looks like different scenarios can benefit from different behavior, or at least different people prefer different approaches and are ready to deal with the shortcomings of their preference.</p><p>Fortunately, Announcements can now easily support and  mix and match both approaches, with strong as the default and weak as an option. Even better, support for weakness comes at no cost to the default strong behavior, and plugs naturally into the rest of the framework API.</p><p>As with the rest of the advanced API, subscriptions selection messages take center stage in configuring weakness . To weaken some subscriptions we do something like</p><pre>    (anObject subscriptionRegistry subscriptionsOf: self) makeWeak</pre><p>From now on, when there are no strong references to self, the object will get garbage collected and its subscriptions with anObject will disappear on their own.</p><p>It is possible to weaken subscriptions right when you create them, using a feature of subscription messages we have not yet talked about. The feature is that all subscription messages (#when:send:to:, #when:do:, #when:do:for:) answer the subscriptions they have just set up. So instead of a separate protocol for setting up weak subscriptions, all we need is send #makeWeak to the result:</p><pre>    (anObject when: Foo send: #fooHappened: to: self) makeWeak.</pre><p>This covers one side of announcer-subscriber relationship, where the subscriber wants to create susbcriptions that won't keep it alive. On the other side of the relationship, it is possible to configure the announcer so that all subscriptions created with it are weak by default. The announcer's subscription registry is the factory that actually creates subscriptions, and the class it instantiates to do that is a parameter. The default strong subscriptions are instances of AnnouncementSubscription. Weak subscriptions are instances of its ephemeral subclass WeakAnnouncementSubscription. So, in order to configure an object to always use weak subscriptions for its announcements, all we need to do is this:</p><pre>    anObject subscriptionRegistry subscriptionClass: WeakAnnouncementSubscription</pre><p>From this moment on, all new subscriptions set up with that object are created as weak. This does not affect already existing subscriptions.</p><p>This preference for weak subscriptions can be turned into the default for a particular announcer class, by hooking into the framework in a different place. A subscription registry for an object is originally created by the method #createSubscriptionRegistry. Instances of a class reimplementing that method as</p><pre>    createSubscriptionRegistry        ^SubscriptionRegistry new subscriptionClass: WeakAnnouncementSubscription</pre><p>will always default to weak subscriptions, without the need to explicitly reset the subscription class in each. And on the flip side, just like you can individually weaken some subscriptions created by classes that default to  strong, a subscriber can individually strengthen its subscriptions with classes defaulting to weak:</p><pre>     (anObject subscriptionRegistry subscriptionsOf: self) makeStrong        (anObject when: Foo send: #fooHappened: to: self) makeStrong</pre><p>To be continued...</p></div></div></div><a name="3311267425"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Advanced_Announcements,_part_3&entry=3311267425" rel="bookmark">Advanced Announcements, part 3</a></h2><p class="timestamp">December 05, 2005 20:30:25 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p><html><div xmlns="http://www.w3.org/1999/xhtml"><p>Back to suspending subscriptions.</p><p>Another suspension option is #suspendWhile:ifAnyMissed:. It takes a second argument which should always be a no-argument block. It works just like #suspendWith: in that the subscriptions you send this to are suspended and don't deliver anything to their recipients while the block runs. In addition, they keep track of whether there have been any &quot;missed calls&quot;. After the &quot;while&quot; block finishes, the second block is evaluated once if there have been any undelivered announcements while the first block ran.</p><p>This serves the use case of &quot;I want to bunch up potential multiple updates&quot;. For example, the following code will suppress Foo announcements but will then ensure one of those gets announced as a summary if needed:</p><pre>	(anObject subscriptionRegistry subscriptionsFor: Foo)		suspendWhle: [...do stuff...]		ifAnyMissed: [anObject announce: Foo]</pre><p>On the recipient side, if we want to suspend response to updates from a certain object but then catch up with a single update, we can also do something like:</p><pre>	(anObject subscriptionRegistry subscriptionsOf: self)		suspendWhile: [...]		ifAnyMissed: [self update]</pre><p>Again, overlap between subscrptions suspended by nested blocks  is handled correctly, in the sense that nested suspend requests don't affect the outer ones and vice versa. If an outer block suspends a subscription, and then an inner block suspends it again with #suspendWhile:ifAnyMissed:, the missed block will run if needed after the inner block ends, while the subscription will stay suspended until the outer block ends. Conversely, if an outer block runs with #suspendWhile:ifAnyMissed: and the inner block suspends the same subscription outright, and an announcement arrives to that subscription inside the inner block, the summary block will run after the outer block exits.</p><p>The third suspending option we need to cover arranges it so that a block of code runs in lieu of each delivery that would have happened otherwise. For example, the following code will count how many actual announcement deliveries would have occurred:</p><pre>	count := 0.	(anObject subscriptionRegistry subscriptionsFor: Foo)		interceptWith: [count := count + 1]		while: [anObject announce: Foo].	^count</pre><p>Interceptor block can take arguments, with the same interpretation as in handler blocks established by #when:do:. These open up quite a lot of options of what can be done by the interceptor.</p><p>For example, the above code counts deliveries. If there are five subscribers for Foo, and Foo has been announced twice, the count will be 10 for the ten deliveries that would have occurred. If we want to count how many actual announcements were broadcast, regardless of how many objects would have received them, we can do this:</p><pre>	announcements := IdentitySet new.	(anObject subscriptionRegistry subscriptionsFor: Foo)		interceptWith: [:ann | announcements add: ann]		while: [anObject announce: Foo].	^announcements size</pre><p>If the interceptor block has two arguments, it receives the announcement and the announcer, again just like in a regular handler. In the context of an interceptor block this probably isn't as useful. Since in order to get the subscriptions to intercept we start with the announcer and its registry, we typically know who the announcer is anyway.</p><p>The interceptor block can also take three arguments. In that case, the third argument is the subscription that has just been intercepted. Given that, the interceptor can find out the subscriber of the intercepted delivery. Coming back to our example, to count how many subscribers would have received the announcements we intercepted, we would do this:</p><pre>	subscribers := IdentitySet new.	(anObject subscriptionRegistry subscriptionsFor: Foo)		interceptWith: [:a :o :s | subscribers add: s subscriber]		while: [anObject announce: Foo].	^subscribers size</pre><p>Another important option the access to subscription gives us is writing transparent interceptors, those that don't prevent announcements from reaching their subscribers. The following code will silently count how many announcements have been announced, but other than that it will be business as usual and all announcements will safely make it to all of their subscribers:</p><pre>	announcements := IdentitySet new.	(anObject subscriptionRegistry subscriptionsFor: Foo)		interceptWith: 			[:announcement :announcer :subscription | 			announcements add: announcement.			subscription deliver: announcement from: announcer]		while: [anObject announce: Foo].	^announcements size</pre><p>The final &quot;subscription deliver: announcement from: announcer&quot; is what you can use in interceptors to pass the announcement on to the intended recipient, conditionally or unconditionally at the end of the interceptor block.<p>I mentioned that an interceptor block can take the same arguments a handler block or a handler method can. Indeed, ordinary handler blocks and methods can also take the subscription as their third argument. However, in a regular handler, knowing the subscription that delivers the announcement is not quite as useful. Asking it about its subscriber is pointless when you are the subscriber, just as telling it to deliver the announcement when it is already in the process of being delivered. </p><p>One final note about interceptors is their behavior in case of nesting. Interceptors are additive. If you set up an interceptor on a subscription and then set one up in a nested block, both will run when the subscription attempts to deliver an announcement. This is in line with the overall philosophy that nested suspend and intercept requests are independent and don't affect each other's behavior. One notable consequence of this is if both interceptor blocks do &quot;subscription deliver: announcement from: announcer&quot;, the subscriber will get the same announcement twice, once from each of the interceptors. Such is the nature of the beast.</p><p>To be continued...</p></p></div></html></p></div></div></div><a name="3311201882"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Advanced_Announcement_Handling,_part_2&entry=3311201882" rel="bookmark">Advanced Announcement Handling, part 2</a></h2><p class="timestamp">December 05, 2005 02:18:02 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>Today's subject is suspending subscriptions.</p><p>Sometimes it's handy to be able to turn off some subscriptions temporarily, to let a piece of code run without the usual reaction the announcements it broadcasts would trigger. What subscriptions exactly should be turned off depends on the circumstances. We may want to turn off all subscriptions for announcements of an object, or only for a particular kind of announcements. Or a subscriber might want to stop receiving announcements from a particular announcer, or only a subset of those announcements.</p><p>Announcements framework takes care of all of these with a single method. The method suspends a group of announcements previously selected using the selection messages we discussed in the previous post. By combining those methods with the single suspending method we have a wide choice of what gets suspended without the need for multiple versions of the suspend method.</p><p>If an object wants to temporarily disable all the current subscriptions to its announcements it does:</p><pre>	self subscriptionRegistry allSubscriptions 		suspendWhile: [...]</pre><p>or  particular kinds of announcement</p><pre>	(self subscriptionRegistry subscriptionsFor: Foo, Bar)		suspendWhile: [...]</pre><p>If self wants to temporarily stop receiving particular announcements from a particular object:</p><pre>	(anObject subscriptionRegistry subscriptionsOf: self for: Foo, Bar)		suspendWhile: [...]</pre><p>And there is always the catch-all option to get #allSubscriptions, filter the collection with #select: or #reject: using an arbitrary condition based on the subscriber and announcementClass, and then send #suspendWhile: to the filtered result.</p><p>Note that #suspendWhile: is sent directly to the result of the selection messages. Obviously, what those answer aren't ordinary collections.</p><p>All subscription selection messages of SubscriptionRegistry answer instances of AnnouncementSubscriptionCollection, a subclass of OrderedCollection. This isn't a hack, this is a conceptual feature. What the framework does is elevates the concept of a <em>group of subscriptions</em> to first-class status. Some of the operations we want to do--suspending subscriptions is one of those--are the easiest to think of as operations on groups of subscriptions, and we do just that. We represent groups of subscriptions as collections with extra behavior appropriate for susbcription collections.</p><p>Here are some other points worth noting about suspending subscriptions.</p><p>What you disable is always a collection of specific subscriptions rather than the ability of an object to broadcast announcements. For example, the following</p><pre>	anObject subscriptionRegistry allSubscriptions suspendWhile: [...]</pre><p>disables <em>all currently existing</em> subscriptions of an object, but if new subscriptions are added to the object while the block runs, those new subscriptions will be active and will deliver announcements broadcast inside the block.</p><p>The previous feature fits the overall subscription-centric spirit of the framework, already mentioned when we discussed unsubscribing. As you remember, subsclass relationship is considered only when delivering announcements--a subscription for Foo will also deliver any subclass of Foo--but to remove a subscription for Foo you need to specify Foo exactly.</p><p>The same principle applies to subscription selection. &quot;subscriptionsFor: Foo&quot; won't select subscriptions for superclasses of Foo, even though those subscriptions would deliver instances of Foo when asked. (It's not surprising that the principle is the same, since unsubscribing relies on the same selection methods). This means that if you have this arrangement of announcement classes</p><pre>	ValueChangeAnnouncement (abstract)		AboutToChangeValue		ChangingValue		ChangedValue</pre><p>and you want to suspend all three concrete classes, simply saying</p><pre>	(self subscriptionRegistry subscriptionsFor: ValueChangeAnnouncement)		supendWhile: [...]</pre><p>will not do, as this won't match any of the concrete subclasses. We already considered this feature applied to unsubscribing, and in that context it wasn't quite as bad. After all, a subscription is something you create explicitly when you set up your object structure. It isn't a big stretch to say that when you dismantle that structure you should match what you did to create it.</p><p>In the context of suspending, it's different. Even considering that we can list classes using an announcement set as &quot;subscriptionsFor: AboutToChangeValue, ChangingValue, ChangedValue&quot;, this code is fragile and will break if we add a new ValueChangeAnnouncement subclass.  It's also plain tedious.</p><p>This is a good use case for another way of creating announcement sets. The right solution is this:</p><pre>	(self subscriptionRegistry subscriptionsFor: ValueChangeAnnouncement andSubclasses)		suspendWhile: [...]</pre><p>#andSubclasses sent to an announcement class creates an announcement set with that class and all its subclasses, avoiding both the tedium and the need to keep the code in sync with the class structure.</p><p>Of course, #andSubclasses can be used in any context where announcement sets are allowed. For example, you can unsubscribe an object from all ValueChangeAnnouncement subclasses it previously subscribed to in one shot by saying</p><pre>	announcer unsubscribe: self from: ValueChangeAnnouncement andSubclasses</pre><p>Potentially, you could even use #andSubclasses when subscribing:</p><pre>	announcer when: Foo andSubsclasses do: [...]</pre><p>though in this case it's not only pointless but the result is likely unwanted, too. It's pointless because a subscription for Foo alone will deliver any subclass of Foo. It's unwanted because given this class structure:</p><pre>	Foo		Bar			Zork</pre><p>the code will create three subscriptions, one for each class. When the announcer later announces Zork, that same announcement will be delivered three times, once by each subscription. (Did I mention the framework was very subscription-centric?)</p><p>Suspend requests can be nested, and if  sets of suspended subscriptions of such nested requests overlap, the framework does the right thing. The right thing being that when you suspend a subscription for the duration of a block, and then inside that block suspend the same subscription again for the duration of an inner block, the subscription will not be reactivated after the inner block ends and will stay suspended until the end of the outer block.</p><p>To be continued...</p></div></div></div><a name="3311112620"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Advanced_Announcement_Handling,_part_1&entry=3311112620" rel="bookmark">Advanced Announcement Handling, part 1</a></h2><p class="timestamp">December 04, 2005 01:30:20 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>Announcements-related methods in Object implement only the bread-and-butter stuff--the basic subscribing, unsubscribing and announcing functions we've discussed so far. For anything advanced (read less frequently used)  you need to go to the object's subscription registry. One reason for this separation is to avoid (and in the distant future when triggerEvent is retired, reduce) Object's API bloat. triggerEvent has 44 methods in Object, plus about 15 #evaluate and #evaluateWithArguments: sprinkled around various classes. All the current version of Announcements has &quot;out in the open&quot; are 13 methods in Object.</p><p>The registry is the gateway to the rest of announcement API. This is another important point--it's a gateway rather than just the container of the rest of the API. In Announcements, the API is not simply split in two with the less frequently used stuff moved out of Object. The overall API design is different from triggerEvent in that it's focused on capturing the key concepts as objects you can work with, rather just adding a bunch of methods to Object for the functions the users are expected to need. This leads to a smaller API that goes much further.</p><p>If this still sounds vague at this point, I hope this and the following posts will illustrate what I mean. Also note that if you want to look at the actual code, for this and the following posts you'll need an up-to-date version (at least &quot;preview-13.0&quot;).</p><p>So, suppose we want to do some advanced stuff and we got a hold of an object's registry.</p><p>To start with the simplest thing, you can send messages #isEmpty and #notEmpty to it to find out if it has any subscriptions--in case you want to do something differently when it doesn't compared to when it does. (I don't know why you might want to do that, but Travis does, so ask him if you are curious).</p><p>Most important in the grand scheme of things are the four selection messages that select the currently existing subscriptions:</p><pre>	allSubscriptions	subscriptionsFor: announcementClassOrSet	subscriptionsOf: anObject	subscriptionsOf: anObject for: announcementClassOrSet</pre><p>These are fairly self-explanatory. &quot;Of:&quot; means we want subscriptions where the object we specify is the subscriber, &quot;for:&quot; means we want subscriptions for the specific announcement class or class set, and both mean we combine both of those conditions.</p><p>Once we've found the subscriptions we are interested in, we can do a number of things with them. One is we can unsubscribe from them. As you remember, Object's #unsubscribe: and #unsubscribe:from: handle the two most common cases: you can say</p><pre>	anObject unsubscribe: self</pre><p>or</p><pre>	anObject unsubscribe: self from: Foo</pre><p>Somewhere down below these actually do</p><pre>	registry removeSubscriptions:		(registry subscriptionsOf: self)</pre><p>and</p><pre>	registry removeSubscriptions:		(registry subscriptionsOf: self for: Foo)</pre><p>Registry API enables less considerate unsubscribing options, those that affect multiple subscribers at once and for that reason are not included in the basic API in Object:</p><pre>	registry removeSubscriptions: registry allSubscriptions</pre><p>zaps all subscriptions no matter who subscribed and for what announcements. (Just trashing the whole registry with &quot;anObject subscriptionRegistry: nil&quot; might work but isn't nice, because as we'll see in future posts, the registry might not be an object you can just throw away. Incidentally, #subscriptionRegistry: is a private method).</p><pre>	registry removeSubscriptions: 		(registry subscriptionsFor: Foo)</pre><p>removes all subscriptions for the announcement class Foo, no matter the subscriber.</p><p>So far this might not have looked very impressive. After all, one subscription removal method combinable with four selection methods sounds nice in theory but in practice, why not just make the registry understand #removeAllSubscriptions, #removeSubscriptionsFor: and all those other cases?</p><p>It's because elevating subscription selection to the level of public API (and making subscriptions real objects in the first place) gives us tremendous flexibility, nearly for free. Even before we get to other advanced things in followup posts, the simple fact that subscriptions are objects and we can work with their collections allows the framework user to &quot;just do&quot; things triggerEvent had to provide for specifically. Or not provide at all.</p><p>For example, in triggerEvent there is a method Object&gt;&gt;hasActionForEvent: to test, in Announcements speak, whether an object has any subscriptions for an event. Why, finding this out with Announcements is as simple as</p><pre>	(registry subscriptionsFor: Foo) isEmpty</pre><p>Or just as easily we can do</p><pre>	(registry subscriptionsOf: anObject) isEmpty</pre><p>to check whether a particular object is a subscriber--something triggerEvent doesn't do.</p><p>Or to find out what announcement classes are in demand at the moment:</p><pre>	(registry allSubscriptions		collect: [:each | each announcementClass]) asSet</pre><p>Or, similarly, to get a collection of all the current subscribers:</p><pre>	(registry allSubscriptions		collect: [:each | each subscriber]) asSet</pre><p>Or we can remove all subscriptions whose subscribers we don't like for whatever reason:</p><pre>	registry removeSubscriptions:		(registry allSubscriptions select: 			[:each | self dislikes: each subscriber])</pre><p>or the same thing, but like this:</p><pre>	registry allSubscriptions do:		[:each |		(self dislikes: each subscriber) ifTrue:			[registry removeSubscription: each]]</pre><p>I hope this gives a a taste of &quot;capturing the key concepts as objects you can work with, rather just adding a bunch of methods to Object for the functions the users are expected to need&quot;.</p><p>To be continued.</p></div></div></div><a name="3310908698"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Announcements:_Subscription_Management&entry=3310908698" rel="bookmark">Announcements: Subscription Management</a></h2><p class="timestamp">December 01, 2005 16:51:38 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>How exactly subscriptions are stored is typically not important for the framework end user. However, we'll look at the overall picture because some bits of it are good to know for the more advanced scenarios.</p><p>Subscriptions to announcements are managed by instances of two classes, SubscriptionRegistry and AnnouncementSubscription. A SubscriptionRegistry is associated with an announcer object, one registry per announcer. A registry uses instances of AnnouncementSubscription to record individual subscriptions for the announcements of that object.</p><p>A registry for an object is accessible by sending the #subscriptionRegistry message to the object. This will always answer a SubscriptionRegistry, creating and associating one with the object if it doesn't exist yet. A variant of that message, #subscriptionRegistryOrNil, answers a registry only if one is already set up, or nil if it isn't.</p><p>The primary reason SubscriptionRegistry is publicly accessible like this, even though it works entirely behind the scenes in basic announcements-related tasks, is that it provides second-tier subscription management protocol. We'll look at that protocol in the next post.</p><p>Any object can be an announcer, so the implementation in Object uses an external EphemeronDictionary which maps objects (by identity) to their registries, similar to DependentsFields and EventHandlers of change/update and triggerEvent frameworks. One difference is that the dictionary is kept in a shared variable Registries of the SubscriptionRegistry class rather than in a shared variable of Object.</p><p>If a class wants to store its registry locally, in an instance variable similar to 'depedents' in Model or 'handlers' in EventManager, it should as a minimum implement two methods: #subscriptionRegistry: to store the argument in that variable and #subscriptionRegistryOrNil to return the value of the variable. Ideally, it should also implement #postCopy to nil out the registry in the copy (with the default mechanism objects are mapped to their registries based on identity, so a copy automatically loses the original's registry).</p><p>In future, the framework may provide Announcer class as a ready-made superclass for those classes that need such local subscription storage. There is no such class at the moment because Pollock, the first planned major client, doesn't need it. In Pollock, local handler storage is implemented from scratch in those superclasses that need it. Apparently, there are often more important reasons for choosing a superclass than inheriting two or three trivial methods.</p></div></div></div><a name="3310653956"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Announcements:_Announcing_and_Vetoing&entry=3310653956" rel="bookmark">Announcements: Announcing and Vetoing</a></h2><p class="timestamp">November 28, 2005 18:05:56 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>Announcing is even simpler than subscribing and unsubscribing. The one message that does all the work is #announce:. The message is sent to the announcer-to-be, and the announcement is passed as the argument.</p><p>The argument can be either an announcement instance or a class. If it is a class, the actual instance to announce is automatically created behind the scenes, so you can do either</p><pre>	self announce: StuffHappened</pre><p>or</p><pre>	self announce: (StuffHappened new explanation: 'foo')</pre><p>The way this works is the first thing #announce: does is it sends #asAnnouncement message to the argument. The result of the message is used as the actual announcement to announce. Announcement instances answer <em>self</em> to #asAnnouncement, and Announcement classes answer <em>self new</em>. This also means that in principle any object that properly implements #asAnnouncement can be used as the argument of #announce: (though as an independent feature this doesn't seem to be obviously useful).</p><p>As an extended example, and to introduce announcement vetoing, here is a complete implementation of ObservedValue&gt;&gt;value: method updated to use announcements.</p><pre>value: anObject	| changedAnnouncement |	self announce: (AboutToChangeValue from: value to: anObject)		ifVetoed: [^self].	self announce: (ChangingValue from: value to: anObject).	changedAnnouncement := ChangedValue from: value to: anObject.	value := anObject.	self announce: changedAnnouncement</pre><p>One moderately interesting feature here is how we create ChangedValue in advance to preserve the value we are about to overwrite. But the really interesting one is the #announce:ifVetoed: message used to signal AboutToChangeValue.</p><p>As we discussed a couple of posts ago, AboutToChangeValue is the first phase of a three-phase event notification. With it, the announcer notifies the interested parties of its intent to do something. If one of the subscribers voices an objection (&quot;vetoes&quot; the announcement), the announcer is expected to abort the intended action.</p><p>The #announce:ifVetoed: message is for implementing this vetoing behavior on the announcer side. The first argument is the same as in the #announce: message. The second one is a block evaluated if the announcement has been vetoed by at least one subscriber. In our example, we simply leave the #value: method if that happens.</p><p>On the subscriber side, an announcement is vetoed by sending the #veto message to it. For example, here is a subscriber that ensures an ObservedValue rejects anything but a symbol.</p><pre>	aValue		when: AboutToChangeValue		do: [:change |			change newValue isSymbol ifFalse: [change veto]]</pre><p>This sending of #veto to <em>change</em> (an instance of AboutToChangeValue) eventually makes the ifVetoed: block in the implementation of #value: to run, aborting the change.</p><p>It's interesting to compare vetoing in Announcements and in triggerEvent.</p><p>In triggerEvent, since there was nothing to send anything like a #veto message to, handler code vetoes an event by raising a VetoAction exception. Instead of &quot;change veto&quot; above, the code would read &quot;VetoAction raise&quot;. The signaler would set up a handler for VetoAction to respond to it, something like</p><pre>	[self triggerEvent: #aboutToChange]		on: VetoAction		do: [:ex | ...]</pre><p>The difference in Announcements is not only that the guts are hidden inside a clean protocol of #veto and #announce:ifVetoed:. In addition, Announcements don't rely on exceptions for communication. Because an announcement is a tangible object, vetoing simply sets a flag in the announcement itself. The announcer then checks if the flag is set. In fact, #announce:ifVetoed: is only a convenience message and the #value: method above could instead be doing this:</p><pre>	| intent |	intent := AboutToChangeValue from: value to: anObject.	self announce: intent.	intent isVetoed ifTrue: [^self].	...</pre><p>The exact behavior of this code (which is how #announce:ifVetoed: is implemented) is different from VetoAction in that raising VetoAction effectively cancels delivery of the event, while vetoing an announcement doesn't. In other words, if the first subscriber vetoes an announcement, the announcement is still delivered to all the other subscribers. In triggerEvent, when the first event handler raises a VetoAction, none of the other handlers for the same event are invoked. The new behavior is a deliberate choice, to give vetoable announcement handlers as a whole a more deterministic behavior.</p><p>This implementation of vetoing illustrates how announcements, by virtue of being objects, make it easier for the announcer and subscribers to communicate. This communication can be even more involved. As an example, here is an implementation of voting alternative to vetoing, so that the announcer aborts an action when <em>the majority</em> of subscribers, rather than just one, object. One way to implement this is an Announcement subclass Vote, with an instance variable &quot;bias&quot; initialized to 0. Vote would have methods</p><pre>voteFor	bias := bias + 1voteAgainst	bias := bias - 1isApproved	^bias &gt; 0</pre><p>Subscribers would listen to Vote (or perhaps its specific subclass) and send either #voteFor or #voteAgainst to it. The announcer would run the poll as</p><pre>	| vote |	vote := KickUserVote new.	self announce: vote.	vote isApproved ifTrue: [...]</pre></div></div></div><a name="3310204813"></a><div class="post"><p class="category"><a href="blogView?searchCategory=Announcements Framework">Announcements Framework</a></p><h2><a href="blogView?showComments=true&printTitle=Announcements:_Unsubscribing&entry=3310204813" rel="bookmark">Announcements: Unsubscribing</a></h2><p class="timestamp">November 23, 2005 13:20:13 EST</p><div class="postbody"><div xmlns="http://www.w3.org/1999/xhtml"><p>Essentially, all there is to unsubscribing are two messages: #unsubscribe: and #unsubscribe:from:. For example, if we have these subscriptions:</p><pre>	nameHolder when: ChangingValue send: #changingName: to: self.	nameHolder when: ChangedValue send: #changedName: to: self.</pre><p>we can stop receiving #changingName: when ChangingValue is announced by executing</p><pre>	nameHolder unsubscribe: self from: ChangingValue</pre><p>To unsubscribe from more than one announcement class at a time, we can use a list of announcement classes, just like when subscribing:</p><pre>	nameHolder unsubscribe: self from: ChangingValue, ChangedValue</pre><p>We can also request nameHolder to bulk-unsubscribe us from everything we are currently subscribed to with a single</p><pre>	nameHolder unsubscribe: self</pre><p>That's the general idea, though there are two points worth clarifying. </p><p>One is what precisely is considered the subscriber (what should we pass as the &quot;unsubscribe:&quot; argument). With message-based subscriptions it's clear enough--it is the receiver of the notification message (<em>self</em> in our examples). Things get more interesting with block-based subscriptions.</p><p>The only thing we can reasonably consider a subscriber in that case is, of course, the block itself. In fact, this is the only thing we can consider, period, because nothing else is known to the announcer when we establish a block-based subscription. So in order to unsubscribe a block, we'd need to hold onto it and pass it to the #unsubscribe: request:</p><pre>	spy := [:announcement | Transcript cr; print: announcement].	nameHolder when: Announcement do: spy.	...	nameHolder unsubscribe: spy</pre><p>This is reasonable in this particular case, however it doesn't work that well with one very common pattern of block-based subscriptions. Blocks are often used as simple intermediary &quot;forwarding thunks&quot; to invoke a method with some additional information. For example, in an initialization method of our application we could have something like (this is goofy, but bear with me):</p><pre>  authorization := self getAuthorization.  nameHolder when: ChangingValue do: [self prepareNameChangeWith: authorization].  nameHolder when: ChangedValue do: [self processNameChangeWith: authorization].</pre><p>Unsubscribing these is pretty tedious. We need to break this clean and tight code to store the two blocks in instance variables set up just for that purpose, and then unsubscribe the blocks individually when we want to break the dependency on nameHolder.</p><p>It would be much better if we could somehow indicate that the blocks act on behalf of <em>self</em>, so that <em>self</em> rather than the blocks would be considered the actual subscriber and used as the argument of the #unsubscribe: message.</p><p>This is where the third subscription message I mentioned in the previous post comes into play. The message is #when:do:for:. It works just like #when:do:, except it accepts a third argument specifying the object on whose behalf the block is subscribed. For such subscriptions, that object rather than the block is considered to be the subscriber. So if we rewrite our example as:</p><pre>  authorization := self getAuthorization.  nameHolder	when: ChangingValue	do: [self prepareNameChangeWith: authorization] 	for: self.  nameHolder	when: ChangedValue	do: [self processNameChangeWith: authorization]	for: self.</pre><p>We can later remove those two subscriptions with a single</p><pre>	nameHolder unsubscribe: self</pre><p>To sum up, the framework considers the following to be the subscriber:</p><ul><li>For subscriptions established using #when:send:to: it's the &quot;to:&quot; argument.</li><li>For subscriptions established using #when:do: it's the &quot;do:&quot; argument.</li><li>For subscriptions established using #when:do:for: it's the &quot;for:&quot; argument.</li></ul><p>Another point is the exact interpretation of the announcement class passed as the second argument of #unsubscribe:from:. Suppose we have a subscription (two, in fact) established as</p><pre>	aValue when: ChangingValue, ChangedValue send: #foo to: self</pre><p>if later we send</p><pre>	aValue unsubscribe: self from: Announcement</pre><p>what should happen?</p><p>One possible approach is that it should remove both subscriptions, since both ChangingValue and ChangedValue are subclasses of Announcement. In light of how a subscription for an announcement class also receives all the subclasses of the class, this sounds reasonable. This approach could be called &quot;announcement-centric&quot; since it considers unsubscribing as an operation that reduces the set of announcements the subscriber receives. This gets interesting when an unsubscribe request is more specific than the prior subscription. Suppose that initially we subscribe to Announcement, and then send a request to unsubscribe from ChangedValue. The result of that would have to be a subscription for all announcements other than ChangedValue (and its subclasses, if any). This is implementable, of course, but starts to sound pretty involved and costly.</p><p>The other possibility is to say that an unsubscribe request should reference exactly the same announcement class as the one we subscribed to. This is the subscription-centric view--we think of unsubscribing as removing the subscription identified by the announcement class used to establish it. This is also reasonable, and has the advantage of simplicity. With this policy, the unsubscribe request above would do nothing since we never created a subscription for Announcement.</p><p>This second view is how the framework works. The first statement in the above example is treated as if it establishes two subscriptions, one for ChangingValue, the other for ChangedValue. In order to remove them, we need to unsubscribe from those two exact classes. We can do that either as two separate requests:</p><pre>	aValue		unsubscribe: self from: ChangingValue;		unsubscribe: self from: ChangedValue;</pre><p>Or as a single request, but still explicitly listing both classes:</p><pre>	aValue unsubscribe: self from: ChangingValue, ChangedValue</pre><p>Note that if we send only</p><pre>	aValue unsubscribe: self from: ChangingValue</pre><p>this will remove a subscription for that class, but subscription for ChangedValue will remain, even though both were established with one #when:send:to: message. This again is in line with the overall idea of each announcement class mentioned in a #when:... message considered to be an individual subscription.</p><p>In the next installment (most likely after Thanksgiving) we'll finally get to broadcasting announcements.</p></div></div></div><p><table width="30%"><tr><td><a href="blogView?searchCategory=Announcements Framework&index=11">Next</a></td><td>(13total)</td></tr></table></p>
			</div> <!-- #posts -->
			
			
		</div> <!-- #content -->
	
		<!--		THE MENU SECTION		-->
	
		<div id="menu">
		<div class="watermark"></div>	
	
			<h2>Posts</h2>
			<ul>
				<li><a href="blogView">Recent</a></li>
				<li><span>January 2008</span></li><li><span>December 2007</span></li><li><span>November 2007</span></li><li><span>October 2007</span></li>
				<li><a href="blogArchive">Archives</a></li>
				<li><a class="feedbutton" href="http://www.cincomsmalltalk.com/rssBlog/vbykov-rss.xml" target="_new" title="Subscribe using your RSS reader">RSS</a></li>
				<li><hr />
				<li><a href="http://technorati.com/faves/?blogView">add to technorati</a></li>
			</ul>
		
			

			<h2>Links</h2>
			<ul>
				<li><a href="http://www.whysmalltalk.com/">WhySmalltalk.com</a></li>
			</ul>

			<h2>Categories</h2>
			<ul>
				<select onChange="if (this.selectedIndex > 0) { window.location =this[this.selectedIndex].value }"><option>Select...</option><option value="blogView?searchCategory=Announcements Framework">Announcements Fram...</option><option value="blogView?searchCategory=Bits of History">Bits of History</option><option value="blogView?searchCategory=blog test">blog test</option><option value="blogView?searchCategory=Building UIs">Building UIs</option><option value="blogView?searchCategory=CSS">CSS</option><option value="blogView?searchCategory=Did You Know You Can...">Did You Know You C...</option><option value="blogView?searchCategory=Extended Reply">Extended Reply</option><option value="blogView?searchCategory=general">general</option><option value="blogView?searchCategory=Interfaces">Interfaces</option><option value="blogView?searchCategory=Just Smalltalk">Just Smalltalk</option><option value="blogView?searchCategory=Mac">Mac</option><option value="blogView?searchCategory=sightseeing">sightseeing</option><option value="blogView?searchCategory=Splash">Splash</option><option value="blogView?searchCategory=VisualWorks">VisualWorks</option></select>
			</ul>
		
			<h2>Subscribe</h2>
			<ul>
		
				
				
				
				
				<li><a class="feedbutton" href="http://www.cincomsmalltalk.com/rssBlog/vbykov-rss.xml" target="_new" title="Subscribe using your RSS reader">RSS</a></li>
				<li><a href="/rssBlog/vbykov-rssBlogCommentView.xml" target="_new" title="Use this link in your RSS reader (Comments)." >RSS Comments</a></li>
				<li><a href="http://localhost:8666/btf?rss=http://www.cincomsmalltalk.com/rssBlog/vbykov-rss.xml" title="Add this feed to a running copy of BottomFeeder" >BottomFeeder</a></li>
				<li><a href="/rssBlog/vbykov-atom02.xml" target="_new">Atom</a></li>
				<li><a href="/rssBlog/vbykov-atom02Comments.xml" target="_new">Atom Comments</a></li>
				<li><a href="http://www.bloglines.com/sub/http://www.cincomsmalltalk.com/rssBlog/vbykov-rss.xml" target="_new" title="Subscribe in blogLines">BlogLines</a></li>
				<li><a href="http://www.cincomsmalltalk.com/BottomFeeder" target="_new" title="Get The BottomFeeder RSS Viewer">Get BottomFeeder</a></li>
	</ul>
	<h2>Category Syndication Links</h2>
	<ul>
	<select onChange="if (this.selectedIndex > 0) { window.location =this[this.selectedIndex].value }"><option>Select...</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_AnnouncementsFramework.xml">Announcements Fram...</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_BitsofHistory.xml">Bits of History</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_blogtest.xml">blog test</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_BuildingUIs.xml">Building UIs</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_CSS.xml">CSS</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_DidYouKnowYouCan....xml">Did You Know You C...</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_ExtendedReply.xml">Extended Reply</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_general.xml">general</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_Interfaces.xml">Interfaces</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_JustSmalltalk.xml">Just Smalltalk</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_Mac.xml">Mac</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_sightseeing.xml">sightseeing</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_Splash.xml">Splash</option><option value="http://www.cincomsmalltalk.com/rssBlog/vbykov_VisualWorks.xml">VisualWorks</option></select>
			</ul>
			
			<h2>Search</h2>
			<form name="blogViewForm" method="post" action="servlet/SearchServlet">
			<p><label for="searchID" accesskey="4">Archives:</label></p>
			<p><input type="checkbox" checked name="searchTitle" value="searchTitle" />Title
			     <input type="checkbox" checked name="searchBodies" value="searchBodies" />Body</p>
			<p><input type="text" name="searchText" size="17" maxlength="80" id="searchID" />
			     <input type="submit" value="Go" name="search_button" /></p>
			</form>
		
			<h2>Feedster</h2>
			<form name="feedsterForm" method="post" action="http://www.feedster.com/search.php">
			<p><label for="searchF" accesskey="5"><a href="http://www.feedster.com">Feedster:</a></label></p>
			<input type="hidden" value="UTF-8" name="ie" />
			<p><input type="text" name="q"  size="17" maxlength="80" id="searchF" />
			     <input type="submit" value="Go" name="btnG" /></p>
			</form>
		
			<img src="/images/poweredBySmalltalk.png" />
		
	      </div> <!-- menu -->

	
      </div> <!-- #main -->

    </div> <!-- container -->

  </body>

</html>
<!-- Built with Cincom Smalltalk. http://www.cincomsmalltalk.com -->
