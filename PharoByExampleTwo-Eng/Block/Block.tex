% $Author: oscar $
% $Date: 2009-08-16 16:37:09 +0200 (Sun, 16 Aug 2009) $
% $Revision: 28477 $

% HISTORY:
% 2008-01-19 - Stef started
% 2008-12-26 - Jannik Laval added text
% 2011-20-05 - Jean baptiste Arnaud add some text (Lexical closure)
% 2011-07-01 - Jean baptiste Arnaud add some test (Storing a block)
% 2011-08-09 - Stef doing another pass
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
% todo for stef explaining blockClosure environment representation + explaining the trick with the bytecodes
% 2012-01-27 - Integrated Ben Coman feedback
% 2012-07-25 - Stef doing another pass to restart working on it.

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Blocks: a Detailed Analysis}\chalabel{blocks}


Blocks (lexical closures) are a powerful and essential feature of Smalltalk. Without them it
would be difficult to have such a small and compact syntax. The use of blocks in Smalltalk
is key to get conditionals and loops as library messages and not hardcoded in the language syntax. This is why we can say that
blocks work extremely well with the message passing syntax of Smalltalk.

In addition blocks are  effective to improve the readability, reusability and efficiency of code.
However the dynamic runtime semantics of Smalltalk is often not well documented. Blocks in the presence of return statements behave like an escaping mechanism and while this can lead to ugly code when used to its extreme, it is important to understand it. In the Pharo by Example book, we presented how to write and use blocks. On the contrary, this chapter focuses on deep aspects and their runtime behavior.

In this chapter we present some basic block behaviors such as the notion of static environments defined at block compile-time. To understand blocks, we describe how  a program executes.

% ============================================================================
\section{Basics}
% ============================================================================

What is a block? Historically, a block is a lambda expression, also called an anonymous function. A block is a piece of code whose evaluation is frozen and kicked in using messages. Blocks are defined by square brackets.

If you execute and print the result of the following code, you will not get 3 but a block.

\begin{code}[Block definition]{Block Definition}
[ 1 + 2 ] --> [ 1 + 2 ]
\end{code}

 A block is evaluated by sending the \mthind{BlockClosure}{value} message to it. More precisely blocks can be evaluated using \ct{value} (when no argument is mandatory), \ct{value:} (when the block requires one argument), \ct{value:value:} (for two arguments), \ct{value:value:value:} (for three) and \ct{valueWithArguments: anArray} (for more arguments). These messages are the basic and historical API for block evaluation. They were presented in the Pharo by Example book.

\begin{code}[Block definition]{Block Evaluation}
[ 1 + 2 ] value --> 3

[ :x | x + 2 ] value: 5 --> 7
\end{code}

\subsection{Some handy extensions}

Beyond the \ct{value} messages, Pharo includes some handy messages
such as \ct{cull:} and friends to support the evaluation of blocks even
in the presence of more values than necessary. \ct{cull:} will raise
an error if the receiver requires more arguments than provided. The
\ct{valueWithPossibleArgs:} message is similar to \ct{cull:} but takes
an array of parameters to pass to a block as argument. If the block
requires more arguments than provided, \ct{valueWithPossibleArgs:}
will fill them with \ct{nil}.

\begin{code}{Cull: examples}
[ 1 + 2 ] cull: 5 --> 3
[ 1 + 2 ] cull: 5 cull: 6 --> 3
[ :x | 2 + x ] cull: 5 --> 7
[ :x | 2 + x ] cull: 5 cull: 3 --> 7
[ :x :y | 1 + x + y ] cull: 5 cull: 2 --> 8
[ :x :y | 1 + x + y ] cull: 5 ~-> error because the block needs 2 arguments.
[ :x :y | 1 + x + y ] valueWithPossibleArgs: #(5)
                      ~-> error because 'y' is nil and '+' does not accept nil as a parameter.
\end{code}


\paragraph{Other messages.}

Some messages are useful to profile evaluation (more information in the Profiling Chapter~\ref{cha:Profiler}):

\begin{description}
\item{\textsf{bench}}. Return how many times the receiver block can get evaluated in 5 seconds.

\item{\textsf{durationToRun}}. Answer the duration (instance of Duration) taken to evaluate the receiver block.

\item{\textsf{timeToRun}}. Answer the number of milliseconds taken to evaluate this block.
\end{description}


Some messages are related to error handling (as explained in the Exception Chapter~\ref{cha:exception}).

\begin{description}
\item{\textsf{ensure: terminationBlock}}. Evaluate the termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes.
\item{\textsf{ifCurtailed: onErrorBlock}}. Evaluate the receiver, and, if the evaluation does not complete, evaluate the error block. If evaluation of the receiver finishes normally, the error block is not evaluated.

\item{\textsf{on: exception do: catchBlock}}. Evaluate the receiver. If an exception \textsf{exception} is raised, evaluate the catch block.

\item{\textsf{on: exception fork: catchBlock}}. Evaluate the receiver. If an exception \textsf{exception} is raised, fork a new process, which will handle the error. The original process will continue running as if the receiver evaluation finished and answered nil,\ie  an expression like: \textsf{[ self error: 'some error'] on: Error fork: [:ex |  123 ]} will always answer nil to the original process. The context stack, starting from the context which sent this message to the receiver and up to the top of the stack will be transferred to the forked process, with the catch block on top. Eventually, the catch block will be evaluated in the forked process.
\end{description}


Some messages are related to process scheduling. We list the most important ones. Since this Chapter is not about concurrent programming in Pharo we will not go deep into them.

\begin{description}
\item{\textsf{fork}}. Create and schedule a Process evaluating the receiver.

\item{\textsf{forkAt: aPriority}}. Create and schedule a Process evaluating the receiver at the given priority. Answer the newly created process.

\item{\textsf{newProcess}}. Answer a Process evaluating the receiver. The process is not scheduled.
\end{description}


% ============================================================================
\section{Variables and Blocks}
% ============================================================================
A block can have its own temporary variables. Such variables are initialized during each block evaluation and are local to the block. Now the question we want to make clear is what is happening when a block refers to other (non-local) variables. Later, for the curious, we will present how local variables are implemented and stored.

In Pharo, private variables (such as self, instance variables, method temporaries and arguments) are lexically scoped. These variables are bound (get a value associated to them) in \emph{the context (a stack frame)} in which the block that contains them is \emph{defined}, rather than the context in which the block is evaluated.  Traditionally, the context in which a block is defined is named the \emph{block home context}.

In essence, a context (called stack frame in other languages) represents information about the current evaluation step such as the context from which the current one is executed, the next byte code to be executed, and the value of the temporary variables. A context is an activation record representing a Smalltalk execution stack element. This is important and we will come back later to this concept.

\subsection{Some little experiments}
Let's experiment a bit to understand how variables are bound in a block. Define a class named \ct{Bexp} (for BlockExperiment):

\begin{code}{}
Object subclass: #Bexp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BlockExperiment'
\end{code}


\paragraph{Experiment 1: Variable lookup.} A variable is looked up in the block definition context.



\begin{code}{}
Bexp>>evaluateBlock: aBlock
	| t |
	t := nil.
	aBlock value

Bexp>>setVariableAndDefineBlock
	| t |
	t := 42.
	self evaluateBlock: [ t traceCr ]
\end{code}

Executing the \ct{Bexp new setVariableAndDefineBlock} expression prints 42 in the Transcript (message \ct{traceCr}). The value of the temporary variable \ct{t} defined in the \ct{setVariableAndDefineBlock} method is the one used rather than the one of \ct{t} defined inside \ct{evaluateBlock:} even if the block is evaluated during the execution of the later method.

The variable \ct{t} is not looked up in the context of the  block-evaluating method \ct{evaluateBlock:} but in the context of the block-defining method \ct{setVariableAndDefineBlock}.

Let's look at it in detail. Figure~\ref{fig:variable} shows the execution of the expression \ct{Bexp new setVariableAndDefineBlock}. 

\begin{itemize}
\item During the execution of method \ct{setVariableAndDefineBlock}, a variable \ct{t} is defined and it is assigned 42. Then a block is created and this block refers to the method activation context - which holds temporary variables (Step 1). 

\item The method \ct{evaluateBlock:} defines its own local variable \ct{t} with the same name than the one in the block. However, this is not this variable that is used when the block is evaluated. While executing the method \ct{evaluateBlock:} the block is evaluated (step 2), during the execution of the expression \ct{t traceCr} the non-local variable \ct{t} is looked up in the home context of the block \ie the method context that created the block and not the context of the currently executed method.
\end{itemize}

\begin{figure}[!h]
\begin{center}\includegraphics[width=\textwidth]{variable}
\caption{ non-local variables are looked in the method activation context where the block was created and not evaluated.\label{fig:variable} \dc{must change this figure to reflect the real method names.}\dc{logCr -> traceCr}}
\end{center}
\end{figure}


\paragraph{Experiment 2: Changing a variable value.} The method \ct{setVariableAndDefineBlock2} shows that a non-local variable value can be changed during the evaluation of a block. Executing \ct{Bexp new setVariableAndDefineBlock2} prints 33, since 33 is the last value of the variable \ct{t}.


\begin{code}{}
Bexp>>setVariableAndDefineBlock2
	| t |
	t := 42.
	self evaluateBlock: [ t := 33. t traceCr ]
\end{code}

\paragraph{Experiment 3: Accessing a shared non-local variable.}
Two blocks can share a non-local variable and they can modify the value of this variable at different moments. To see this, let us define a new method \ct{setVariableAndDefineBlock3} as follows:

\begin{code}{}
Bexp>>setVariableAndDefineBlock3
	| t |
	t := 42.
	self evaluateBlock: [ t traceCr. t := 33. t traceCr ].
	self evaluateBlock: [ t traceCr. t := 66. t traceCr ].
	self evaluateBlock: [ t traceCr ]
\end{code}

\ct{Bexp new setVariableAndDefineBlock3} will print 42, 33, 33, 66 and 66.
Here the two blocks \ct{[ t := 33. t traceCr ]} and \ct{[ t := 66. t traceCr ]} access the same variable \ct{t} and can modify it. During the first execution of the method \ct{evaluateBlock:} its current value \ct{42} is printed, then the value is changed and printed. A similar situation occurs with the second call. This example shows that blocks share the context where variables are stored.

\paragraph{Experiment 4: Variable lookup is done at execution time.}\
The following example shows that the value of the variable is looked up at runtime.
First add the instance variable \ct{block} to the class \ct{Bexp}.

\begin{code}{}
Object subclass: #Bexp
	instanceVariableNames: 'block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BlockExperiment'
\end{code}

Here the initial value of the variable \ct{t} is 42. The block is created and stored into the instance variable \ct{block} but the value to \ct{t} is changed to 69 before the block is evaluated. And this is the last value (69) that is effectively printed because it is looked up at execution-time. Executing \ct{Bexp new setVariableAndDefineBlock4} prints 69.



\begin{code}{}
Bexp>>setVariableAndDefineBlock4
	| t |
	t := 42.
	block := [ t traceCr: t ].
	t := 69.
	self evaluateBlock: block
\end{code}

\ct{Bexp new setVariableAndDefineBlock4} prints 69.

\paragraph{Experiment 5: For method arguments.}\
Naturally we can expect that method arguments are bound in the context of the defining method. Let's illustrate this point now. Define the following methods.

\begin{code}{}
Bexp>>testArg
	self testArg: 'foo'.

Bexp>>testArg: arg
	block := [arg crLog].
	self evaluateBlockAndIgnoreArgument: 'zork'.

Bexp>>evaluateBlockAndIgnoreArgument: arg
	block value.
\end{code}

Now executing \ct{Bexp new testArg: 'foo'} prints \ct{'foo'} even if in the method \ct{evaluateBlockAndIgnoreArgument:} the temporary \ct{arg} is redefined.

\paragraph{Experiment 6: self binding.}
For binding of self, we simply define a new class and a couple of methods.
Add the instance variable \ct{x} to the class \ct{Bexp} and define the \ct{initialize} method as follows:

\begin{code}{}
Object subclass: #Bexp
	instanceVariableNames: 'block x'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BlockExperiment'

Bexp>>initialize
    super initialize.
	x := 123.
\end{code}

Define another class named \ct{Bexp2}.

\begin{code}{}
Object subclass: #Bexp2
	instanceVariableNames: 'x'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BlockExperiment'

Bexp2>>initialize
	super initialize.
	x := 69.

Bexp2>>evaluateBlock: aBlock
	aBlock value
\end{code}

Then define the methods that will invoke  methods defined in \ct{Bexp2}.
\begin{code}{}
Bexp>>evaluateBlock: aBlock
	Bexp2 new evaluateBlock: aBlock

Bexp>>evaluateBlock
	self evaluateBlock: [self crTrace ; traceCr: x]
\end{code}

Now when we execute \ct{Bexp new evaluateBlock}, we get \ct{a Bexp123} printed in the Transcript, showing that a block captures self too, since an instance of Bexp2 evaluated the block but the printed object (self) is the original Bexp instance that was accessible at the block creation time.


% ============================================================================
\section{Variables can outlive their defining method}
% ============================================================================

Non block local variables referred to by a block continue to be accessible and shared with other expressions even if the method execution terminated. We say that variables outlive the method execution that defined them.
Let us take some examples.

\paragraph{Method-Block Sharing.} Define the following method \ct{foo} which defines a temporary variable \ct{a}.

\begin{code}{}
Bexp>>foo
	| a |
	[ a := 0 ] value.
	^ a
\end{code}

When we execute \ct{Bexp new foo}, we get 0 and not nil.
Here what you see is that the value is shared between the method body and the block. Inside the method body we can access the variable whose value was set by the block evaluation.
Both the method  and block bodies access the same temporary variable \ct{a}.

Now define the method \ct{twoBlockArray} as follows:

\begin{code}{}
Bexp>>twoBlockArray
	| a |
	a := 0.
	^ {[ a := 2] . [a]}
\end{code}

The method \ct{twoBlockArray} defines a temporary variable \ct{a}. It sets the value of \ct{a}
to zero and returns an array whose first element is a block setting the value of \ct{a} to 2 and second element is a block just returning the value of the temporary variable \ct{a}.

Now we store the array returned by \ct{twoBlockArray} and evaluate the blocks stored in the array. This is what the following code snippet is doing.

\begin{code}{}
| res |
res := Bexp new twoBlockArray.
res second value. --> 0
res first value.
res second value. --> 2
\end{code}

You can also define the code as follows and open a transcript to see the results.

\begin{code}{}
| res |
res := Bexp new twoBlockArray.
res second value traceCr.
res first value.
res second value traceCr.
\end{code}

Let us step back and look at an important point.
In the previous code snippet when the expressions \ct{res second value} and \ct{res first value} are executed, the method \ct{twoBlockArray} has already finished its execution - as such it is not on the execution stack anymore.  Still the temporary variable \ct{a} can be accessed and set to a new value. This experiment shows that the variables referred to by a block may live longer than the method which created the block that refers to them. We say that the variables outlive their defining method execution.

 You can see from this example that while temporary variables are somehow stored in an activation context, the implementation is a bit more subtle than that. The block implementation needs to keep referenced variables in a structure that is not in the execution stack but lives on the heap. We will go in more details in a following section.


% ============================================================================
\section{Returning from inside a block}
% ============================================================================
In this section we explain why it is  not a good idea to have return statements inside a block (such as \ct{[^ 33]}) that you pass or store into instance variables. A block with an explicit return statement is called a non-local returning block. Let us start illustrating some basic points first.

\subsection{Basics on return}

By default the returned value of a method is the receiver of the message \ie self.
A return expression (the expression starting with the character \ct{^}) allows one to return a different value than the receiver of the message. In addition, the execution of a return statement exits the currently executed method and returns to its caller. This ignores the expressions following the return statement.

Define the following method. Executing \ct{Bexp new testExplicitReturn}  prints 'one' and 'two' but it will not print \ct{not printed}, since the method \ct{testExplicitReturn} will have returned before.

\begin{code}{}
Bexp>>testExplicitReturn
	self traceCr: 'one'.
	0 isZero ifTrue: [ self traceCr: 'two'. ^ self].
	self traceCr: 'not printed'
\end{code}


%Finally, in Smalltalk, \ct{^} should be the last statement of a block body. You should get a compile error if you type and compile the following expression.
%
%\begin{code}{}
%[ self traceCr: 'two'.
%  ^ self.
%  self traceCr: 'not printed' ]
%
%    ~-> End of block expected ->
%\end{code}


\subsection{Escaping behavior of non-local return}
A return expression behaves also like an escape mechanism since the execution flow will directly jump out to the current invoking method. For example, the following expression \ct{Bexp new jumpingOut} will return 3 and not 42. \ct{^ 42} will never be reached. The expression \ct{[ ^3 ]} could be deeply nested, its execution jumps out all the levels and return to the method caller. Some old code  in Pharo (predating introduction of exceptions) passes non-local returning blocks around leading to complex flows and difficult to maintain code. In subsequent sections we will carefully look at where a return is actually returning.

\begin{code}{}
Bexp>>jumpingOut
	#(1 2 3 4) do: [:each |
					self traceCr: each printString.
					each = 3
						ifTrue: [^ 3]].
	^ 42
\end{code}

Now to see that a return is really escaping the current execution, let us build a slightly more complex call flow.
We define four methods among which one creates an escaping block \ct{defineBlock} and one evaluates this block (\ct{arg:}). Pay attention that to stress the escaping behavior of a return we defined \ct{evaluatingBlock:} so that it endlessly loops after evaluating its argument.

\begin{code}{}
Bexp>>start
	| res |
	self traceCr: 'start start'.
	res := self defineBlock.
	self traceCr: 'start end'.
	^ res

Bexp>>defineBlock
	| res |
	self traceCr: 'defineBlock start'.
	res := self arg: [ self traceCr: 'block start'.
                            1 isZero ifFalse: !\textbf{[}! ^ 33 !\textbf{]}!.
                            self traceCr: 'block end'. ].
	self traceCr: 'defineBlock end'.
	^ res

Bexp>>arg: aBlock
	| res |
	self traceCr: 'arg start'.
	res := self evaluateBlock: aBlock.
	self traceCr: 'arg end'.
	^ res

Bexp>>evaluateBlock: aBlock
	| res |
	self traceCr: 'evaluateBlock start'.
	res := self evaluateBlock: aBlock value.
	self traceCr: 'evaluateBlock loops so should never print that one'.
	^  res
\end{code}


Executing \ct{Bexp new start}  prints the following (we added indentation to stress the calling flow).

\begin{code}{}
start start
   defineBlock start
      arg start
         evaluateBlock start
            block start
start end
\end{code}

What we see is that the calling method \ct{start} is fully executed. The method \ct{defineBlock} is not completely executed. Indeed, its escaping block \ct{[^33]} is executed two calls away in the method \ct{evaluateBlock:}. The evaluation of the block returns to the sender of the block home context. Here the home context of the block is the execution context of the method \ct{defineBlock}. The sender of this execution was created by the execution of the method \ct{start}, therefore the return execution returns to the execution point of the \ct{start} execution context.

When the return statement of the block is executed in the method \ct{evaluateBlock:}, the execution discards the pending computation and returns to the method execution point that created the home context of the block. The block is defined in  the method \ct{defineBlock}. The home context of the block is the activation context that represents the execution of the method \ct{defineBlock}. This is why the rest of the computation in the block itself, in the \ct{defineBlock} method, and in the \ct{arg:} method is discarded.

\begin{figure}[!h]
\begin{center}\includegraphics[width=\textwidth]{nonLocalReturn2}
\caption{A block with non-local return execution returns to the method execution that activated the block home context.\dc{rename methods}\label{nonLocalReturn}}
\end{center}
\end{figure}

As shown by Figure~\ref{nonLocalReturn}, \ct{[^33]} will return to the sender of its home context. \ct{[^33]} home context is the context that represents the execution of the method \ct{defineBlock}, therefore it will return its result to the method \ct{start}.

\begin{itemize}
\item Step 1 represents the execution up to the invocation of the
  method \ct{defineBlock}: 'start start' is printed.

\item Step 3 represents the execution up to the block creation, which
  is done in Step 2. 'defineBlock start' is printed. The home context
  of the block is the \ct{defineContext} method execution context.

\item Step 4 represents the execution up to the invocation of the method
  \ct{evaluateBlock:}. \ct{arg start'} is printed.

\item Step 5 represents the execution up to the block evaluation.
  'evaluateBlock: start' is printed.

\item Step 6 represents the execution of the block up to the
  condition: 'block start' is printed.

\item Step 7 represents the execution up to the return statement.

\item Step 8 represents the execution of the return statement. It
  returns to the sender of the block home context, \ie just after the
  invocation of the method defineBlock in the method start. The
  execution continues and 'start end' gets printed.
\end{itemize}

\paragraph{Accessing information.} 

To manually verify and find the home context of a block we can do the following: add the expression \ct{thisContext home inspect} in the block of the  method \ct{defineBlock}. We can also add the expression \ct{thisContext closure home inspect} which accesses the closure via the current execution context and gets its home context. Note that in both cases, even if the block is evaluated during the execution of the method \ct{evaluateBlock:}, the home context of the block is the method \ct{defineBlock}.

Note that such expressions will be executed during the block evaluation.

\begin{code}{}
Bexp>>defineBlock
	| res |
	self traceCr: 'defineBlock start'.
	res := self arg: [ thisContext home inspect. self traceCr: 'block start'.
                            1 isZero ifFalse: !\textbf{[}! ^ 33 !\textbf{]}!.
                            self traceCr: 'block end'. ].
	self traceCr: 'defineBlock end'.
	^ res
\end{code}

To verify where the execution will end you can use the expression \ct{thisContext home sender copy inspect. } which returns a method context pointing to the assignment in the method \ct{start}.

\paragraph{Couple more examples.}
The following examples show that escaping blocks jumped to their home context but do not unwind the stack after this point. For example the previous example shows that the method \ct{start} was fully executed.
We define \ct{valuePassingEscapingBlock} on the class BlockClosure as follows.

\begin{code}{}
BlockClosure>>valuePassingEscapingBlock
	  self value: [ ^nil ]
\end{code}

Then we define a simple assert: method that raises an error if its argument is false.

\begin{code}{}
Bexp>>assert: aBoolean
	aBoolean ifFalse: [Error signal]
\end{code}

We define the following method.

\begin{code}{}
Bexp>>testValueWithExitBreak
	| val |
	[ :break |
	    1 to: 10 do: [ :i |
			         val := i.
			         i = 4 ifTrue: [ break value ] ] ] valuePassingEscapingBlock.
	val traceCr.
	self assert: val = 4.
\end{code}

This method defines a block whose argument \ct{break} is evaluated as soon as the step 4 of a loop is reached. Then a variable \ct{val} is printed and we make sure that its value is 4. Executing \ct{Bexp new testValueWithExitBreak} performs without raising an error and prints 4 to the Transcript: the loop has been stopped, the value has been printed, and the assert has been validated.

If you change the \ct{valuePassingEscapingBlock} message sent by \ct{value: [^ nil]} in the \ct{testValueWithExitBreak} method above, you will not get the trace because the execution of the method \ct{testValueWithExitBreak} will exit when the block is evaluated. In this case, calling \ct{valuePassingEscapingBlock} is not equivalent to calling \ct{value: [^nil]} because the home context of the escaping block \ct{[ ^ nil ]} is different.  With the original \ct{valuePassingEscapingBlock}, the home context of the block \ct{[^ nil]}
is \ct{valuePassingEscapingBlock} and not the method \ct{testValueWithExitContinue} itself.
Therefore when evaluated, the escaping block will change the execution flow to the \ct{valuePassingEscapingBlock} message in the method \ct{testValueWithExitBreak} (similarly to the previous example where the flow came back just after the invocation of the \ct{defineBlock} message).
Put a self halt before the assert: to convince you. In one case, you will reach the halt while in the other not.

\paragraph{Non-local return blocks.} As a block is always evaluated in its home context, it is possible to attempt to return from a method execution which has already returned. This runtime error condition is trapped by the VM.

\begin{code}{}
Bexp>>returnBlock
	^ [ ^ self ]

Bexp new returnBlock value ~-> Exception
\end{code}

When we execute \ct{returnBlock}, the method returns the block to its caller (here the top level execution). When evaluating the block, because the method defining it has already terminated, an error is signaled.


% ==========================================================================
\section{Context: representing method execution}
% ============================================================================
Imagine that we have a simple method as the following one.

\begin{code}{}
Bexp>>first: arg
	| temp |
	temp := arg * 2.
	^ temp
\end{code}

We can easily imagine that when such method is invoked multiple times with different arguments, we need a way to keep
the value of the argument \ct{arg} and the temporary variable \ct{temp}. In addition, the instruction or program counter (the index saying what is the next instruction) can hold different values depending on the execution state and location. Therefore, there is a need to represent such information. Literature calls it a context. A Smalltalk interpreter needs the following information to represent its current execution state:
\begin{enumerate}
\item The CompiledMethod whose bytecodes are being executed.
\item The location of the next bytecode to be executed in that
CompiledMethod. This is the interpreter's instruction pointer.
\item The receiver and arguments of the message that invoked the
CompiledMethod.
\item Any temporary variables needed by the CompiledMethod.
\item A stack.
\end{enumerate}



In Pharo, the class \ct{MethodContext} represents such execution information. Instances of \ct{MethodContext} hold information about a specific execution point and we can obtain them using the pseudo-variable \ct{thisContext}.

Let us look at an example. Modify the method as follow and execute it using \ct{Bexp new first: 33}.
You will get the inspector shown in Figure~\ref{oneContext}.

\begin{code}{}
Bexp>>first: arg
	| temp |
	temp := arg * 2.
	thisContext copy inspect.
	^ temp
\end{code}

Note that we copy the current context obtained using \ct{thisContext} because the Virtual Machine reuses contexts to avoid their creation when not necessary and it nilles out some values such as the temp value.

\begin{figure}[!h]
\begin{center}\includegraphics[width=5cm]{OneContext}
\caption{A method context where we can access the value of the temporary variable \ct{temp} at that given point of execution.\label{oneContext}}
\end{center}
\end{figure}

\ct{MethodContext} does not only represent activation context of method execution but also
the ones for block closures as we will see later. Let us have a look at some value of the current context:

\begin{itemize}
\item \ct{sender} points to the previous context that led to the creation of the current context. Here when you executed the expression, a context was created and this context is the sender of the current one.

\item \ct{method} points to the currently executing method.

\item \ct{pc} holds the value of the last executed instruction. Here its value is 27. To see which instruction it is, double click on the \ct{method} instance variable and select the all bytecodes field, you should obtain the situation depicted in Figure~\ref{ByteCodes}, which shows that the next instruction to be executed is pop (instruction 28).

\item \ct{stackp} defines the number of stored temporary variables.

\item \ct{closureOrNil} holds a reference to the closure currently executed or nil.

\item \ct{receiver} is the message receiver.
\end{itemize}

\begin{figure}[!h]
\begin{center}\includegraphics[width=5cm]{ByteCodes}
\caption{The last instruction executed was the message send \ct{inspect}.\label{ByteCodes}}
\end{center}
\end{figure}

\subsection{Studying Contexts}

Method arguments and temporaries are stored in contexts. A context have a variable part that
stores them.

When inspecting the following method, stackp holds 3 to represent that there is one argument
and two temporary variables.

\begin{code}{}
Bexp>>twoTempsOneArg: arg
	"self new twoTempsOneArg: 33"
	| temp1 temp2 |
	temp1 := temp2 := arg.
	thisContext copy inspect.
	^ temp1
\end{code}


\begin{code}{}
ContextPart>>arguments
	"returns the arguments of a message invocation"

	| arguments numargs |
	numargs :=  self method numArgs.
	arguments := Array new: numargs.
	1 to: numargs do: [:i | arguments at: i put: (self tempAt: i) ].
	^ arguments
\end{code}


\subsection{Invoking Another Method}
\begin{code}{}
Bexp>>first: arg

	| temp |
	temp := arg *2.
	thisContext copy inspect.
	self second: temp.

Bexp>>second: arg2

	self halt.
	^ arg2
\end{code}

In the inspector, you can access the temporary variable of method first: using the expression self tempNamedAt: 'arg'




% ============================================================================
\section{Closures}
% ============================================================================
\begin{code}{}
#(1 2 3) inject: 0 into: [:sum :each | sum + each]
\end{code}

\begin{code}{}
inject: thisValue into: binaryBlock
	"Accumulate a running value associated with evaluating the argument,
	binaryBlock, with the current value of the argument, thisValue, and the
	receiver as block arguments. For instance, to sum the numeric elements of a
	collection, aCollection inject: 0 into: [:subTotal :next | subTotal + next]."
	| nextValue |
	nextValue := thisValue.
	self do: [:each | nextValue := binaryBlock value: nextValue value: each]. 	^ nextValue
\end{code}



Lexical closure is a concept introduced by SCHEME in 70s. Scheme uses lambda expression which is basically an anonymous function (such the block). But using an anonymous function implies to connect it to the current execution context. This is why the lexical closure is important because it defines when variables of block are bound to the execution context. The variable is depending of the scope where it is defined. Let's illustrate that :

\begin{code}{}
blockLocalTemp
	| collection |
		collection := OrderedCollection new.
		1 to: 3 do: [ :index || temp |
			temp := index.
			collection add: [ temp ] ].
		^collection collect: [:each | each value].
\end{code}

Let's comment the code: we create a loop that stores the arg value in a temporary variable created in the loop. We store a block containing the simply temp read access in a collection. After the loop, we evaluate each block and return the collection of value.
If we evaluate this method, it will return \#(1 2 3). What's happening? At each loop we create a variable existing locally and bind it to a block. Then at the end evaluate block, we evaluate each block with this contextual \emph{temp}.

\begin{figure}[htbp]
	\centering
        \includegraphics[width=0.7\linewidth]{blockClosureLocalTemp}
	\caption{blockLocalTemp Execution}
	\label{fig:blockLocalTempExecution}
\end{figure}

Now see another case :
\begin{code}{}
blockOutsideTemp
		| collection temp |
		collection := OrderedCollection new.
		1 to: 3 do: [ :index |
			temp := index.
			collection add: [ temp ] ].
		^collection collect: [:each | each value].
\end{code}
Same case except the \emph{temp}, variable will be declared in the upper scope. What will happen? Here the temp at each loop is the \textbf{same} shared variable bind. So when we collect the evaluation of the block at the end we will collect \#(3 3 3).
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.7\linewidth]{blockClosureOutsideTemp}
	\caption{blockOutsideTemp Execution}
	\label{fig:blockClosureOutsideTemp}
\end{figure}

When we look at the following Scheme expression and evaluate it you get 4. Indeed a binding is created
which associates the variable index to the value 0. Then y a lambda expression is defined and it returns
 the variable index (its value). Then within this context another expression is evaluated which starts
with a begin statement: first the value of the variable index is set to 4. Second the lambda expression is
evaluated. It returns then the value of the

\begin{code}{}
(let* ((index 0)
       (y (lambda () index)))
  (begin
    (set! index 4)
    (y)))
\end{code}

\begin{code}{}
(let ((index 0))
  (let ((y (lambda () index)))
    (begin
      (set! index 4)
      (y))))
\end{code}

\begin{code}{}
((lambda (index)
   ((lambda () (begin
                (set! index 4)
                index))))
 0)
\end{code}


What you see is that the lambda expression is sharing the binding (index 0) with expression \ct{(begin...)}
therefore when this binding is modify from the body of the begin expression, the lambda expression sees its impact
and this is why it returns 4 and not 0 because.



% ============================================================================
\section{Opening the trunk}
% ============================================================================
The Virtual Machine represents execution state as context objects, one per method or block currently executed (or activated). In Pharo, method and block activations are represented by MethodContext instances.
We will explain contexts as well as method execution to finish by block closure evaluation.




\subsection{Sending a Message}
Let us look at what happens when we send a message.

To send a message to a receiver, the VM has to:

\begin{enumerate}
\item Find the class of the receiver using the receiver object's header.
\item Lookup the method in the class methodDictionary. If the method is not found, repeat this lookup in superclasses. When no class in the superclass chain can understand the message, send the message \ct{doesNotUnderstand:} to the receiver so that the error can be handled in a manner appropriate to that object.

\item Extract the appropriate compiled method from the method dictionary where the message was found and then
\begin{enumerate}
\item check for a primitive associated with the method by reading the method header
\item if there is a primitive, execute it.
\item if it completes successfully, return the result object directly to the message sender.
\item otherwise, continue as if there was no primitive called and pass to step 4.
\end{enumerate}
\item Create a new activation record. Set up the program counter, stack pointer,
home contexts, then copy the arguments and receiver from the message sending context's stack to the new stack.
\item Activate that new context and start executing the instructions in the new method.
\end{enumerate}

When a message is sent, computation state may have to be changed to execute a different compiled method in response to this new message. The execution old state must be remembered because the instructions after the message send must be executed after the value of the message is returned.
The execution saves its state in objects called contexts. There will be many contexts in the system at any one time. The context that represents the current state of execution is called the active context.

When a message send happens in the active context, the active context becomes suspended and a new context is created and made active. The suspended context retains the state associated with the original compiled method until that context becomes active again. A context must remember the context that it suspended so that the suspended context can be resumed when a result is returned. The suspended context is called the new context's sender.

Contexts are objects representing a given execution state also called activation record, like a C stack represents execution of a C program. Contexts maintain the program counter and stack pointer, holding pointers to the sending context, the method for which this is appropriate, etc. A MethodContext represents an executing method, it points back to the context from which it was activated, holds onto its receiver and compiled method.

%\begin{figure}
%\begin{center}
%\includegraphics[width=8cm]{MethodAndMethodContext}
%\end{center}
%\end{figure}

\subsection{Remote Variables in Blocks}
Temporaries and arguments for Blocks are handled the same way as in Methods.
Arguments are passed on the stack and temporaries are held in the corresponding context.
However a block can access more variables than a simple method.
It is possible to refer to arguments and temporaries from the enclosing method.
As you have seen before, blocks can be passed around freely and activated any time later.
Even in this case the block can access and modify the variables from the method it was defined in.


\subsection{Real Closures with MethodContext and BlockContext}

Let us consider the example shown in the following picture.

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{BlockWithFullClosures}
\end{center}
\end{figure}

The \ct{temp} variable used in the block the \ct{exampleReadInBlock} method is a remote variable.
\ct{temp} is initialized and changed in the method body and later on read in the block.
The actual value of the variable is not stored in the block context but in the defining method context, also known as home context.
In a typical implementation the home context of a block is accessed through its closure.
This approach works well if all objects are first-class objects, including the methods and block context.
Blocks can be evaluated outside their home context and still refer to remote variables.
Hence all home contexts might outlive the method activation. \cb{cannot-return example is missing here}

\subsection{Optimizing the Stack in the VM}
The previously mentioned approach for block contexts has disadvantages from a low-level point of view.
If method and block contexts are normal objects that means they have to be garbage collected at some point.
Combined with the typical coding practice of using small methods that call many other objects Smalltalk system generate a lot of contexts.

The most efficient way to deal with method contexts is to not create them at all.
At the VM this is done by using real stack frames.
Method contexts can be easily mapped to stack frames: whenever we call a method we create a new frame, whenever we return from a method we delete the current frame.
In that matter Smalltalk is not different from C.
This means whenever we return from a method the method context / stack frame is immediately removed.
Hence no high-level garbage collection is needed. \cb{maybe explain a bit more how the stack frames work in C}
However using the stack gets much more complicated when we have to support blocks.

As we mentioned before, methods contexts that are used as home contexts might outlive their activation.
If method contexts work as they did up to now we would to check each time for home contexts if a stack frame is removed.
This comes with a big performance penalty.
Hence the next step in using a stack for contexts is to make sure method contexts can be safely removed when we return from a method.

The following example shows how remote variables are no longer directly stored in the home context but in a separate remote array.

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{BlockWithMethodContext}
\end{center}
\end{figure}



\subsection{Reading Remote Variables in a TemporaryVector}
The following example defines a block that read a temporary variable from its enclosing block.
\begin{code}{}
exampleReadInBlock
    | readOnlyInBlock |
    readOnlyInBlock := #readOnlyInBlock.
    ^ [ readOnlyInBlock ] value
\end{code}



\subsection{Optimizing read-only Temporaries accessed from a Block}
The bytecodes for this method look as follows.
\begin{code}{}
pushConstant: #readOnlyInBlock
popIntoTemp: 0
pushTemp: 0

closureNumCopied: 1 numArgs: 0 bytes 24 to 25
pushTemp: 0
blockReturn

send: value
returnTop
\end{code}


\subsection{More Examples}
\begin{code}{}
exampleWrittenInBlock
    | writtenInBlock |
    [ writtenInBlock := #foo ] value.
    ^ writtenInBlock
\end{code}

\begin{code}{}
exampleTempNamedPut
    | externalViciouslyWritten |
    externalViciouslyWritten := #external.
    [ thisContext tempNamed: #externalViciouslyWritten put: #internal. externalViciouslyWritten ] value.
    ^ externalViciouslyWritten
\end{code}

% too many arguments for blocks
% 
\section{Chapter Summary}














%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:


%| last |
%last := thisContext.
%thisContext runSimulated: [#(1 2 3) detect: [:e| e even]] contextAtEachStep: [:c| c ~~ last ifTrue: [Transcript print: c; cr; flush. last := c]]
%
%=>
%
%[] in UndefinedObject>>DoIt
%Array(Collection)>>detect:
%Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
%
%
%or...
%+
%
%| last home indent |
%last := nil.
%home := thisContext.
%indent := 0.
%thisContext
%	runSimulated: [#(1 2 3) detect: [:e| e even]]
%	contextAtEachStep:
%		[:c| | ctxt |
%		c ~~ last ifTrue:
%			[last := c.
%			 indent := 0. ctxt := c sender.
%			 [ctxt ~~ home] whileTrue:
%				[ctxt := ctxt sender. indent := indent + 1].
%			Transcript crtab: indent; print: c; flush]]
%
%[] in UndefinedObject>>DoIt
%	Array(Collection)>>detect:
%		Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%	Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
%


% ============================================================================
\section{Chapter conclusion}
% ============================================================================

We want to thank Ben Coman for his english corrections and Eliot Miranda for the discussions and explanations about his implementation of fast closure for Squeak and Pharo. We thank Norbert Hartl for his feedback.
