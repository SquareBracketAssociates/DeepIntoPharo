% $Author: oscar $
% $Date: 2009-08-16 16:37:09 +0200 (Sun, 16 Aug 2009) $
% $Revision: 28477 $

% HISTORY:
% 2008-01-19 - Stef started
% 2008-12-26 - Jannik Laval added text
% 2011-20-05 - Jean baptiste Arnaud add some text (Lexical closure)
% 2011-07-01 - Jean baptiste Arnaud add some test (Storing a block)
% 2011-08-09 - Stef doing another pass
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
% todo for stef explaining blockClosure environment representation + explaining the trick with the bytecodes
% 2012-01-27 - Integrated Ben Coman feedback

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Block and Dynamic Behavior of Smalltalk-Runtime}\chalabel{blocks}
\chapterauthor{Jean-Baptiste Arnaud}



Blocks (lexical closures) are a powerful and essential feature of Smalltalk. Without them it
would be difficult to have such a small and compact syntax. The use of blocks in Smalltalk
is the key to get conditionals and loops not hardcoded in the language syntax but just 
simple messages having blocks as arguments. This is why we can say that 
blocks work extremely well with the message passing syntax of Smalltalk.

In addition blocks are  effective to improve the readability, reusability and efficiency of code. 
However the dynamic runtime semantics of Smalltalk are often not well documented. Blocks in the presence of return statements behave like an escaping mechanism and while this can lead to ugly code when used to its extreme, it is important to understand it. 

In this chapter we will discuss some basic block behavior such as the notion of a static environment defined at block compile-time. Then we will present some deeper issues. But let us first recall some basics.

We already presented blocks in Pharo by Example. This presentation was simple and showing simply how to define blocks and to use them. Here we just will focus on deeper aspects and their run time behavior. 

\section{Basics}
What is a block? Historically, it's a Lambda expression, or an anonymous function. A block is a piece of code whose execution is frozen and kicked in using  specific messages.  Blocks are defined by square brackets. 

If you execute and print the result of the following block you will not get 3 but a block. 
\begin{code}[Block definition]{Block Definition}
[ 1 + 2 ]
    --> [ 1 + 2 ]
\end{code}

 A block is evaluated by sending the \mthind{BlockClosure}{value} message to it. More precisely blocks can be executed using \ct{value} (when no argument is mandatory), \ct{value:} (when one argument), \ct{value:value:}, \ct{value:value:value:}  and \ct{valueWithArguments: anArray}...). These messages are the basic and historical API for block execution. They were presented in Pharo by Example. 
 

\begin{code}[Block definition]{Block Execution}
[ 1 + 2 ] value  
    --> 3
    
[ :x | x + 2 ] value: 5
    --> 7
\end{code}

\subsection{Some handy extensions}
Pharo includes some handy messages such as \ct{cull:} and friends to support the execution of blocks even in presence of more values than necessary. This allows us to write blocks more concisely when we are not necessarily interested in all the available arguments.
\ct{cull:} fills the same need as  \ct{valueWith[Possible/Enough]Args:}, but does not require creating an Array with the arguments, and will raise an error if the receiver has more arguments than provided rather than pass nil in the extraneous ones. 
Hence, from where the block is provided, they look almost the same, but where the block is executed, the code is usually cleaner.

Here are some examples of \mthind{BlockClosure}{cull:} and  valueWithPossibleArgs: usages.
\begin{code}{Cull: examples}
[ 1 + 2 ] cull: 5
	--> 3
[ :x | 1 + 2 + x ] cull: 5 
	--> 8
[ 1 + 2 ] cull: 5 cull: 6
	--> 3
[ :x | 1 + 2 + x ] cull: 5 
	--> 8
[ :x | 1 + 2 + x ] cull: 5 cull: 3	
	--> 8 
[ :x :y | 1 + y + x ] cull: 5 cull: 2 
	--> 8
[ :x :y | 1 + y + x ] cull: 5 
	~->raises an error mentioning that the block requires two arguments.
[ :x :y | 1 + y + x ] valueWithPossibleArgs: #(5) 
	~->leads to an error because nil is passed as arguments.	
\end{code}

The message \mthind{BlockClosure}{once} is another extension that caches the results until the receiver is uncached. A typical usage is the following one:

\begin{method}{Example for resources caching using once}
myResourceMethod
	^ [expression] once
\end{method}

Blocks are instances of class \ct{BlockClosure}. The table below lists some of the messages available on this class. 
 
\begin{tabular}{p{2.5cm}|p{8cm}}
\textsf{silentlyValue}&Execute the receiver but avoiding progress bar notifications to show up.\\
\textsf{once}&Answer and remember the receiver value, answering exactly the same object in any further sends
	 of once or value. The expression will be evaluated once and its result returned for any subsequent evaluations.\\
\end{tabular}

Some messages are useful to profile execution (more information on Chapter~\ref{cha:Profiler}: 

\begin{tabular}{p{2.5cm}|p{8cm}}
\textsf{bench}&Return how many times the receiver can get executed in 5 seconds. \\
\textsf{durationToRun}&Answer the duration (instance of Duration) taken to execute the receiver block.\\
\textsf{timeToRun}&Answer the number of milliseconds taken to execute this block.\\
\end{tabular}

Some messages are related to error handling (as explained in the Exception Chapter~\ref{cha:exception}).

\begin{tabular}{p{2.5cm}|p{8cm}}
\textsf{ensure: aBlock}&Execute a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes.  \\
\textsf{ifCurtailed: aBlock}& Evaluate the receiver with an abnormal termination action. Evaluate aBlock only if execution is unwound during execution of the receiver. If execution of the receiver finishes normally do not evaluate aBlock. \\
\textsf{on: exception do: aBlock}&Evaluate the receiver. If an exception \textsf{exception} is raised, executes the block \textsf{aBlock}.\\
\textsf{on: exception fork: aBlock}&Execute the receiver. In case of exception, fork a new process, which will handle the error. The original process will continue running as if receiver evaluation finished and answered nil,\ie  an expression like: \textsf{[ self error: 'some error'] on: Error fork: [:ex |  123 ]} will always answer nil to the original process, not 123. The context stack, starting from context which sent this message to the receiver and up to the top of the stack will be transferred to the forked process, with handlerAction on top. When the forked process will resume, it will enter the block \textsf{aBlock}).\\
\end{tabular}


Some messages are related to process scheduling. We list the most important ones. Since this Chapter is not about concurrent programming in Pharo we will not go deep into them.

\begin{tabular}{p{2.5cm}|p{8cm}}
\textsf{fork}&Create and schedule a Process running the code in the receiver.\\
\textsf{forkAt: aPriority}& Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process. \\
\textsf{newProcess}&Answer a Process running the code in the receiver. The process is not scheduled.\\
\end{tabular}


\section{Method Execution}
Before going into the details of block handling, we will have a look at the way methods are executed. Imagine that we have 
a simple method 

\begin{code}{}
BEXp>>first: arg	| temp | 		temp := arg * 2.
	^ temp
\end{code}

We can easily imagine that when such method is invoked multiple times with different arguments, we need a way to keep 
the value of the argument \ct{arg} and the temporary variable \ct{temp}. In addition, the instruction or program counter (the index saying what is the next instruction) can hold different values depending on the execution state and location. Therefore, there is a need to represent such information. Literature calls it a context. A Smalltalk interpreter needs five information to represent its current execution state:
\begin{enumerate}
\item The CompiledMethod whose bytecodes are being executed.\item The location of the next bytecode to be executed in thatCompiledMethod. This is the interpreter's instruction pointer.\item The receiver and arguments of the message that invoked theCompiledMethod.\item Any temporary variables needed by the CompiledMethod.\item A stack.
\end{enumerate}



In Pharo, the class \ct{MethodContext} represents such execution information. Instances of \ct{MethodContext} hold information about a specific execution point and we can obtain them using the pseudo-variable \ct{thisContext}.

Let us look at an example. Modify the method as follow and execute it using \ct{BEXp new first: 33}. 
You will get the inspector shown in Figure~\ref{oneContext}.

\begin{code}
BEXp>>first: arg	| temp | 		temp := arg * 2.
	thisContext copy inspect.
	^ temp
\end{code}

Note that we copy the current context obtained using \ct{thisContext} because the Virtual Machine reuses contexts to avoid their creation when not necessary and it nilles out some values such as the temp value.

Let us have a look at some value of the current context:

\begin{figure}[!h]
\begin{center}\includegraphics[width=5cm]{oneContext}
\caption{A method context where we can access the value of the temporary variable \ct{temp} at that given point of execution.\label{oneContext}}
\end{center}
\end{figure}

\begin{itemize}
\item \ct{sender} points to the previous context that led to the creation of the current context. Here when you executed the expression, a context was created and this context is the sender of the current one. 
\item \ct{pc} holds the value of the last executed instruction. Here its value is 27. To see which instruction it is, double click on the method instance variable and select the all bytecodes field, you should obtain the situation depicted in Figure~\ref{ByteCodes}. 

\end{itemize}


\begin{figure}[!h]
\begin{center}\includegraphics[width=5cm]{ByteCodes}
\caption{The last instruction executed was the message send \ct{inspect}.\label{ByteCodes}}
\end{center}
\end{figure}







\begin{code}
BEXp>>first: arg	| temp | 		temp := arg * 2.
	thisContext copy inspect.
	temp := arg * 3.
	thisContext inspect.
	self halt.
	^ temp
\end{code}

Why without the self halt in the inspector temp is nil? Context recycling?
Why can it see the difference between the first and the second thisContext?



Therefore, there is a need to represent the specific execution state of a compiled method: the argument, temporary variable, next instruction to execute. 







\begin{code}{}
BEXp>>first: arg	| temp | 		temp := arg *2.
	thisContext inspect.	self second: temp.

BEXp>>second: arg2		self halt.	^ arg2
\end{code}

In the inspector, you can access the temporary variable of method first: using the expression self tempNamedAt: 'arg'


\subsection{Contexts}

Contexts are objects representing a given execution state also called activation record, like a C stack represents execution of a C program. Contexts maintain the program counter and stack pointer, holding pointers to the sending context, the method for which this is appropriate, etc. MethodContext represents an executing method, it points back to the context from which it was activated, holds onto its receiver and compiled method. 

\begin{figure}
\begin{center}
\includegraphics[width=8cm]{MethodAndMethodContext}
\end{center}
\end{figure}

To send a message to a receiver, the VM has to:

\begin{enumerate}
\item find the class of the receiver using the receiver object's header.\item lookup the method in the class methodDictionary.\item if the method is not found, repeat this lookup in superclasses.When no class in the superclass chain can understand the message, send the message doesNotUnderstand: to the receiver so that the error can be handled in a manner appropriate to that object.
\item extract the appropriate CompiledMethod from the MethodDictionary where the message was found and then 
\begin{enumerate}\item check for a primitive associated with the method by reading the method header\item if there is a primitive, execute it.\item if it completes successfully, return the result object directly to the message sender.\item otherwise, continue as if there was no primitive called.
\end{enumerate}\item Create a new activation record. Set up the program counter, stack pointer,home contexts, then copy the arguments and receiver from the message sending context's stack to the new stack.
\item Activate that new context and start executing the instructions in the new method.
\end{enumerate}


\subsection{Handling Temporary Variables}
\sd{to rewrite}
Temporary Variables.
 Temporary variables are created for a particular execution of a CompiledMethod and cease to exist when the execu- tion is complete. The CompiledMethod indicates to the interpreter how many temporary variables will be required. The arguments of the in- voking message and the values of the temporary variables are stored to- gether in the temporary frame. The arguments are stored first and the temporary variable values immediately after. They are accessed by the same type of bytecode (whose comments refer to a temporary frame lo- cation). Since merge: takes a single argument, its two temporary vari- ables use the second and third locations in the temporary frame. The compiler enforces the fact that the values of the argument names can- not be changed by never issuing a store bytecode referring to the part of the temporary frame inhabited by the arguments.


When a message is sent, all five parts of the in-terpreter's state may have to be changed in order to execute a different CompiledMethod in response to this new message. The interpreter's old statemust be remembered because the bytecodes after the send must be executed after the value of the message is returned.The interpreter saves its state in objects called contexts. There will be many contexts in the system at any one time. The context that rep- resents the current state of the interpreter is called the active context. When a send bytecode in the active context's CompiledMethod requires a new CompiledMethod to be executed, the active context becomes sus- pended and a new context is created and made active. The suspended context retains the state associated with the original CompiledMethod until that context becomes active again. A context must remember the context that it suspended so that the suspended context can be resumed when a result is returned. The suspended context is called the new con- text's sender.


\section{Variables and Blocks}
In Smalltalk, private variables (such as self, instance variables, temporaries and arguments) are 
lexically scoped. These variables are bound (get a value associated to them) in the context in which the block that contains them is defined, rather than the context in which the block is executed.  We call the context (an activation record representing a smalltalk execution stack element) in which a block is defined, the \emph{block home context}.


Let's have fun and experiment a bit to understand. 
Define a class named \ct{BExp} (for BlockExperience) and the following methods:

\paragraph{Experience one.}\ 

\begin{code}{}
BExp>>testBlock: aBlock 
	| t | 
	t := nil. 
	aBlock value 
	
BExp>>testScope 
	| t | 
	t := 42. 
	self testBlock: [self traceCr: t printString] 
\end{code}

Execute \ct{BExp new testScope}. Executing the \ct{testScope} message will print 42 in the Transcript. The value of the temporary variable \ct{t} defined in method \ct{testScope} is the one used rather than the one of t defined inside \ct{testBlock:}.
The variable \ct{t} is not looked up in the context of the executing method \ct{testBlock:} but in the context of the method \ct{testScope} which defined the block.

\sd{would be nice to have a picture}

\paragraph{Experience two.}\ 
\begin{code}{}
BExp>>testBlock: aBlock
	| t | 
	t := nil. 
	aBlock value 
	
BExp>>testScope2 
	| t | 
	t := 42. 
	self testBlock: [t := 33. self traceCr: t printString] 	
\end{code}

Executing \ct{BExp new testScope2} prints 33. This experience shows that a block is not only an anonymous method but one with an execution context or environment. In this environment temporary variables are bound with the values they hold when the block 
is defined. 

If we redefine \ct{testScope2} as follows: 

\begin{code}{}
testScope2 
	|t|
	t := 42.
	self testBlock: [t := 33. self traceCr: t printString].
	self testBlock: [t := 66. self traceCr: t printString].
	self testBlock: [ self traceCr: t printString]
\end{code}

We will get 33, 66 and 66 printed.




\paragraph{For method arguments.}\
Naturally we can expect that method arguments as well as self and instance variables are bound 
in the context of defining method. Let's illustrate these points now. 

\begin{code}{}
BExp>>testScopeArgValue: aBlock
	| arg | 
	arg := 'zork'.
	aBlock value
	
BExp>>testScopeArg: arg
	"self new testScopeArg: 'foo'"
	
	self testScopeArgValue: [self traceCr: arg ; cr]
\end{code}

Now executing \ct{BExp new testScopeArg: 'foo'} prints 'foo' even if in the method \ct{testScopeArgValue:} the temporary arg is redefined.
 

\paragraph{self binding.}
For binding of self, we simply define a new class and a couple of methods. 
Add the instance variable x to the class \ct{BExp} and define the initialize method as follows:

\begin{code}{}
Object subclass: #BExp
	instanceVariableNames: 'x'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BlockExperiment'
\end{code}

\begin{code}{}
BExp>>initialize
	x := 123.
\end{code}	

Define another class named \ct{BExp2} (it can be a subclass of \ct{BExp} since inheritance is orthogonal to what we want to show).


\begin{code}{}
BExp2>>initialize
	super initialize.
	x := 69.

BExp2>>testScopeSelf: aBlock
	aBlock value
\end{code}

Then define the methods that will invoke  methods defined in \ct{BExp2}.
\begin{code}{}	
BExp>>testScopeSelf: aBlock
	"Here we ask another class to execute the block"
	BEXp2 new testScopeSelf: aBlock
	
BExp>>testScopeSelf
	"self new testScopeSelf"
	self testScopeSelf: [self traceCr: self printString ; traceCr: x]
\end{code}	

Now when we execute \ct{BExp new testScopeSelf}. You get \ct{a BExp123} printed, showing that a block captures self too, since an instance of BExp2 executed the block but the printed object was the original BExp instance. 

\paragraph{An example of sharing.}

Variables referred to by a block continue to be accessible and shared with other expressions. Let us  take some examples. Define the following method \ct{foo} which defines a temporary variable \ct{a}.

\begin{code}{}
BExp>>foo
	| a |
	[ a := 0 ] value.
	^ a
\end{code}

When we execute \ct{BExp new foo}, we get 0 and not nil. 
Here what you see is that the value is shared between the method body and the block. Inside the method body we can access the variable whose value was set by the block execution. 
Both the method  and block bodies access to the temporary variable \ct{a}.

Now imagine that we define the method \ct{foo} as follows:

\begin{code}{}
BExp>>foo
	| a |
	a := 0. 
	^ {[ a := 2] . [a]} 
\end{code}

The method \ct{foo} defines a temporary variable \ct{a}. It sets the value of \ct{a}
to zero and returns an array whose first element is a block setting the value to 2 and second element is a block just returning the value of the temporary variable. 

\begin{code}{}
| res | 
res := BExp new foo.
res second value.
     --> 0
res first value.
res second
     --> 2
\end{code}

You can also define the code as follows and open a transcript to see the results.

\begin{code}
| res |
res := BExp new foo.
res second value traceCr.
res first value.
res second value traceCr.
\end{code}

Let us step back and look at an important point. 
In the previous code snippet when the expressions \ct{res second value} and \ct{res first value} are executed, the method \ct{foo} has already finished its execution - as such it is not on the execution stack anymore.  Still the temporary variable \ct{a} can be accessed and set to new value. It means that the variables referred to by a block may live longer than the methods which created the block that refers to them. We say that the variables outlive their defining context. 

The block implementation needs to keep referenced variables in a structure that is not linked to the execution stack but lives in the heap. We will go in more details in a following section. 



\section{Returning from inside a block}
It is really not a good idea to have return statement in a block such as \ct{[^ 33]} that you pass or store into instance variables and we will explain why in this section. A block with explicit return statement is called a  non-local return block. 

\subsection{Basics on Return}
A return statement allows one to return a different value than the receiver of the message.

\begin{code}{}
BExp>>testExplicitReturn
	"self new testExplicitReturn"
	
	self traceCr: 'one'.
	0 isZero ifTrue: [ self traceCr: 'two'. ^ self].
	self traceCr: 'not printed'
\end{code}

Executing \ct{BExp new testExplicitReturn} will print one and two. But not \ct{not printed}.

In Smalltalk, \ct{^} should be the last statement of a block body. You should get a compile error if you type and compile the following expression. 

\begin{code}{}
[ self traceCr: 'two'.
  ^ self.  
  self traceCr: 'not printed' ]
  
    ~-> End of block expected ->
\end{code}


\subsection{Escape with Non Local Return}
A return expression behaves also like an escape mechanism since the execution flow will jump out to the current caller and not just one level up. For example, the following code will return 3 and 42 will never be reached. The expression \ct{[ ^3 ]} could be deeply nested, its execution jumps out all the levels and returns \emph{from} the method that defines it. This is why it is important to avoid to use this style and use Exception when such behavior is needed. Some old code in Pharo predates Exception introduction and returning blocks are passed around leading to complex flow and difficult to maintain code. 

\begin{code}{}
BExp>>foo
	
	#(1 2 3 4) do: [:each | 
					self traceCr: each printString. 
					each = 3 
						ifTrue: [^ 3]].						
	^ 42
\end{code}

Now to see that a return is really escaping the current execution. Let us build a slightly more complex call flow. 
We define four methods among which one creates and escaping block \ct{defineBlock} and one execute this block (\ct{arg2:}).


\begin{code}{}
Bexp>>executeBlock: aBlock
	| res |
	self traceCr: 'executeBlock start'.
	res := self executeBlock: aBlock value. 
	self traceCr: 'executeBlock loop so should never print that one'.
	^  res
\end{code}


\begin{code}{}
Bexp>>arg: aBlock
	| res |
	self traceCr: 'arg start'. 
	res := self executeBlock: aBlock.
	self traceCr: 'arg end'. 
	^ res 
\end{code}

\begin{code}{}
BExp>>defineBlock
	| res |
	self traceCr: 'defineBlock start'.
	res := self arg: [ self traceCr: 'block start'. 
                            1 isZero ifFalse: !\textbf{[}! ^ 33 !\textbf{]}!.
                            self traceCr: 'block end'. ].
	self traceCr: 'defineBlock end'.
	^ res
\end{code}


\begin{code}{}
BExp>>start
	| res |
	self traceCr: 'start start'.
	res := self defineBlock.
	self traceCr: 'start end'.
	^ res
\end{code}

Executing \ct{BExp new start}  prints:

\begin{code}{}
start start
defineBlock start
arg start
executeBlock start
block start
start end
\end{code}

What we see is that the calling method \ct{start} is fully executed. The method \ct{defineBlock} is not completely executed. Indeed its escaping block \ct{[^33]} is executed two calls away in \ct{executeBlock:}. The execution of the block returns to the method that created the home context of the block. Here when the block is executed in method \ct{executeBlock:}, the execution discards the pending computation and returns from the method that defines the block, here \ct{defineBlock}. This is why the rest of the computation in the block itself, the \ct{defineMethod} method as well as \ct{arg:} are discarded. 

As shown by Figure~\ref{nonLocalReturn}, \ct{[^3]} will return to the method that activated its home context \ct{unclear what does it mean activated}. \ct{[^33]} home context is the context that represents the execution of the method \ct{defineBlock}, therefore it will return its result to the method \ct{start}.

\begin{figure}[!h]
\begin{center}\includegraphics[width=9cm]{nonLocalReturn}
\caption{A block with non local return execution returns to the method that activated the block home context.\label{nonLocalReturn}}
\end{center}
\end{figure}


\paragraph{Couple more examples.}
The following examples shows that escaping blocks jumped to their home context but do not unwind the stack after this point. For example the previous example shows that the method \ct{start} was fully executed. 
\ct{valueWithExit} is defined on the class BlockClosure as follows.

\begin{code}{}
BlockClosure>>valueWithExit 
	  self value: [ ^nil ]
\end{code}

\begin{code}{}
BExp>>assert: aBoolean
	aBoolean ifFalse: [Error signal]

BExp>>testValueWithExitBreak
	| val |
	[ :break |
	    1 to: 10 do: [ :i |
			val := i.
			i = 4 ifTrue: [break value].
		] 
	] valueWithExit.
	self assert: val = 4.
\end{code}

The method \ct{testValueWithExitBreak} shows that the block \ct{break} is created and activated once and as effect it cancels the rest of the computation. 

The following method \ct{testValueWithExitContinue} shows that just the computation left from the block activation is skipped (here \ct{val := val + 1.	last := i}, when i = 4) and this is why the value of \ct{val} is 9 and not 10. 
In this example, a new block is created 


\begin{code}{}
BExp>>testValueWithExitContinue
	| val last |	
	val := 0. 
	1 to: 10 do: [ :i |
		[ :continue |
			i = 4 ifTrue: [continue value].
			val := val + 1.
			last := i
		] valueWithExit.
	].
	self assert: val = 9.
	self assert: last = 10.	
\end{code}

Pay attention here \ct{valueWithExit} is not equivalent to \ct{value: [^nil]} because it changes the home context of the block. 
In the first case the homeContext of the block is not the method \ct{testValueWithExitContinue} while in the second it is.
Put a self halt before the assert: to convince you. In one case, you will reach the halt while in the other not. 



\sd{up until here}


\subsection{Different blocks} 

\sd{should say something about that.}
\paragraph{Non-local return blocks.} \ct{[:x :y| x*x. ^ x + y]} returns the value to the method that activated its homeContext. As a block is always evaluated in its homeContext, it is possible to attempt to return from a method which has already returned using other return. This runtime error condition is trapped by the VM.

\begin{code}{}
Object>>returnBlock
	"self new returnBlock value -> error"

	^[^self]

Object new returnBlock
-> Exception
\end{code}	
	
	



\sd{restarted here}
Block temporary variables are local to the blocks. For example


\begin{code}{}
|b|
b := [ :p |
	| t |
	t ifNil: [ t := p ].
	t ].
{ b value: 1. b value: 2 }.
   -->  #(1 2)
\end{code}

You get \ct{#(1 2)} because \ct{t} is a block local variable. Its value is initialized during each block execution.

\sd{until here}



\section{Blocks and Contexts}

The Virtual Machine represents the state of execution as context objects, one per method or block currently executed (or activated). In Pharo method and block activations are represented by MethodContext.
Contexts are first-class activation record.

aContext contains a reference to the context from which it is invoked, the receiver arguments, temporaries in the Context

We call the home context, the activation record or context in which a block is defined.

Arguments, temporaries, instance variables are lexically scoped in Smalltalk. These variables are bound in the context in which the block is defined and not in the context in which the block is evaluated.




\section{Block Scope Optimization}







\section{Chapter conclusion}


We want to thank Ben Coman for his english corrections.

\section{To be treated}

\begin{code}{}
|b| 
b:= [:x| Transcript show: x. x].
b value: a. b value: b.
b:= [:x| Transcript show: x. ^x].
b value: a. b value: b.
\end{code}
 
Non local returning blocks cannot be executed several times!

\begin{code}{}
Test>>testScope
	   |t|
    	t := 15.
	   self testBlock: [Transcript show: "--",t printString, "--".
	   ^35 ].
    ^ 15

Test>>testBlock:aBlock
	   |t|
	   t := 50.
	   aBlock value.
	   self halt.
\end{code}

\begin{code}{}
Test new testBlock 	
print: *15* and not halt. 
return: 35
\end{code}


\begin{code}{}
|val|
val := [:exit |
		|goSoon|
		goSoon := Dialog confirm: 'Exit now?'.
		goSoon ifTrue: [exit value: 'Bye'].
		Transcript show: 'Not exiting'.
		'last value'] myValueWithExit.
Transcript show: val.
val
yes -> print Bye and return  Bye
no -> print Not Exiting 2 and return 2
\end{code}

\begin{code}{}
BlockClosure>>myValueWithExit
	      self value: [:arg| ^arg ].
      ^ '2'
BlockClosure>>myValueWithExit
 ^ self value: [:arg | ^ arg]        
\end{code}


\section{Lexical Closure}

\ja{english form must be verified}

Lexical closure is a concept introduced by SCHEME in 70s. Scheme uses lambda expression which is basically an anonymous function (such the block). But using anonymous function implies to connect it to the current execution context. \ja{please a verb}That why the lexical closure is important because it define when variables of block are bound to the execution context \ja{redo this sentence}. The variable is depending of the scope where it's \ja{no reduction in the text} define. Let's illustrate that :

\begin{code}{}
blockLocalTemp
	| collection |
		collection := OrderedCollection new.
		1 to: 3 do: [ :index || temp |
			temp := index. 
			collection add: [ temp ] ].
		^collection collect: [:each | each value].
\end{code}

Let's comment the code, we create a loop the store the arg value, in a temporary variable created in the loop (then local) and change it in the loop. We store a block containing the simply temp read access in a collection. And after the loop, we evaluate each block and return the collection of value.
If we evaluate this method that will return \#(1 2 3). What's happen? At each loop we create a variable existing locally and bind it to a block. Then at the end evaluate block, we evaluate each block with this contextual \emph{temp}. \ja{should be redone}

\begin{figure}[htbp]
	\centering
        \includegraphics[width=0.7\linewidth]{blockClosureLocalTemp}
	\caption{blockLocalTemp Execution}
	\label{fig:blockLocalTempExecution}
\end{figure}


\newpage
Now see another case : 
\begin{code}{}
blockOutsideTemp
		| collection temp |
		collection := OrderedCollection new.
		1 to: 3 do: [ :index | 
			temp := index. 
			collection add: [ temp ] ].
		^collection collect: [:each | each value].
\end{code}
Same case except the \emph{temp}, variable will be  declare in the upper scope. Then what will happen? Here the temp at each loop is the \textbf{same} shared variable bind. So when we collect the evaluation of the block at the end we will collect \#(3 3 3).
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.7\linewidth]{blockClosureOutsideTemp}
	\caption{blockOutsideTemp Execution}
	\label{fig:blockClosureOutsideTemp}
\end{figure}




When we look at the following Scheme expression and evaluate it you get 4. Indeed a binding is created 
which associates the variable index to the value 0. Then y a lambda expression is defined and it returns
 the variable index (its value). Then within this context another expression is evaluated which starts
with a begin statement: first the value of the variable index is set to 4. Second the lambda expression is 
evaluated. It returns then the value of the 

\begin{code}{}
(let* ((index 0)
       (y (lambda () index)))
  (begin
    (set! index 4)
    (y)))
\end{code}

\begin{code}{}
(let ((index 0))
  (let ((y (lambda () index)))
    (begin
      (set! index 4)
      (y))))
\end{code}

\begin{code}{}
((lambda (index)
   ((lambda () (begin 
                (set! index 4)
                index))))
 0)
\end{code}


What you see is that the lambda expression is sharing the binding (index 0) with expression \ct{(begin...)}
therefore when this binding is modify from the body of the begin expression, the lambda expression sees its impact
and this is why it returns 4 and not 0 because. 

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:


%| last |
%last := thisContext.
%thisContext runSimulated: [#(1 2 3) detect: [:e| e even]] contextAtEachStep: [:c| c ~~ last ifTrue: [Transcript print: c; cr; flush. last := c]]
%
%=>
%
%[] in UndefinedObject>>DoIt
%Array(Collection)>>detect:
%Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
% 
%
%or...
%
%
%| last home indent |
%last := nil.
%home := thisContext.
%indent := 0.
%thisContext
%	runSimulated: [#(1 2 3) detect: [:e| e even]]
%	contextAtEachStep:
%		[:c| | ctxt |
%		c ~~ last ifTrue:
%			[last := c.
%			 indent := 0. ctxt := c sender.
%			 [ctxt ~~ home] whileTrue:
%				[ctxt := ctxt sender. indent := indent + 1].
%			Transcript crtab: indent; print: c; flush]]
%
%[] in UndefinedObject>>DoIt
%	Array(Collection)>>detect:
%		Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%	Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
%

