% $Author: oscar $
% $Date: 2009-08-16 16:37:09 +0200 (Sun, 16 Aug 2009) $
% $Revision: 28477 $

% HISTORY:
% 2008-01-19 - Stef started
% 2008-12-26 - Jannik Laval added text
% 2011-20-05 - Jean baptiste Arnaud add some text (Lexical closure)
% 2011-07-01 - Jean baptiste Arnaud add some test (Storing a block)
% 2011-08-09 - Stef doing another pass
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng
% todo for stef explaining blockClosure environment representation + explaining the trick with the bytecodes
% 2012-01-27 - Integrated Ben Coman feedback

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Blocks: a Detailed Analysis}\chalabel{blocks}
\chapterauthor{Jean-Baptiste Arnaud}



Blocks (lexical closures) are a powerful and essential feature of Smalltalk. Without them it
would be difficult to have such a small and compact syntax. The use of blocks in Smalltalk
is the key to get conditionals and loops not hardcoded in the language syntax but just 
simple messages having blocks as arguments. This is why we can say that 
blocks work extremely well with the message passing syntax of Smalltalk.

In addition blocks are  effective to improve the readability, reusability and efficiency of code. 
However the dynamic runtime semantics of Smalltalk are often not well documented. Blocks in the presence of return statements behave like an escaping mechanism and while this can lead to ugly code when used to its extreme, it is important to understand it. 

In this chapter we will discuss some basic block behavior such as the notion of a static environment defined at block compile-time. Then we will present some deeper issues. But let us first recall some basics.

We already presented blocks in Pharo by Example. This presentation was simple and showing simply how to define blocks and to use them. Here we just will focus on deeper aspects and their run time behavior. 

\section{Basics}
What is a block? Historically, it's a Lambda expression, or an anonymous function. A block is a piece of code whose execution is frozen and kicked in using  specific messages.  Blocks are defined by square brackets. 

If you execute and print the result of the following block you will not get 3 but a block. 
\begin{code}[Block definition]{Block Definition}
[ 1 + 2 ]
    --> [ 1 + 2 ]
\end{code}

 A block is evaluated by sending the \mthind{BlockClosure}{value} message to it. More precisely blocks can be executed using \ct{value} (when no argument is mandatory), \ct{value:} (when one argument), \ct{value:value:}, \ct{value:value:value:}  and \ct{valueWithArguments: anArray}...). These messages are the basic and historical API for block execution. They were presented in Pharo by Example. 
 

\begin{code}[Block definition]{Block Execution}
[ 1 + 2 ] value  
    --> 3
    
[ :x | x + 2 ] value: 5
    --> 7
\end{code}

\subsection{Some handy extensions}
Pharo includes some handy messages such as \ct{cull:} and friends to support the execution of blocks even in presence of more values than necessary. This allows us to write blocks more concisely when we are not necessarily interested in all the available arguments.
\ct{cull:} fills the same need as  \ct{valueWith[Possible/Enough]Args:}, but does not require creating an Array with the arguments, and will raise an error if the receiver has more arguments than provided rather than pass nil in the extraneous ones. 
Hence, from where the block is provided, they look almost the same, but where the block is executed, the code is usually cleaner.

Here are some examples of \mthind{BlockClosure}{cull:} and  \ct{valueWithPossibleArgs:} usages.
\begin{code}{Cull: examples}
[ 1 + 2 ] cull: 5
	--> 3
[ :x | 1 + 2 + x ] cull: 5 
	--> 8
[ 1 + 2 ] cull: 5 cull: 6
	--> 3
[ :x | 1 + 2 + x ] cull: 5 
	--> 8
[ :x | 1 + 2 + x ] cull: 5 cull: 3	
	--> 8 
[ :x :y | 1 + y + x ] cull: 5 cull: 2 
	--> 8
[ :x :y | 1 + y + x ] cull: 5 
	~->raises an error mentioning that the block requires two arguments.
[ :x :y | 1 + y + x ] valueWithPossibleArgs: #(5) 
	~->leads to an error because nil is passed as arguments.	
\end{code}

The message \mthind{BlockClosure}{once} is another extension that caches the results until the receiver is uncached. A typical usage is the following one:

\begin{method}{Example for resources caching using once}
myResourceMethod
	^ [expression] once
\end{method}

Blocks are instances of class \ct{BlockClosure}. The table below lists some of the messages available on this class. 
\begin{description}
\item{\textsf{silentlyValue}} Execute the receiver but avoiding progress bar notifications to show up.

\item{\textsf{once}} Answer and remember the receiver value, answering exactly the same object in any further sends of once or value. The expression will be evaluated once and its result returned for any subsequent evaluations.
\end{description}

Some messages are useful to profile execution (more information on Chapter~\ref{cha:Profiler}: 

\begin{description}
\item{\textsf{bench}} Return how many times the receiver can get executed in 5 seconds. 

\item{\textsf{durationToRun}} Answer the duration (instance of Duration) taken to execute the receiver block.

\item{\textsf{timeToRun}} Answer the number of milliseconds taken to execute this block.
\end{description}


Some messages are related to error handling (as explained in the Exception Chapter~\ref{cha:exception}).

\begin{description}
\item{\textsf{ensure: aBlock}} Execute a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes.  
\item{\textsf{ifCurtailed: aBlock}} Evaluate the receiver with an abnormal termination action. Evaluate aBlock only if execution is unwound during execution of the receiver. If execution of the receiver finishes normally do not evaluate aBlock. 

\item{\textsf{on: exception do: aBlock}} Evaluate the receiver. If an exception \textsf{exception} is raised, executes the block \textsf{aBlock}.

\item{\textsf{on: exception fork: aBlock}} Execute the receiver. In case of exception, fork a new process, which will handle the error. The original process will continue running as if receiver evaluation finished and answered nil,\ie  an expression like: \textsf{[ self error: 'some error'] on: Error fork: [:ex |  123 ]} will always answer nil to the original process, not 123. The context stack, starting from context which sent this message to the receiver and up to the top of the stack will be transferred to the forked process, with handlerAction on top. When the forked process will resume, it will enter the block \textsf{aBlock}).
\end{description}


Some messages are related to process scheduling. We list the most important ones. Since this Chapter is not about concurrent programming in Pharo we will not go deep into them.

\begin{description}
\item{\textsf{fork}} Create and schedule a Process running the code in the receiver.

\item{\textsf{forkAt: aPriority}} Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process. 

\item{\textsf{newProcess}} Answer a Process running the code in the receiver. The process is not scheduled.
\end{description}





\section{Variables and Blocks}
A block can have its own temporaries variables, such variables are initialized during each block execution and are local to the block. Now the question we want to make clear is what is happening when a block refers to other (non local) variables. 

In Smalltalk, private variables (such as self, instance variables, method temporaries and arguments) are lexically scoped. These variables are bound (get a value associated to them) in the context in which the block that contains them is defined, rather than the context in which the block is executed.  We call the context in which a block is defined, the \emph{block home context} we will come back later to this concept. 
In essence a context, represent information about the current execution step (what is the context from which the current one is executed, what is the next byte code, what is the value of the temporary variables...) a context is an activation record representing a smalltalk execution stack element. 


Let's experiment a bit to understand how variables are bound in a blockt. Define a class named \ct{Bexp} (for BlockExperience) and the following methods:

\paragraph{Experience one.}\ 

\begin{code}{}
Bexp>>testVariable: aBlock 
	| t | 
	t := nil. 
	aBlock value 
	
Bexp>>testVariable 
	| t | 
	t := 42. 
	self testVariable: [ t logCr ] 
\end{code}

Execute \ct{Bexp new testVariable}. Executing the \ct{testVariable} message  prints 42 in the Transcript. The value of the temporary variable \ct{t} defined in method \ct{testVariable} is the one used rather than the one of \ct{t} defined inside \ct{testVariable:}. Even if the block is executed during the execution of the method \ct{testVariable:}.

The variable \ct{t} is not looked up in the context of the executing method \ct{testVariable:} but in the context of the method \ct{testVariable} which defined the block.

Figure~\ref{fig:variable} shows the execution of the expression \ct{Bexp new testVariable}. It shows that during the execution of method \ct{testVariable}, a block is created and this block refers to the method activation context (which holds temporaries variables for example) (step 1). When the block is executed in step 2 while executing the method testVariable: (in a different execution context), the non local variable t is looking in the home context of the block \ie the method context that created the block.

\begin{figure}[!h]
\begin{center}\includegraphics[width=9cm]{variable}
\caption{ Non local variable are looked in the method activation context where the block was created and not executed.\label{fig:variable}}
\end{center}
\end{figure}


\paragraph{Experience two. A block can change the value of a non local variable.}\ 
Now the method \ct{testVariable2} shows that non local variable value can be changed during the execution of a block. Executing \ct{Bexp new testVariable2} prints 33, since 33 is the last value of the variable \ct{t}.


\begin{code}{}
Bexp>>testVariable2 
	| t | 
	t := 42. 
	self testVariable: [ t := 33. t logCr ] 	
\end{code}

\paragraph{Experience Three. Accessing a shared non local variable.}\ 
Note that two blocks can share a non local variable. Let us define a new method \ct{testVariable3} as follows: 

\begin{code}{}
Bexp>>testVariable3 
	| t |	t := 42.	self testVariable: [ t logCr. t := 33. t logCr ].	self testVariable: [ t logCr. t := 66. t logCr ].	self testVariable: [ t logCr ]
\end{code}

\ct{Bexp new testVariable3} will print 42, 33, 33, 66 and 66.
Here the two blocks \ct{[ t := 33. t logCr ]} and \ct{[ t := 66. t logCr ]} access the variable \ct{t} and can modify it. During the first execution of the method \ct{testVariable:} its current value \ct{42} is printed, then the value is changed and printed. Similar situation occurs in the following block.

\paragraph{Experience Four. Storing a block.}\ 
The following example shows that the value of the variable is looked up at runtime. 
Here the initial value of the variable \ct{t} is 42. The block is created and stored into an instance variable but the value to \ct{t} is changed to 69 before the block is executed. And this is the last value (69) that is effectively printed because it is looked up at execution-time. Executing \ct{Bexp new testVariable4} prints 69.

\begin{code}{}
Object subclass: #Bexp
	instanceVariableNames: 'block'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BlockExperiment'
\end{code}

\begin{code}{}
Bexp>>testVariable4
	| t |
	t := 42.
	block := [ t logCr: t ].
	t := 69. 
	self testVariable: block
\end{code}






\paragraph{For method arguments.}\
Naturally we can expect that method arguments as well as self and instance variables are bound 
in the context of defining method. Let's illustrate these points now. 

\begin{code}{}
Bexp>>testScopeArgValue: aBlock
	| arg | 
	arg := 'zork'.
	aBlock value
	
Bexp>>testScopeArg: arg
	"self new testScopeArg: 'foo'"
	
	self testScopeArgValue: [arg crLog]
\end{code}

Now executing \ct{Bexp new testScopeArg: 'foo'} prints 'foo' even if in the method \ct{testScopeArgValue:} the temporary arg is redefined.
 
\sd{here}
\paragraph{self binding.}
For binding of self, we simply define a new class and a couple of methods. 
Add the instance variable x to the class \ct{Bexp} and define the \ct{initialize} method as follows:

\begin{code}{}
Object subclass: #Bexp
	instanceVariableNames: 'x'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BlockExperiment'
\end{code}

\begin{code}{}
Bexp>>initialize
    super initialize.
	x := 123.
\end{code}	

Define another class named \ct{Bexp2} (it can be a subclass of \ct{Bexp} since inheritance is orthogonal to what we want to show).


\begin{code}{}
Bexp2>>initialize
	super initialize.
	x := 69.

Bexp2>>testScopeSelf: aBlock
	aBlock value
\end{code}

Then define the methods that will invoke  methods defined in \ct{Bexp2}.
\begin{code}{}	
Bexp>>testScopeSelf: aBlock
	"Here we ask another class to execute the block"
	Bexp2 new testScopeSelf: aBlock
	
Bexp>>testScopeSelf
	"self new testScopeSelf"
	self testScopeSelf: [self traceCr: self printString ; traceCr: x]
\end{code}	

Now when we execute \ct{Bexp new testScopeSelf}. You get \ct{a Bexp123} printed, showing that a block captures self too, since an instance of Bexp2 executed the block but the printed object was the original Bexp instance. 

\paragraph{Another example of sharing.}

Non local variables referred to by a block continue to be accessible and shared with other expressions. Let us  take some examples. Define the following method \ct{foo} which defines a temporary variable \ct{a}.

\begin{code}{}
Bexp>>foo
	| a |
	[ a := 0 ] value.
	^ a
\end{code}

When we execute \ct{Bexp new foo}, we get 0 and not nil. 
Here what you see is that the value is shared between the method body and the block. Inside the method body we can access the variable whose value was set by the block execution. 
Both the method  and block bodies access to the temporary variable \ct{a}.

Now imagine that we define the method \ct{foo} as follows:

\begin{code}{}
Bexp>>foo
	| a |
	a := 0. 
	^ {[ a := 2] . [a]} 
\end{code}

The method \ct{foo} defines a temporary variable \ct{a}. It sets the value of \ct{a}
to zero and returns an array whose first element is a block setting the value to 2 and second element is a block just returning the value of the temporary variable. 

\begin{code}{}
| res | 
res := Bexp new foo.
res second value.
     --> 0
res first value.
res second
     --> 2
\end{code}

You can also define the code as follows and open a transcript to see the results.

\begin{code}
| res |
res := Bexp new foo.
res second value traceCr.
res first value.
res second value traceCr.
\end{code}

Let us step back and look at an important point. 
In the previous code snippet when the expressions \ct{res second value} and \ct{res first value} are executed, the method \ct{foo} has already finished its execution - as such it is not on the execution stack anymore.  Still the temporary variable \ct{a} can be accessed and set to new value. It means that the variables referred to by a block may live longer than the methods which created the block that refers to them. We say that the variables outlive their defining context. 

The block implementation needs to keep referenced variables in a structure that is not linked to the execution stack but lives in the heap. We will go in more details in a following section. 



\section{Returning from inside a block}
It is really not a good idea to have return statement in a block such as \ct{[^ 33]} that you pass or store into instance variables and we will explain why in this section. A block with explicit return statement is called a  non-local return block. 

\subsection{Basics on Return}
A return statement allows one to return a different value than the receiver of the message. In addition, when a return statement is defined in a method, the execution of a return statement exits the currently executed method and returns to its caller. This cancels the expressions following the return statement.

\begin{code}{}
Bexp>>testExplicitReturn
	self traceCr: 'one'.
	0 isZero ifTrue: [ self traceCr: 'two'. ^ self].
	self traceCr: 'not printed'
\end{code}

Executing \ct{Bexp new testExplicitReturn}  prints 'one' and 'two' but it will not print \ct{not printed}, since the method textExplicitReturn will have returned before.


In Smalltalk, \ct{^} should be the last statement of a block body. You should get a compile error if you type and compile the following expression. 

\begin{code}{}
[ self traceCr: 'two'.
  ^ self.  
  self traceCr: 'not printed' ]
  
    ~-> End of block expected ->
\end{code}


\subsection{Escape with Non Local Return}
A return expression behaves also like an escape mechanism since the execution flow will jump out to the current caller and not just one level up. For example, the following code will return 3 and 42 will never be reached. The expression \ct{[ ^3 ]} could be deeply nested, its execution jumps out all the levels. This is why it is important to avoid to use this style and use Exception when such behavior is needed. Some old code in Pharo predates exception introduction and returning blocks are passed around leading to complex flow and difficult to maintain code. In subsequent section we will carefully look at where a return is actually returning.

\begin{code}{}
Bexp>>foo
	#(1 2 3 4) do: [:each | 
					self traceCr: each printString. 
					each = 3 
						ifTrue: [^ 3]].						
	^ 42
\end{code}

Now to see that a return is really escaping the current execution. Let us build a slightly more complex call flow. 
We define four methods among which one creates an escaping block \ct{defineBlock} and one executes this block (\ct{arg2:}).

\begin{code}{}
Bexp>>start
	| res |
	self traceCr: 'start start'.
	res := self defineBlock.
	self traceCr: 'start end'.
	^ res
\end{code}

\begin{code}{}
Bexp>>defineBlock
	| res |
	self traceCr: 'defineBlock start'.
	res := self arg: [ self traceCr: 'block start'. 
                            1 isZero ifFalse: !\textbf{[}! ^ 33 !\textbf{]}!.
                            self traceCr: 'block end'. ].
	self traceCr: 'defineBlock end'.
	^ res
\end{code}

\begin{code}{}
Bexp>>arg: aBlock
	| res |
	self traceCr: 'arg start'. 
	res := self executeBlock: aBlock.
	self traceCr: 'arg end'. 
	^ res 
\end{code}

\begin{code}{}
Bexp>>executeBlock: aBlock
	| res |
	self traceCr: 'executeBlock start'.
	res := self executeBlock: aBlock value. 
	self traceCr: 'executeBlock loops so should never print that one'.
	^  res
\end{code}


Executing \ct{Bexp new start}  prints the following (we added indentation to stress the calling flow).

\begin{code}{}
start start
   defineBlock start
      arg start
         executeBlock start
            block start
start end
\end{code}

What we see is that the calling method \ct{start} is fully executed. The method \ct{defineBlock} is not completely executed. Indeed, its escaping block \ct{[^33]} is executed two calls away in the method \ct{executeBlock:}. The execution of the block returns to the sender of the block home context. 
Indeed the block should return and it will return to the method context of its home context. Here the home context of the block is the execution context of the method \ct{defineBlock}. The sender of this execution was created by the execution of the method \ct{start}, therefore the return execution returns to the execution point of the start execution context.

When the return statement of the block is executed in method \ct{executeBlock:}, the execution discards the pending computation and returns to the method execution point that created the home context of the block. The block is defined in  method \ct{defineBlock}, the home context of the block is the activation context that represents the execution of the method \ct{defineMethod}. This is why the rest of the computation in the block itself, the \ct{defineMethod} method as well as \ct{arg:} are discarded. 

As shown by Figure~\ref{nonLocalReturn}, \ct{[^3]} will return to the sender of its home context. \ct{[^33]} home context is the context that represents the execution of the method \ct{defineBlock}, therefore it will return its result to the method \ct{start} execution.

\begin{figure}[!h]
\begin{center}\includegraphics[width=9cm]{nonLocalReturn2}
\caption{A block with non local return execution returns to the method execution that activated the block home context.\label{nonLocalReturn}}
\end{center}
\end{figure}


\paragraph{Accessing information.}
To verify manually and find the home context of a closure we can do the following: add the expression \ct{thisContext home inspect} in the block of the  method defineBlock. We can also add the expression \ct{thisContext closure home inspect} which accesses the closure via the current execution context and gets its home context. Note that in both cases, even if the block is executed during the execution of the method \ct{executeBlock:}, the home context of the block is the method \ct{defineBlock}. 


\begin{code}{}
Bexp>>defineBlock
	| res |
	self traceCr: 'defineBlock start'.
	res := self arg: [ thisContext home inspect.self traceCr: 'block start'. 
                            1 isZero ifFalse: !\textbf{[}! ^ 33 !\textbf{]}!.
                            self traceCr: 'block end'. ].
	self traceCr: 'defineBlock end'.
	^ res
\end{code}

To verify where the execution will end you can use the expression \ct{thisContext home sender copy inspect. } which returns an method context pointing to the assignment of the method \ct{start}.

\paragraph{Couple more examples.}
The following examples shows that escaping blocks jumped to their home context but do not unwind the stack after this point. For example the previous example shows that the method \ct{start} was fully executed. 
\ct{valueWithExit} is defined on the class BlockClosure as follows.

\begin{code}{}
BlockClosure>>valueWithExit 
	  self value: [ ^nil ]
\end{code}

\begin{code}{}
Bexp>>assert: aBoolean
	aBoolean ifFalse: [Error signal]

Bexp>>testValueWithExitBreak
	| val |
	[ :break |
	    1 to: 10 do: [ :i |
			val := i.
			i = 4 ifTrue: [break value].
		] 
	] valueWithExit.
	self assert: val = 4.
\end{code}

The method \ct{testValueWithExitBreak} shows that the block \ct{break} is created and activated once and as effect it cancels the rest of the computation. 

The following method \ct{testValueWithExitContinue} shows that just the computation left from the block activation is skipped (here \ct{val := val + 1.	last := i}, when i = 4) and this is why the value of \ct{val} is 9 and not 10. 
In this example, a new block is created 


\begin{code}{}
Bexp>>testValueWithExitContinue
	| val last |	
	val := 0. 
	1 to: 10 do: [ :i |
		[ :continue |
			i = 4 ifTrue: [continue value].
			val := val + 1.
			last := i
		] valueWithExit.
	].
	self assert: val = 9.
	self assert: last = 10.	
\end{code}

Pay attention here \ct{valueWithExit} is not equivalent to \ct{value: [^nil]} because it changes the home context of the block. 
In the first case the homeContext of the block is not the method \ct{testValueWithExitContinue} while in the second it is.
Put a self halt before the assert: to convince you. In one case, you will reach the halt while in the other not. 







\sd{restarted here}
Block temporary variables are local to the blocks. For example


\begin{code}{}
|b|
b := [ :p |
	| t |
	t ifNil: [ t := p ].
	t ].
{ b value: 1. b value: 2 }.
   -->  #(1 2)
\end{code}

You get \ct{#(1 2)} because \ct{t} is a block local variable. Its value is initialized during each block execution.

\sd{until here}



\section{Opening the Trunk}

The Virtual Machine represents the state of execution as context objects, one per method or block currently executed (or activated). In Pharo method and block activations are represented by MethodContext.
Contexts are first-class activation record.

aContext contains a reference to the context from which it is invoked, the receiver arguments, temporaries in the Context

We call the home context, the activation record or context in which a block is defined.

Arguments, temporaries, instance variables are lexically scoped in Smalltalk. These variables are bound in the context in which the block is defined and not in the context in which the block is evaluated.

\subsection{Handling Temporary Variables}
\sd{to rewrite}
Temporary Variables.
 Temporary variables are created for a particular execution of a CompiledMethod and cease to exist when the execu- tion is complete. The CompiledMethod indicates to the interpreter how many temporary variables will be required. The arguments of the in- voking message and the values of the temporary variables are stored to- gether in the temporary frame. The arguments are stored first and the temporary variable values immediately after. They are accessed by the same type of bytecode (whose comments refer to a temporary frame lo- cation). Since merge: takes a single argument, its two temporary vari- ables use the second and third locations in the temporary frame. The compiler enforces the fact that the values of the argument names can- not be changed by never issuing a store bytecode referring to the part of the temporary frame inhabited by the arguments.


When a message is sent, all five parts of the in-terpreter's state may have to be changed in order to execute a different CompiledMethod in response to this new message. The interpreter's old statemust be remembered because the bytecodes after the send must be executed after the value of the message is returned.
The interpreter saves its state in objects called contexts. There will be many contexts in the system at any one time. The context that rep- resents the current state of the interpreter is called the active context. When a send bytecode in the active context's CompiledMethod requires a new CompiledMethod to be executed, the active context becomes sus- pended and a new context is created and made active. The suspended context retains the state associated with the original CompiledMethod until that context becomes active again. A context must remember the context that it suspended so that the suspended context can be resumed when a result is returned. The suspended context is called the new con- text's sender.




\section{Method Execution}
Before going into the details of block handling, we will have a look at the way methods are executed. Imagine that we have 
a simple method 

\begin{code}{}
Bexp>>first: arg
	| temp | 	
	temp := arg * 2.
	^ temp
\end{code}

We can easily imagine that when such method is invoked multiple times with different arguments, we need a way to keep 
the value of the argument \ct{arg} and the temporary variable \ct{temp}. In addition, the instruction or program counter (the index saying what is the next instruction) can hold different values depending on the execution state and location. Therefore, there is a need to represent such information. Literature calls it a context. A Smalltalk interpreter needs five information to represent its current execution state:
\begin{enumerate}
\item The CompiledMethod whose bytecodes are being executed.
\item The location of the next bytecode to be executed in that
CompiledMethod. This is the interpreter's instruction pointer.
\item The receiver and arguments of the message that invoked the
CompiledMethod.
\item Any temporary variables needed by the CompiledMethod.
\item A stack.
\end{enumerate}



In Pharo, the class \ct{MethodContext} represents such execution information. Instances of \ct{MethodContext} hold information about a specific execution point and we can obtain them using the pseudo-variable \ct{thisContext}.

Let us look at an example. Modify the method as follow and execute it using \ct{Bexp new first: 33}. 
You will get the inspector shown in Figure~\ref{oneContext}.

\begin{code}
Bexp>>first: arg
	| temp | 	
	temp := arg * 2.
	thisContext copy inspect.
	^ temp
\end{code}

Note that we copy the current context obtained using \ct{thisContext} because the Virtual Machine reuses contexts to avoid their creation when not necessary and it nilles out some values such as the temp value.

\begin{figure}[!h]
\begin{center}\includegraphics[width=5cm]{oneContext}
\caption{A method context where we can access the value of the temporary variable \ct{temp} at that given point of execution.\label{oneContext}}
\end{center}
\end{figure}

\ct{MethodContext} does not only represent activation context of method execution but also 
the ones for block closures as we will see later. Let us have a look at some value of the current context:

\begin{itemize}
\item \ct{sender} points to the previous context that led to the creation of the current context. Here when you executed the expression, a context was created and this context is the sender of the current one. 

\item \ct{pc} holds the value of the last executed instruction. Here its value is 27. To see which instruction it is, double click on the method instance variable and select the all bytecodes field, you should obtain the situation depicted in Figure~\ref{ByteCodes}, which shows that the next instruction to be executed is pop \sd{is it true?}

\item \ct{stackp} defines the number of stored temporary variables and 

\item \ct{method} points to the currently executed method.

\item \ct{closureOrNil} holds a reference to the closure currently executed or nil.

\item \ct{receiver} is the message receiver.
\end{itemize}


\begin{figure}[!h]
\begin{center}\includegraphics[width=5cm]{ByteCodes}
\caption{The last instruction executed was the message send \ct{inspect}.\label{ByteCodes}}
\end{center}
\end{figure}




\begin{figure}[!h]
\begin{center}\includegraphics[width=8cm]{TwoContexts}
\caption{Two contexts at different execution points.\label{ByteCodes}}
\end{center}
\end{figure}

Using the following definition you can get two inspectors open on a copy of the context
at the execution point. 
\begin{code}
Bexp>>first: arg
	| temp | 	
	temp := arg * 2.
	thisContext copy inspect.
	temp := arg * 3.
	thisContext copy inspect.
	^ temp
\end{code}

\subsection{Studying Contexts}
Methods arguments and temporaries are stored in contexts. Contexts have a variable part that 
store them. 

When inspecting the following method, stackp holds 3 to represent that there is one argument
and two temporary variables.

\begin{code}{}
Bexp>>twoTempsOneArg: arg
	"self new twoTempsOneArg: 33"
	| temp1 temp2 | 	
	temp1 := temp2 := arg.
	thisContext inspect.
	^ temp1
\end{code}


\begin{code}{}
ContextPart>>arguments
	"returns the arguments of a message invocation"
	
	| arguments numargs |
	numargs :=  self method numArgs.
	arguments := Array new: numargs.
	1 to: numargs do: [:i | arguments at: i put: (self tempAt: i) ].
	^ arguments
\end{code}






\subsection{Invoking Another Method}
\begin{code}{}
Bexp>>first: arg

	| temp | 	
	temp := arg *2.
	thisContext inspect.
	self second: temp.

Bexp>>second: arg2
	
	self halt.
	^ arg2
\end{code}

In the inspector, you can access the temporary variable of method first: using the expression self tempNamedAt: 'arg'







\subsection{Contexts}
\sd{I should reshuffle that part later}

Contexts are objects representing a given execution state also called activation record, like a C stack represents execution of a C program. Contexts maintain the program counter and stack pointer, holding pointers to the sending context, the method for which this is appropriate, etc. MethodContext represents an executing method, it points back to the context from which it was activated, holds onto its receiver and compiled method. 

\begin{figure}
\begin{center}
\includegraphics[width=8cm]{MethodAndMethodContext}
\end{center}
\end{figure}

To send a message to a receiver, the VM has to:

\begin{enumerate}
\item find the class of the receiver using the receiver object's header.
\item lookup the method in the class methodDictionary.
\item if the method is not found, repeat this lookup in superclasses.
When no class in the superclass chain can understand the message, send the message doesNotUnderstand: to the receiver so that the error can be handled in a manner appropriate to that object.

\item extract the appropriate CompiledMethod from the MethodDictionary where the message was found and then 
\begin{enumerate}
\item check for a primitive associated with the method by reading the method header
\item if there is a primitive, execute it.
\item if it completes successfully, return the result object directly to the message sender.
\item otherwise, continue as if there was no primitive called.
\end{enumerate}
\item Create a new activation record. Set up the program counter, stack pointer,
home contexts, then copy the arguments and receiver from the message sending context's stack to the new stack.

\item Activate that new context and start executing the instructions in the new method.
\end{enumerate}


\section{Closures}


\begin{code}{}
#(1 2 3) inject: 0 into: [:sum :each | sum + each]
\end{code}

\begin{code}{}
inject: thisValue into: binaryBlock
	"Accumulate a running value associated with evaluating the argument, 	
	binaryBlock, with the current value of the argument, thisValue, and the 
	receiver as block arguments. For instance, to sum the numeric elements of a 
	collection, aCollection inject: 0 into: [:subTotal :next | subTotal + next]."
	| nextValue |
	nextValue := thisValue.
	self do: [:each | nextValue := binaryBlock value: nextValue value: each]. 	^ nextValue
\end{code}






\section{To be treated}

\begin{code}{}
|b| 
b:= [:x| Transcript show: x. x].
b value: a. b value: b.
b:= [:x| Transcript show: x. ^x].
b value: a. b value: b.
\end{code}
 
Non local returning blocks cannot be executed several times!

\begin{code}{}
Test>>testScope
	   |t|
    	t := 15.
	   self testBlock: [Transcript show: "--",t printString, "--".
	   ^35 ].
    ^ 15

Test>>testBlock:aBlock
	   |t|
	   t := 50.
	   aBlock value.
	   self halt.
\end{code}

\begin{code}{}
Test new testBlock 	
print: *15* and not halt. 
return: 35
\end{code}


\begin{code}{}
|val|
val := [:exit |
		|goSoon|
		goSoon := Dialog confirm: 'Exit now?'.
		goSoon ifTrue: [exit value: 'Bye'].
		Transcript show: 'Not exiting'.
		'last value'] myValueWithExit.
Transcript show: val.
val
yes -> print Bye and return  Bye
no -> print Not Exiting 2 and return 2
\end{code}

\begin{code}{}
BlockClosure>>myValueWithExit
	      self value: [:arg| ^arg ].
      ^ '2'
BlockClosure>>myValueWithExit
 ^ self value: [:arg | ^ arg]        
\end{code}


\section{Lexical Closure}

Lexical closure is a concept introduced by SCHEME in 70s. Scheme uses lambda expression which is basically an anonymous function (such the block). But using anonymous function implies to connect it to the current execution context. This  why the lexical closure is important because it define when variables of block are bound to the execution context \ja{redo this sentence}. The variable is depending of the scope where it's \ja{no reduction in the text} define. Let's illustrate that :

\begin{code}{}
blockLocalTemp
	| collection |
		collection := OrderedCollection new.
		1 to: 3 do: [ :index || temp |
			temp := index. 
			collection add: [ temp ] ].
		^collection collect: [:each | each value].
\end{code}

Let's comment the code, we create a loop the store the arg value, in a temporary variable created in the loop (then local) and change it in the loop. We store a block containing the simply temp read access in a collection. And after the loop, we evaluate each block and return the collection of value.
If we evaluate this method that will return \#(1 2 3). What's happen? At each loop we create a variable existing locally and bind it to a block. Then at the end evaluate block, we evaluate each block with this contextual \emph{temp}. 

\begin{figure}[htbp]
	\centering
        \includegraphics[width=0.7\linewidth]{blockClosureLocalTemp}
	\caption{blockLocalTemp Execution}
	\label{fig:blockLocalTempExecution}
\end{figure}

Now see another case : 
\begin{code}{}
blockOutsideTemp
		| collection temp |
		collection := OrderedCollection new.
		1 to: 3 do: [ :index | 
			temp := index. 
			collection add: [ temp ] ].
		^collection collect: [:each | each value].
\end{code}
Same case except the \emph{temp}, variable will be  declare in the upper scope. Then what will happen? Here the temp at each loop is the \textbf{same} shared variable bind. So when we collect the evaluation of the block at the end we will collect \#(3 3 3).
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.7\linewidth]{blockClosureOutsideTemp}
	\caption{blockOutsideTemp Execution}
	\label{fig:blockClosureOutsideTemp}
\end{figure}


When we look at the following Scheme expression and evaluate it you get 4. Indeed a binding is created 
which associates the variable index to the value 0. Then y a lambda expression is defined and it returns
 the variable index (its value). Then within this context another expression is evaluated which starts
with a begin statement: first the value of the variable index is set to 4. Second the lambda expression is 
evaluated. It returns then the value of the 

\begin{code}{}
(let* ((index 0)
       (y (lambda () index)))
  (begin
    (set! index 4)
    (y)))
\end{code}

\begin{code}{}
(let ((index 0))
  (let ((y (lambda () index)))
    (begin
      (set! index 4)
      (y))))
\end{code}

\begin{code}{}
((lambda (index)
   ((lambda () (begin 
                (set! index 4)
                index))))
 0)
\end{code}


What you see is that the lambda expression is sharing the binding (index 0) with expression \ct{(begin...)}
therefore when this binding is modify from the body of the begin expression, the lambda expression sees its impact
and this is why it returns 4 and not 0 because. 


\section{Notes from eliot blog}



- way to control execution -> block closures
- way to store arg and temp -> method context
- a way of accessing locals in enclosing block or method activations
but to implement access to locals in enclosing activations without access through those activations.








\subsection{Different blocks} 

\sd{should say something about that.}
\paragraph{Non-local return blocks.} \ct{[:x :y| x*x. ^ x + y]} returns the value to the method that activated its homeContext. As a block is always evaluated in its homeContext, it is possible to attempt to return from a method which has already returned using other return. This runtime error condition is trapped by the VM.

\begin{code}{}
Object>>returnBlock
	"self new returnBlock value -> error"

	^[^self]

Object new returnBlock
-> Exception
\end{code}	
	
	












%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:


%| last |
%last := thisContext.
%thisContext runSimulated: [#(1 2 3) detect: [:e| e even]] contextAtEachStep: [:c| c ~~ last ifTrue: [Transcript print: c; cr; flush. last := c]]
%
%=>
%
%[] in UndefinedObject>>DoIt
%Array(Collection)>>detect:
%Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(SequenceableCollection)>>do:
%[] in Array(Collection)>>detect:ifNone:
%[] in [] in UndefinedObject>>DoIt
%SmallInteger>>even
%[] in [] in UndefinedObject>>DoIt
%[] in Array(Collection)>>detect:ifNone:
%Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
% 
%
%or...
%
%
%| last home indent |
%last := nil.
%home := thisContext.
%indent := 0.
%thisContext
%	runSimulated: [#(1 2 3) detect: [:e| e even]]
%	contextAtEachStep:
%		[:c| | ctxt |
%		c ~~ last ifTrue:
%			[last := c.
%			 indent := 0. ctxt := c sender.
%			 [ctxt ~~ home] whileTrue:
%				[ctxt := ctxt sender. indent := indent + 1].
%			Transcript crtab: indent; print: c; flush]]
%
%[] in UndefinedObject>>DoIt
%	Array(Collection)>>detect:
%		Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%			Array(SequenceableCollection)>>do:
%				[] in Array(Collection)>>detect:ifNone:
%					[] in [] in UndefinedObject>>DoIt
%						SmallInteger>>even
%					[] in [] in UndefinedObject>>DoIt
%				[] in Array(Collection)>>detect:ifNone:
%	Array(Collection)>>detect:
%[] in UndefinedObject>>DoIt
%


\section{Chapter conclusion}


We want to thank Ben Coman for his english corrections and Eliot Miranda for the discussions and explanations about his implementation of fast closure for Squeak and Pharo.
