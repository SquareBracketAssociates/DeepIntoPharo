% $Author: luc $
% $Date: 2010-08-01 13:46:12 +0100 $
% $Revision: 0 $

% HISTORY:
% 2010-08-01 - Luc
%% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================


\newcommand{\Spock}[0]{Spock } %could be alius
\chapter{Calling Foreign Code with Spock}\label{cha:alien}


Interacting with the external world is a mandatory element of modern systems. Been able to call libraries is often a key success to business. In this chapter, we will explain you how to do that in Pharo using Foreign Function Interface. 

%Despite of our aim of doing as much as possible directly in Smalltalk (as deeper as the virtual machine itself cf. ChapXX), it is still required in some special cases to call external code written in other languages and compiled in a binary library.

Suppose you want to use OpenGL in Pharo. %Then you will face a problem, because the OpenGL libraries
%only know about C and nothing about Smalltalk. 
The solution is to make a \emph{binding} of each C library function to a Smalltalk method,  and then to call these methods from Smalltalk code. But we should answer several questions: how does a binding call a 
C function? How do you write such binding? How do we pass heap allocated objects? The libraries and mechanisms in charge of doing this kind of work are usually called FFI, for Foreign Function Interface. In this chapter we will help you to use this interface by exposing some practical examples of
how to solve common problems faced when communicating with other languages.

%There are other possibilities: imagine that you want
%to optimize some piece of code. In the first approach,
%of course, you would try to make it more efficient by
%using a better algorithm, but that may not be enough.
%Then you may encounter the need of writing code in a
%lower level language that is more CPU efficient. In
%that case, you may ask, which is the way to communicate
%the high-level smalltalk world with the low level one?

Just to mention, there is another possible approach that would be to invoke C libraries by defining a specific plugin for the virtual machine, but it's more complex and it offers no important advantage compared to the results of using bindings in the same language and with the same constructions you are used to.

We will start to show you how to use \Spock, a new foreign function library. \Spock is based on NativeBoost and previous FFI libraries.\luc{Alien and FFI. cite them here no?}


\section{Getting Started}

\luc{Before the section ``calling Ext func'', I think we should first introduce the basics (part of the old ``What is a FFI and how it works?'' section). Because the reader will want to test while reading. And for that he probably will need a special VM (NativeBoost VM), an image with NativeBoost inside, ... }


Right now to run Spock, the new FFI library described in this chapter, you will need a vm that has the NativeBoost plugin and  you can find one at \url{https://ci.lille.inria.fr/pharo/job/NB-Cog-Mac-Carbon/}.  

Then you should load in your image, the package \ct{NativeBoost-Installer} that you can load as follows:
\begin{code}{}
Gofer it
        squeaksource: 'NativeBoost';
        package: 'NativeBoost-Installer';
        load.
\end{code}

Once loaded you should execute the following expression: \ct{NBInstaller install.}


%\begin{description}
%\item [C header.] \ 
%
%\begin{code}{}
%
%\end{code}
%
%\item [Pragma declaration.] \ 
%
%\begin{code}{}
%
%\end{code}
%
%
%\item [Library access.] \ 
% 
%\dothis{ }
%
%\end{description}


\section{Calling External Functions}

Suppose you want to know the amount of time the image has been running by calling the underlying OS function named \ct{clock}. 
This function is part of the standard C library. Its C declaration is\footnote{According to man its return type is clock\_t instead of int, but we deliberately made it int for the sake of simplicity. \sd{how would we deal with that if we do not want/can change clock\_t into int?}}:

\begin{code}{}
int clock (void)
\end{code}

To call \ct{clock} from the image, you will write a binding, which is a normal method with a \ct{<primitive:module:>} pragma. This pragma describes the signature of the C function. Here is the definition. We  explain below the details.

\begin{code}{}
CExamples class>>ticksSinceStart
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	
	^ NBFFICallout cdecl: #( int clock () ) module: NativeBoost CLibrary
\end{code}


\sd{Igor in 1.4 I get a vmVersion -> deprecated.}

You can define this method in any class, on its instance or class side.
It doesn't make any difference. In the above example, we defined a class named \ct{CExamples} and define the methos on its class side. This way it is easy to access it by sending a message to this class without creating unnecessary instances. 

Then, to know the time since the program started you can execute and print it.
But of course, these are just the native clock ticks, which aren't of much use. 
\begin{script}{Invoking a C binding}
CExamples ticksSinceStart
\end{script}

What we have just done is usually called an FFI callout. 
\ct{NBFFICallout} is the class that represents this behavior, which is essentially a call to an external function.
We use the the  message \ct{#cdecl:module:} to describe this call. 
This message has two arguments: the signature of the function that is about to be called and the module (or library) where to look for it which is the standard C library in this example. 
The signature is described by an array whose first element is the C return type and the second is the name of the called function.
The third and last element is also an array which describe the arguments of the function when there's any. 

Notice that the return type is \ct{int} and not \ct{SmallInteger}. 
This is the same with function arguments. 
They are all describe in terms of C language.
But you don't have to bother with this because the \Spock library does an automatic conversion between C types and Smalltalk types.
So, when this message is executed, the return value will be a \ct{SmallInteger}. 
This conversion process for types from different languages is called \emph{marshaling}.
We will see more examples of automatic conversions in this chapter. 

As you will
see later there are always three things to take into account when doing
callouts:

\begin{description}
\item [C header.] The definition of the function from a C point of view. In the last example:

\begin{code}{}
int clock (void)
\end{code}

\item [Pragma declaration.] The Smalltalk code that describes the C header and `binds' Smalltalk arguments to C arguments. In this case it was:

\begin{code}{}
CExamples class>>ticksSinceStart

<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	
^ NBFFICallout cdecl: #( int clock () ) module: NativeBoost CLibrary
\end{code}


\item [Library access.] Finally, there is the code that sends the message to use the binded C function. In this case, 

\dothis{CExamples ticksSinceStart}



\end{description}


Now, lets look at another example, and to make it more interesting lets call the very well known \ct{strlen} function, which receives a string as argument and returns the amount of characters it has. 


\begin{description}
\item [C header.] \ 

\begin{code}{}
int strlen ( const char * str );
\end{code}

\item [Pragma declaration.] \ 

\begin{code}{}
CExamples class>>stringLength: aString

	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	
	^ NBFFICallout cdecl: #( int strlen (char* aString) ) module: NativeBoost CLibrary
\end{code}


\item [Library access.] \ 
 
\dothis{CExamples stringLength: 'awesome!'}

\end{description}



Can you see the small differences with the previous example? 
First of all, in this case we are specifying \ct{strlen}
instead of clock, of course. But besides that, the only
change is that we have to specify the string passed
as argument. That is, in the arguments array, we
put the C type of the argument, and after that,
the name of the Smalltalk variable we are going to send as 
argument. This type-and-name pair will be repeated, separated 
by comma for each argument, as we will show in the next
example. Now you can try printing this:

\dothis{CExamples stringLength: 'awesome!'.}

Before getting into the next example, two little things
needs to be clarified. The first is that there is a small
difference between the C signature and the signature we are
providing in the Smalltalk array. This difference is 
the const keyword of the argument. For those not used to C, 
that's only a modifier keyword that the compiler take advantage
of to make some static validations at compile time. It's has no
value when describing the signature for calling a function at
runtime.
The second important thing to notice is that as argument we are providing
the object {\sffamily aString}, the same as the one receive as Smalltalk argument.
This is really necessary as we are not only describing the signature
but we are also describing which objects we will send to the C 
function as arguments so to receive the expected result.
It is important to remark again that \Spock will take care of automagically
doing the conversion of the arguments, which come from Smalltalk
world, to C values. \emph{This means
that the string passed in the example is going to be put in an
external C \ct{char} array and that a null termination character will be
added to it. Also, this array will be automatically released 
after the call ends}. Conversely, Spock will take the C result
value of calling the C function and convert it to a proper Smalltalk
object, a String in this particular case.



To continue with the examples we will call \ct{strcmp}, which takes two arguments and returns -1, 0 or 1 depending on the relationship between both strings.

\begin{description}
\item [C header.] \ 

\begin{code}{}
int strcmp ( const char * str1, const char * str2 );
\end{code}

\item [Pragma declaration.] \ 

\begin{code}{}
stringCompare: aString with: anotherString

	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	
	^ NBFFICallout cdecl: #( int strcmp (char* aString, char* anotherString) ) module: NativeBoost CLibrary
\end{code}


\item [Library access.] \ 
 
\dothis{CExamples stringCompare: 'awesome!' with: 'awesome'}

\end{description}

Notice that you can add arguments by appending them to the arguments array,
using a comma to separate them. Also notice that you have to explicitly tell
which object is going to be send for each argument as already told. In this case, aString is
the first one and anotherString is the second.

The next example adds a bit more complexity: we are going to send a ByteArray
to the memset function. 

\begin{description}
\item [C header.] \ 

\begin{code}{}
void * memset ( void * ptr, int value, int num );
\end{code}
Sets the first num bytes of the block of memory pointed by ptr to the specified value

\item [Pragma declaration.] \ 

\begin{code}{}
memorySet: aByteArray with: anInteger for: aByteCount

	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	
	^ NBFFICallout cdecl: #( void* memset (char* aByteArray, int anInteger, int aByteCount) ) module: NativeBoost CLibrary
\end{code}


\item [Library access.] \ 
 
\dothis{ 
\\array := ByteArray new: 10.\\
CExamples memorySet: array with: 100 for: 5.\\
array}

\end{description}

As you should notice, this time Spock takes care of finding out the memory address where aByteArray lives and sends a pointer to it as the first argument. After executing the example you can see that the byte array elements were actually changed. This is an important difference with strings. The expertise user would notice that string functions in c language expects to receive a pointer to contiguos memory bytes ending with a null character to delimit its length. \Spock is responsible for copying the string to a bigger buffer and insterting this special end character. This means that strings are passed by-copy, while on the other hand byte arrays are passed by reference!. Also for expertise users, you may notice that in this last example, as sending a reference, we are sending to a native library a pointer to an object that lives in Smalltalk's memory. We already know that Smalltalk's memory is auto cleaned by a garbage collector that potentially move the objects to other places, so we have to be carefull about this special behavior. At the moment this book is written the FFI library doesn't support asyncronics calls so strange behavior is not possible, but we have to be very carefull when facing with c pointer arguments to Smalltalk's memory.

\subsection{More advanced examples}

\subsubsection{Loading code from other libraries}

\subsubsection{Using C structures}

% \section{The levels of native code}
% 
% In Pharo there are many levels where native code
% can live. Some of this code forms part of the
% Virtual Machine itself, so it's actually Slang code
% that gets converted to C and then compiled. It is a
% bit static because changing this code would mean to
% regenerate and recompile the whole Virtual Machine.
% A work around this are \emph{plugins}, which are also
% written in Slang and can be thought as extensions to
% the Virtual Machine that don't require recompiling
% the whole virtual machine after each change. Unfortunatelly,
% they aren't much dynamic either because, after each
% change.
% part of the 
% 
% The simplest and most
% used form of native code is the implementation
% of each byte-code. For each byte-code there 
% exists a bunch of Slang code which, after being
% converted to C, is compiled to machine code and
% put into the VM executable. Of course, there
% aren't many byte-codes left free for use, and
% the existing ones have been very well thought so
% there is little chance that you may want to
% write native code for a byte-code.
% 
% Next in the level of 


\subsection{original FFI stuff}

Thanks to a Foreign Function Interface (FFI), it is possible to achieve this and interact with third-party libraries.
Multiple FFI libraries are available in Pharo such as FFI (\url{http://wiki.squeak.org/squeak/1414}) and Alien (\url{http://www.squeaksource.com/Alien}).
As an example the dynamic \texttt{OpenGL} library (.dll, .so or .dylib depending on the operating system) is used in Croquet through the FFI library and AlienOpenGL (\url{http://www.squeaksource.com/AlienOpenGL}) use it through the Alien library.

In this chapter, we will describe what is a FFI library and how it works with the virtual machine. 
We will then dive into the Alien library and learn how it can be used thanks to the AlienOpenGL example.

\section{What is a FFI and how it works?}

The Pharo image is loaded and executed by a virtual machine (VM) which is itself executed on the top of the operating system. 
Two different virtual machines can be used for Pharo images: the squeak VM and the Cog VM.
Regarding the general FFI mechanism, it is not really relevant to make a distinction\footnote{It worth noting that the Cog VM is younger and really faster than the Squeak VM but it still presents some small limitations and bugs at the time writing this book.} 
Both are based on a plugin architecture.
A plugin enable the Smalltalk code (in the image) to access third-party functionalities (outside the image and the VM).

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.4\linewidth]{figs/plugins.pdf}
	\caption{Pharo Architecture}
	\label{fig:plugins}
\end{figure}

The Alien library uses the \emph{IA32ABI} plugin which ....



\section{Using the Alien Library} \label{sec:the_alien_library} % (fold)

\subsection{Installation} \label{sec:installation} % (fold)

Alien is a Squeaksource project \url{http://www.squeaksource.com/Alien}. 
Use the following code to install Alien in a Pharo 1.1 image:

\begin{code}{}
Gofer new
	url: 'http://www.squeaksource.com/Alien' ;
	package: 'ConfigurationOfAlien';
	load.

(Smalltalk at: #ConfigurationOfAlien) loadCore ; 
	loadTests ; 
	loadLibC.
\end{code}

Run the tests to ensure that Alien is well installed and that the VM plugin is correctly working.

\subsection{First example} \label{subsec:first_example} % (fold)




\subsection{Core Classes} 

Figure~\ref{fig:alien_uml} shows an UML diagram of the Alien-Core package that contains the main classes of this library.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.9\linewidth]{figs/alien_uml}
	\caption{Core classes of the Alien library}
	\label{fig:alien_uml}
\end{figure}



\subsection{Memory management} \label{sec:memory_management} % (fold)


\subsection{Calling an external C library from Smalltalk} \label{sec:calling_an_external_c_library_from_smalltalk} % (fold)


\subsection{Callbacks from C to Smalltalk code} \label{sec:callbacks_from_c_to_smalltalk_code} % (fold)





\section{Dissection of Alien} \label{sec:dissection_of_alien} % (fold)


\paragraph{Alien}
% copy/past from class comment
% Instances of the Alien class represent actual parameters, return results and function pointers in FFI call-outs and call-backs and provide handles on external data.  See NewsqueakIA32ABIPlugin for the VM code that actually implements call-outs and call-backs.
% 
% 	See the class-side examples category for some simple example workspaces.
% 
% 	Aliens represent ABI (C language) data.  They can hold data directly in their bytes or indirectly by pointing to data on the C heap.  Alien instances are at least 5 bytes in length. The first 4 bytes of an Alien hold the size, as a signed integer, of the datum the instance is a proxy for.  If the size is positive then the Alien is "direct" and the actual datum resides in the object itself, starting at the 5th byte.  If the size is negative then the proxy is "indirect", is at least 8 bytes in length and the second 4 bytes hold the address of the datum, which is assumed to be on the C heap.  Any attempt to access data beyond the size will fail.  If the size is zero then the Alien is a pointer, the second 4 bytes hold a pointer, as for "indirect" Aliens, and accessing primitives indirect through the pointer to access data, but no bounds checking is performed.
% 
% 	When Aliens are used as parameters in FFI calls then all are "passed by value", so that e.g. a 4 byte direct alien will have its 4 bytes of data passed, and a 12-byte indirect alien will have the 12 bytes its address references passed.  Pointer aliens will have their 4 byte pointer passed.  So indirect and pointer aliens are equivalent for accessing data but different when passed as parameters, indirect Aliens passing the data and pointer Aliens passing the pointer.
% 
% 	Class Variables:
% 	GCMallocedAliens <AlienWeakTable of <Alien -> Integer>> - weak collection of malloced aliens, used to free malloced memory of Aliens allocated with newGC:
% 	LoadedLibraries <Dictionary of <String -> Alien>> - library name to library handle map
% 	

\paragraph{FFICallbackReturnValue} 
% copy/past from class comment
% An instance of FFICallbackReturnValue specifies a return value to be passed to a callback callee.  It is intended to have overlaid the following struct:
% 
% \begin{verbatim}
% /*
%  * Returning values from callbacks is done through a CallBackReturnSpec
%  * which contains a type tag and values.  It is designed to be overlaid upon
%  * an FFICallbackReturnProxy created at the Smalltalk level to return values.
%  */
% typedef struct {
%     long type;
% # define retint32  0 
% # define retint64  1
% # define retdouble 2
% # define retstruct 3
%     long _pad; /* so no doubt that valflt64 & valint32 et al are at byte 8 */
%     union {
%         long valint32;
%         struct { long low, high; } valint64;
%         double valflt64;
%         struct { void *addr; long size; } valstruct;
%     } rvs;
% } CallBackReturnSpec;
% \end{verbatim}


\paragraph{FFICallbackThunk} 
% copy/past from class comment

% An instance of FFICallbackThunk is a reference to a machine-code thunk/trampoline that calls-back into the VM.  The reference can be passed to C code which can use it as a function pointer through which to call-back into Smalltalk.  The machine-code thunk/trampoline is different for each instance, hence its address is a unique key that can be used to assocuate the Smalltalk side of the call-back (e.g. a block) with the thunk.  Since thunks must be executable and some OSs may not provide default execute permission on memory returned by malloc we may not be able to use malloc directly.  Instead we rely on a primitive to provide memory that is guaranteed to be executable.  The FFICallbackThunk class>>allocateExectablePage primitive answers an Alien that references an executable piece of memory that is some (possiby unitary) multiple of the pagesize.  Class-side code then parcels out pieces of a page to individual thunks.  These pieces are recycled when thunks are reclaimed.  Since the first byte of a thunk is non-zero we can use it as a flag indicating if the piece is in use or not.
% 
% See Callback for the higher-level construct that represents a Smalltalk block to be run in response to a callback.  Callbacks wrap instances of FFICallbackThunk and arbitrary Alien instances that describe the stack layout for receiving arguments.
% 
% Class Variables
% AccessProtect <Semaphore> critical section for ExecutablePages (de)allocation
% AllocatedThunks <AlienWeakTable of <FFICallbackThunk -> Integer>> - weak collection of thunks, used to return thunk storage to the executable page pool.
% ExecutablePages <Set of: Alien "executable page"> - collection of pages with execute permissions used to provide executable thunks


\paragraph{UnsafeAlien}
% copy/past from class comment

% Instances of UnsafeAlien represent the addresses of heap-resident non-pointer Smalltalk objects as actual parameters in FFI call-outs.  An UnsafeAlien on (e.g.) a ByteString used as a parameter in an FFI call causes the FFI machinery to pass the address of the first byte in the ByteString.  THIS IS UNSAFE!  It is unsafe because
% a) the garbage collector can potentially move the ByteString (or any other object) during the call, because the call may call-back, invoking the garbage collector,
% b) if external code retains the address for longer than the duration of the call and dereferences it in a subsequent call the object may have moved in the mean time,
% c) the address of the object is passed without any other potentially necessary conversions such as null-termination
% d) the hundred other problems this benighted author hasn't thought of.
% Hence UnsafeAlien is to be used carefully by clients that know that the usage is safe.
% You have been warned ;)
% 
% Create instances via
% 	UnsafeAlien forPointerTo: 'You are on your own!', (ByteString with: (Character value: 0))

\paragraph{AlienLibrary}
% copy/past from class comment

\paragraph{Callback}
% copy/past from class comment
% Callbacks encapsulate callbacks from the outside world.  They allow Smalltalk blocks to be evaluated and answer their results to external (e.g. C) callees.
% 
% Instance Variables:
% block <BlockContext> - The Smalltalk code to be run in response to external code invoking the callback.
% thunk <FFICallbackThunk> - the wrapper around the machine-code thunk that initiates the callback and whose address should be passed to C
% argsProxy <Alien> - the wrapper around the thunk's incomming stack pointer, used to extract arguments from the stack.
% resultProxy <FFICalbackReturnValue> - the specification of the block's return value and its C type so that the result can be passed back in the right low-level form.
% 
% Class Variables:
% ThunkToCallbackMap <Dictionary of: thunkAddress <Integer> -> callback <Callback>> - used to lookup the Callback associated with a specific thunk address on callback.  See FFICallbackThunk.

\paragraph{AlienWeakTable}
% copy/past from class comment

% This class supports simple post-mortem finalization of values associated with gc'ed objects.  An object to be finalized is registered in the table together with another object called 'the tag'. The finalizable object is held onto by the table weakly, the tag object--strongly. A table is initialized with the owner object, which is the object that performs the actual finalization. Some time after a finalizable object is garbage-collected, the owner is sent the \#finalize: message with the object's tag as the argument.
% 
% Instance Variables:
% 	accessProtect <Semaphore>  - A mutex protecting state
% 	firstUnusedIndex <Integer> - The lowest index in strongArray that is empty (an invariant)
% 	lastUsedIndex <Integer> - The highest index in strongArray that is not empty (an invariant)
% 	weakArray <WeakArray> - The array of objects whose death we're interested in.
% 	strongArray <Array> - The array of corresponding objects that wll be passed to the owner when their corresponding element in weakArray is garbage collected.
% 	owner <Object> - The object that is sent finalize: with the tag of an object that has been garbage-collected.
% 

\section{Study Case: the AlienOpenGL package} \label{sec:example_the_alienopengl_package} % (fold)


%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================
