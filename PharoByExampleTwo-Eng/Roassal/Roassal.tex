
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
    \DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
	\newcommand{\fig}[4]{
		\begin{figure}[#1]
			\centering
			\includegraphics[width=#2\textwidth]{#3}
			\caption{\label{fig:#3}#4}
		\end{figure}}

	\newcommand{\largefig}[4]{
		\begin{figure*}[#1]
			\centering
			\includegraphics[width=#2\textwidth]{#3}
			\caption{\label{fig:#3}#4}
		\end{figure*}}
		
	\newcommand{\asdf}[4]{
		\begin{subfigure}[\label{fig:#3}]
                \centering
                \includegraphics[width=\textwidth]{#3}
                \caption{\label{fig:#3}#4}                
        \end{subfigure}}

\begin{document}
\fi
%=================================================================
%\renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Agile Visualization with Roassal}
\chalabel{roassal}


\chapterauthor{Vanessa Pe\~{n}a-Araya}

Giving a meaning to a large amount of data is challenging without adequate tools. Textual outputs are known to be limited in their expressiveness and support for interaction. 

Roassal is an agile visualization engine. Roassal is made to visualize and interact with arbitrary data, defined in terms of objects and their relationships. Roassal is commonly employed to produce interactive visualizations. The range of applications using Roassal is diverse. For example, the Moose community uses Roassal to visualize software. 
Mondrian is a domain specific language that is built at the top of Roassal. Mondrian is made to easily create static visualization. Mondrian is presented in the next chapter. 

This chapter introduces Roassal's principles and describes its expressive commands to quickly render your data. After its reading, you will be able to create interactive and visual representation. 

For more information, please visit Roassal website: \url{http://objectprofile.com/roassal}

%=====================
\section{Installation and first visualization}
Roassal is distributed with Moose. So, if you are using Moose, then you already have Roassal. You can merely proceed to your first visualization.

Installing Roassal in a fresh Pharo image is quite easy. Just open a workspace and type:

\begin{code}{}
Gofer new
	squeaksource: 'Roassal'; 
	package: 'ConfigurationOfRoassal';
	load.
(Smalltalk at: #ConfigurationOfRoassal) project lastVersion load.
\end{code}
\alex{We will have modify this to a stable version before releasing the chapter}

Roassal is known to work on the version 1.4 and more recent versions of Pharo.

\subsection{A first visualization.}
\alex{We need to pick a better visualization. This one is too trivial and it is rather adapter to Mondrian, not really to Roassal}

The first visualization we will show represents the \ct{Collection} class hierarchy. It defines each class as a box connected with its subclass. Each box looks according to the represented class number of methods and number of instance variables.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
classElements := ROElement forCollection: Collection withAllSubclasses.

classElements 
	do: [:c | 
		c width: c model instVarNames size.
		c height: c model methods size.
		c + ROBorder. 
		c @ RODraggable ].
view addAll: classElements.

associations := classElements collect: [:c | 
	(c model superclass = Object)
		ifFalse: [ (view elementFromModel: c model superclass) -> c]
	 ] thenSelect: [:assoc | assoc isNil not ].
edges := ROEdge linesFor: associations.
view addAll: edges.

ROTreeLayout new on: view elements.
view open
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{collectionHierarchy}
   \end{minipage}
\label{fig:firstVisualization}
\caption{First visualization using the Roassal framework}
\end{figure}

How to achieve this visualization will be explained through the chapter. 
Next chapter details how to create it using the Mondrian DSL by using the Mondrian builder, part of Roassal.

%=====================
\subsection{Roassal Easel}

The Roassal easel is a tool to interactively script visualizations. The metaphor used with the easel is to turn the programmer into a painter carrying out the work on an easel: creating, adjusting, erasing is just a few (key) strokes away.

The Roassal easel is accessible from the Pharo World menu. Just look for the {\color{red} $\mathcal{R}$} icon\footnote{Note that a Glamour-based easel is also provided, under the Moose section of the World menu. The Glamour-based Roassal easel is similar to the easel presented here. A dedicated presentation of this version may be found in the moose book, \url{http://themoosebook.org}.}.

The easel is made of two independent windows, the one on the left-hand side renders the script written in the textual window on the right-hand side. By accepting (Cmd-s, Alt-s / right-clicking and pressing accept) in the editor, the visualization will be updated. This is the same keystroke than accepting a method in the system browser. The advantage of this is to have short feedback loop: the meaning of your script is always one keystroke away.

The visualization window contains many examples of visualizations, including a step-by-step tutorial. Examples are separated in two categories: \ct{ROExample} and \ct{ROMondrianExample}, and are accessible by clicking in the \textit{examples} button in the upper part of the visualization window.

\fig{H}{1}{ROEasel}{Roassal Easel examples separated by the ROMondrianViewBuilder and ROExample categories}


The \ct{ROMondrianExample} category includes examples created with Mondrian, a domain specific language built at the top of Roassal. These examples primarily use the \ct{ROMondrianViewBuilder} class to made up a visualization. The  \ct{ROExample} category directly illustrates Roassal.

\alex{I do not understand this paragraph}It also includes how to add buttons to zoom in and zoom out the visualization, export it to different formats and save it, among other actions. This buttons are not included by default in the Mondrian builder or the \ct{ROView} class, so the easel allows one to learn how to do it.

%=====================
%=====================

\section{Roassal Core Model}

Each visualization is an instance of the class \ct{ROView}, which is the container for all the data to be visualized.
Data is represented by instances of \ct{ROElement} that are added to the visualization. Usually, a visualization element is holding or referencing to a domain object, which it is called its model and that is accessible via the \ct{model} message. 

\paragraph{Adding an element.} The following code creates and opens a visualization with a single element of 100 size which models the ``foo'' string:


\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element := ROElement new 
				model: 'foo'; 
				size: 100.
view add: element.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex1}
   \end{minipage}
\label{fig:ex1}
\end{figure}

However, by executing this code nothing appears in the visualization. The element is there but we haven't set how it should look like. The look of an element is given by shapes, instances of subclasses of \ct{ROShape}. By default, every element has a empty shape which is an instance of \ct{RONullShape}. Let's add some shape (a border) to our element: 

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element := ROElement new size: 100.
element 
	+ ROBorder. "-> add shape"
view add: element.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex2}
   \end{minipage}
\label{fig:ex2}
\end{figure}

\paragraph{Adding a Shape.}
To add a shape to an element, we send the \ct{+} message with the wanted shape. For this example we added the \ct{ROBorder} shape. As its name suggests, \ct{ROBorder} adds a border to the \ct{ROElement}. By default, the color for a \ct{ROBorder} is black. There are several other shapes such as labels, circles or filled rectangles, and they can be customized. It is also possible to compose them to create more complex looks. \secref{shapes} details more on shapes.

\paragraph{Reacting to events.}
A \ct{ROElement} can also have interactions, allowing it to answer to events. For instance, an element can be dragged by the mouse. To add an interaction to a \ct{ROElement} send the \ct{@} message with the interaction as parameter. \ct{RODraggable} allows an element to react to mouse drag. So let's make our element to be draggable. More about interactions is presented in \secref{interactions}.

\begin{code}{}
view := ROView new.
element := ROElement new size: 100.
element 
	+ ROBorder; "-> add shape"
	@ RODraggable. "-> add interaction"
view add: element.
view open.
\end{code}


\paragraph{More Elements.}
Visualizations are usually composed of more than one element. You can add more elements to a \ct{ROView} by sending the message \ct{addAll:} with a collection of \ct{ROElements}. You can later access them by using the \ct{elements} accessor. 
By executing the following code a visualization with two elements appears, both placed in the top left part. We first create two element of 50 and 100 size, respectively, and add them to the view as an array using the \ct{addAll:} message. We later access all the elements of the view to add them a border and make them draggable.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element1 := (ROElement new size: 100).
element2 := (ROElement new size: 50).
view addAll: (Array with: element1 with: element2).
view elements do: [:el | el + ROBorder; @ RODraggable].
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex3}
   \end{minipage}
\label{fig:ex3}
\end{figure}

A ROElement can be translated by sending \ct{translateBy:} or \ct{translateTo:} with a point as parameter. The parameter representing how much the element must be translated horizontally with the x value and vertically with the y value. The axes are defined as shown in \figref{ex4}, the x-axis increase from left to right and the y-axis from top to bottom.


\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element1 := (ROElement new size: 100).
element2 := (ROElement new size: 50).
element2 translateBy: 150@150.
view addAll: { element1 . element2 }.
view elements do: [:el | el + ROBorder; @ RODraggable].
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex4}
   \end{minipage}
\label{fig:ex4}
\end{figure}


When a visualization contains more than one element it is hard to setup each one's position by hand. Roassal provides defined layouts to arrange elements. A layout in Roassal is a subclass of \ct{ROLayout}. Layouts are explained in  \secref{layouts}.


\paragraph{Nesting Elements.}
A ROElement can also contain other ROElement's, creating nested elements. In addition as shown by the following example, the location of children is relative to the one of the parent. This means that when we translate the parent, the children will be translated as well. %A translation is relative to the parent coordinates.


\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
parent := ROElement new 
				size: 100;
				+ ROBorder.
children := ROElement new 
				size: 50;
				+ ROBorder red.
parent add: children.
view add: parent.
"Translate the parent"
parent translateTo: 50@100.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex5}
   \end{minipage}
\label{fig:ex5}
\end{figure}

By default, when translating a child node, its parent bounds will be extended to contain this element in its new position. This can be seen in the following example.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
parent := ROElement new 
				size: 100;
				+ ROBorder.
children := ROElement new 
				size: 50;
				+ ROBorder red.
parent add: children.
view add: parent.
"Translate the children"
children translateTo: 50@100.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex6}
   \end{minipage}
\label{fig:ex6}
\end{figure}

Each element has a resize strategy, stored as \ct{resizeStrategy} instance variable.
By default, the resize strategy is an instance of \ct{ROExtensibleParent}, which means a parent will extent is bounds to fit all its children elements.
It is possible to find more resize strategies by searching the \ct{ROAbstractResizeStrategy} class, as its subclasses define a strategy to be used by elements.

An element representation looks like \figref{ROElementModel}.

\fig{H}{0.5}{ROElementModel}{ROElement representation}

%\vp{not sure if the camera should be explained here. What can be added here about the camera that helps you to build a visualization?}
\paragraph{Translating the view's camera}
A view also answers to the \ct{translateBy:} and \ct{translateTo:} messages. However, even if it looks like, is not the view which changes its position but its camera. The camera component of a view, represented by an instance of \ct{ROCamera}, is the point of view from which a visualization object is actually viewed. More about the ROCamera can be found in \secref{camera}

\subsection*{The Collection hierarchy example}

As previously said, as an example we will create the Collection hierarchy visualization shown before through the chapter. We will build it by executing the following steps:
\begin{enumerate}
\item Add all the data with no particular shape. In this case the data is the Collection class with all its subclasses;
\item make the classes look according to characteristics of each class;
\item add links between a class and its superclass;
\item arrange the elements as an hierarchy with a layout.
\end{enumerate}

In this section, we start with the first step: adding all elements representing each class of the hierarchy. 

To do this easily, we will send the \ct{forCollection:} message to the \ct{ROElement} class, which is a helper to build ROElements from a collection. 
Each ROElement from the returning value of this message is a representation of each element from the parameter. 
We add a border shape to each of them and make them draggable for easier manipulation.
Finally, we apply a default layout to see all the elements in the view easily. 
More explanation of how layouts works will be explained later on. 


\begin{figure}[H]
\begin{code}{}
view := ROView new.
classElements := ROElement forCollection: Collection withAllSubclasses.
classElements 
	do: [:c | c + ROBorder.
			c @RODraggable ].
view addAll: classElements.
ROHorizontalLineLayout new on: view elements.
view open.
\end{code}
\end{figure}

\fig{H}{0.6}{hier1}{Adding the elements representing classes}


%=====================
\section{Shapes Detailled} \seclabel{shapes}

An element (instance of \ct{ROElement}) can be shaped by sending the \ct{+} message with a shape (instance of \ct{ROShape} subclass) or with a \ct{ROShape} class. 
When the parameter is a shape, it is possible to set attributes such as the color to be filled or the border color. When the class is send as parameter, the element will be shaped with an instance of that class with default values for each of its attributes.

Some of the shapes available are label (\ct{ROLabel}), border (\ct{ROBorder}), box (\ct{ROBox}) and circle (\ct{ROCircle}). By default, \ct{ROLabel} will display the \ct{printString} value of the model of the element. It is also possible to change it by setting a custom text as shown in \figref{label}. When applying \ct{ROBorder}, \ct{ROBox} and \ct{ROCircle} to a ROElement, the shape will be adapted to the bounds of the element. It is also possible to set attributes as color, border color or border width to a shape. This is shown in \figref{border}, \figref{box} and \figref{circle}.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
	     \begin{code}[!]
     
	ROElement new
		model: 'foo';
		size: 100; 
		+ ROLabel.	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{label}
   \end{minipage}
\caption{ROLabel with default values}
\label{fig:label}
\end{figure}

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
	ROElement new 
		size: 100; 
		+ ROBorder.	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.25\textwidth]{border}
   \end{minipage}
\caption{ROBorder with default values}
\label{fig:border}
\end{figure}  

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
ROElement new 
	size: 200; 
	+ (ROBox new 
				color: Color green; 
				borderColor: Color red; 
				borderWidth: 4 ).	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.5\textwidth]{box}
   \end{minipage}
\caption{Customized ROBox}
\label{fig:box}
\end{figure} 

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
|element shape|
element := ROElement new 
				size: 100.
shape := ROCircle new 
			color: Color yellow; 
			borderColor: Color blue; 
			borderWidth: 2.
element + shape.	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.25\textwidth]{circle}     
   \end{minipage}
\caption{Customized ROCircle}
\label{fig:circle}
\end{figure}



\paragraph{Composing Shapes.}
To create more complex looks we can compose shapes. To have an element shaped with more than one ROShape, we send the \ct{+} message several times with the desired shapes (\figref{composed}). 

This builds a chain of shapes associated to the element, which first component is the latest shape added and its end is an instance of the empty shape (\ct{RONullShape}).

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}

|element label border circle| 
    
element := ROElement new 
				size: 180.
				
label := ROLabel new 
				text: 'composed shape'.
border := ROBorder new 
				color: Color red. 
circle := ROCircle new 
				color: Color yellow.
				borderWidth: 0.
				
element + label.
element + border.
element + circle. \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{composed}
   \end{minipage}
\caption{Composing shapes}
\label{fig:composed}
\end{figure} 

\subsubsection*{The Collection hierarchy example}
We now will add some shape to the classes in the \ct{Collection} hierarchy example. Each class representation will have a width according to the number of instance variables of the class and a height according to the number of its methods. This make a polymetric representation of each of the classes.

\begin{code}{}
view := ROView new.
classElements := ROElement forCollection: Collection withAllSubclasses.
classElements do: [:c | 
	c width: c model instVarNames size.
	c height: c model methods size.
	c + ROBorder. 
	c @ RODraggable ].
view addAll: classElements.
ROHorizontalLineLayout new on: view elements.
view open.
\end{code}

\fig{H}{0.6}{hier2}{Adding some shape for each class}


%=====================
\section{Edges: linking elements} \seclabel{edges}

With Roassal it is possible to build links between elements to represent relationships between them. A link between elements is an instance of the class \ct{ROEdge}. An edge needs two elements: one to be the starting point and another to be the ending point. 
By default an edge is shaped with an instance of \ct{RONullShape} which is the empty shape. Because of this, for an edge to be rendered it needs to be shaped with a line shape, which can be any subclass of \ct{ROAbstractLine}.
The following code shows a very simple example of how to build an edge between two elements. We first create the two elements. We then create the edge using them as parameters and shape it with a line (instance of ROLine) shape. We finally add the two elements and the edge to the view.

\begin{figure}[H]
 \begin{code}{}
view := ROView new.
startElement := (ROElement on: 1) size: 20; + ROBorder red.
endElement := (ROElement on: 2)  size: 20; + ROBorder red.
endElement translateBy: 50@50.

edge := ROEdge from: startElement to: endElement.
edge + ROLine. "-> add a line shape"
view 
	add: startElement; 
	add: endElement; 
	add: edge. "-> added to the visualization"
view open.
\end{code}   
\caption{Simple edge}
\label{fig:simpleEdge}
\end{figure} 

\paragraph{Adding shape to an edge.}
There are several kind of line shapes to use besides the standard one, like \ct{ROOrthoHorizontalLineShape}, for example. All of them are subclasses of the \ct{ROAbstractLine} class, including \ct{ROLine}. 
Some examples are shown in \figref{line} and \figref{orthoEdge}.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + ROLine new. \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{line}
   \end{minipage}
\caption{Simple edge}
\label{fig:line}
\end{figure} 


\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + ROOrthoHorizontalLineShape new. \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{orthoEdge}
   \end{minipage}
\caption{Horizontally oriented orthogonal edge}
\label{fig:orthoEdge}
\end{figure} 

\paragraph{Adding an arrow to a line.}
A line can also contain one or more arrows. An arrow is an instance of a subclass of \ct{ROAbstractArrow}, like \ct{ROArrow} or \ct{ROHorizontalArrow}. To add an arrow to a line shape we use the \ct{add:} message, as in \figref{arrowEdge} and \figref{orthoEdgeArrow}.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + (ROLine new add: ROArrow new). \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{arrowEdge}
   \end{minipage}
\caption{Arrowed edge}
\label{fig:arrowEdge}
\end{figure} 

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + (ROOrthoHorizontalLineShape new add: ROHorizontalArrow new)\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{orthoEdgeArrow}
   \end{minipage}
\caption{Orthogonal edge with horizontal oriented arrow}
\label{fig:orthoEdgeArrow}
\end{figure} 

By default the arrow will be located at the end of the edge, but we can customize this position using the \ct{add:offset:}. The offset parameter must be a number between 0 and 1, and it indicates in which percent of the line length line the arrow will be. For example, if the offset is 0.5, the arrow will be set at the middle of the line, as shown in \figref{arrowMiddleEdge}.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + (ROLine new add: ROArrow new offset: 0.5). \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{arrowMiddleEdge}
   \end{minipage}
\caption{Edge with an arrow in the middle}
\label{fig:arrowMiddleEdge}
\end{figure} 

When a line contains more than one arrow we can setup different offsets for each arrow:

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
line := ROLine new.
line add: ROArrow new offset: 0.5.
line add: ROArrow new offset: 0.1.
edge + line. \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{twoArrowEdge}
   \end{minipage}
\caption{Edge with two arrows}
\label{fig:twoArrowEdge}
\end{figure} 

\subsection*{The Collection hierarchy example}
Now we know how to make links between elements. With the following code we can create edges between each class to its superclass. 
To do so, we first need to create a collection of associations to build edges with them. Each association represents a starting point as the association key and an ending point as the association value. For this example each association goes from a \ct{ROElement} representing a class to the \ct{ROElement} that represents its superclass. 

When having the associations, we create the instances of \ct{ROEdge} by using the \ct{linesFor:} message. This message takes as parameter a collection of associations and return a collection of edges.


\begin{code}{}
view := ROView new.
classElements := ROElement forCollection: Collection withAllSubclasses.
view addAll: classElements.
associations := OrderedCollection new.
classElements do: [:c | 
	c width: c model instVarNames size.
	c height: c model methods size.
	c + ROBorder. 
	c @ RODraggable.	
	(c model superclass = Object)
		ifFalse: [ associations add: ((view elementFromModel: c model superclass) -> c)]	
	 ].
edges := ROEdge linesFor: associations.
view addAll: edges.
ROHorizontalLineLayout new on: view elements.
view open
\end{code}

\fig{H}{0.6}{hier3}{Adding links between each class and its superclass}

Now we have each class in the \ct{Collection} hierarchy with the shape we want and connected with each superclass. However we don't see a real hierarchy. This is because we need an appropriate layout to arrange all the elements of the view. Next section covers how to apply layouts to elements.


%=====================
\section{Layouts} \seclabel{layouts}
A layout defines how a collection of elements can be arranged automatically. To apply a layout use the \ct{on:} message with a collection of \ct{ROElement}s as parameter. In the example shown in in \figref{primerLayout} we use the \ct{spriteOn:} message to create a collection of ROElements easier, each one with size equals to 50, shaped with a red border and draggable. And then we apply a layout to arrange the elements as grid.


\begin{figure}[H]
\label{fig:primerLayout}
      \begin{minipage}[t]{0.55\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
view addAll: (ROElement spritesOn: (1 to: 4)).
ROGridLayout on: view elements.
view open.
  \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.3\textwidth]{ROGrid2} %layout1?
   \end{minipage}

\caption{ROGridLayout applied to a group of ROElements}
\end{figure} 

Some of the layouts available in Roassal can be seen in \figref{roLayouts}. This layouts, in addition to those not presented here, can be found as subclasses of \ct{ROLayout}.

\begin{figure}[h]
        \centering
		\subfigure[ROGridLayout]{\includegraphics[width=0.15\textwidth]{ROGrid}} \hfill
		\subfigure[ROCircleLayout]{\includegraphics[width=0.15\textwidth]{ROCircle}}\hfill
		\subfigure[ROTreeLayout]{\includegraphics[width=0.11\textwidth]{ROTree}} \\ 
		\subfigure[ROMapTreeLayout]{\includegraphics[width=0.2\textwidth]{ROMapTree}} \hfill
		\subfigure[ROVerticalLineLayout]{\includegraphics[width=0.06\textwidth]{ROVertical}}\hfill
		\subfigure[ROHorizontalLineLayout]{\includegraphics[width=0.25\textwidth]{ROHorizontal}}
        \caption{Some of the layouts available applied to a group of elements}\label{fig:roLayouts}
\end{figure}

As a layout is applied to a collection of elements, different set of elements can have different layouts. In the following example two collection of elements will be arrange with two layouts. The first one will be align them in a vertical line and the second in a horizontal line. 
We first create the elements for the vertical line, apply the \ct{ROVerticalLineLayout} and shaped them with a label for easier identification. We then do the same for the second group, using the \ct{ROHorizontalLineLayout} and translating them a bit to avoid overlaping.

\begin{figure}[H]
\label{fig:differentLayouts}
\vspace{0pt}
	\begin{minipage}[t]{1\textwidth}
     \begin{code}{}
|view verticalElements horizontalElements|

view := ROView new.

verticalElements := ROElement spritesOn: (1 to: 3).
ROVerticalLineLayout on: verticalElements.
verticalElements do:[:el | el + ROLabel].
	
horizontalElements := ROElement spritesOn: (4 to: 6).
ROHorizontalLineLayout on: horizontalElements.
	
horizontalElements do:[:el |
	el + ROLabel.
	el translateBy: (60@ 0).
].	
view 
	addAll: horizontalElements; 
	addAll: verticalElements.
view open.
  \end{code}
   \end{minipage}  

\hfill
   \begin{minipage}[t]{1\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.3\textwidth]{differentLayouts} 
   \end{minipage}
\caption{Applying different layout to different set of elements}
\end{figure} 



\paragraph{Layouts in Nested Structures.}
When dealing with nested ROElements, layouts are relative to each element container. In the following example, two elements are created, each one with three child elements arranged as a grid. We finally arrange the parents elements in a horizontal line layout.

\begin{figure}[H]
      \begin{minipage}[t]{0.61\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
elements := (ROElement spritesOn: (1 to: 2)).
elements 
	do: [:el | el addAll: (ROElement spritesOn: (1 to: 3)). 
	           "arranging the children nodes"
			   ROGridLayout on: el elements.].			   
view addAll: elements.
ROHorizontalLineLayout on: view elements.
view open.
  \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}\raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{nestedLayout}
   \end{minipage}
\label{fig:nestedLayout}
\caption{Nested elements with different layouts }
\end{figure} 


\paragraph{Creating a new layout.}
\vp{new section added. Needs cleaning and reviewing}
In this section we will describe how to create a new layout. But before explaining how to create a layout, we will first understand a bit of the structure of how a layout is executed. 

All layout classes inherit from \ct{ROLayout}. 
This class define the most commonly used method to apply a layout, \ct{on:}, from the instance or from the class side, which sends the \ct{applyOn:} message. Another option is to send the \ct{applyOn:} message directly to an instance of a layout. 
\ct{applyOn:} calls to \ct{executeOnElements:}, which is the main method for a layout to be applied. This method is shown in the following code:

\begin{code}{}
ROLayout >> executeOnElements: elements 
	"Execute the layout, myself, on the elements"	
	maxInterations := elements size.
	self doInitialize: elements.
	self doExecute: elements asOrderedCollection.
	self doPost: elements.
\end{code}

This method is defined by the three messages send in its code:

\begin{enumerate}

\item \textbf{doInitialize:} To execute the previous actions before the layout is applied;
\item \textbf{doExecute:} to apply the layout, which mean changing the elements position and;
\item \textbf{doPost:} to execute the ending actions after the layout is applied.
\end{enumerate}

It is possible to set operations to be executed before and after the layout is applied. This actions are set as callbacks using the \ct{ROLayoutBegin} and \ct{ROLayoutEnd} events.
\ct{ROLayoutBegin} and \ct{ROLayoutEnd} are announced by \ct{doInitialize:} and \ct{doPost:}, respectively.
An example of its use is shown in the following code:

\begin{code}{}
|layout t|
t := 0.
layout := ROHorizontalLineLayout new.
layout on: ROLayoutBegin do: [ :event | t := t + 1 ].
layout on: ROLayoutEnd do: [ :event | t := t + 1 ].
layout applyOn: (ROElement forCollection: (1 to: 3)).

self assert: (t = 2).
\end{code}

\ct{doExecute:} is the responsible method to arrange the elements as the layout requires. This method takes as parameter a collection of elements and goes through it setting new positions to each component.

Now we know the structure of the \ct{ROLayout} class, let's create a layout that arrange the elements in a diagonal line.
We first need to create a new class inheriting from \ct{ROLayout}. 

\begin{code}{}
ROLayout subclass: #RODiagonalLineLayout
	instanceVariableNames: 'initialPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Roassal-Layout'
\end{code}

The instance variable \ct{initialPosition} defines where the line will start, which mean, where the first element of the line will be located. We will create an initialize method and accessors for this variable.

\begin{code}{}
RODiagonalLineLayout >> initialize
	super initialize.
	initialPosition := 0@0.
	
RODiagonalLineLayout >> initialPosition: aPoint
	initialPosition := aPoint
	
RODiagonalLineLayout >> initialPosition
	^initialPosition
\end{code}

If the layout would need to execute special actions before or after it is applied, we would overwrite the \ct{doInitialize:} or \ct{doPost:} methods. However, this is not the case. 
The method we need overwrite is \ct{doExecute:} which will actually translate the elements.

\begin{figure}[H]
\begin{code}{}
RODiagonalLineLayout >> doExecute: elements
	|position|	
	position := initialPosition.
	elements do: [:el | 
		el translateTo: position.
		position := position + el extent.
	].	
\end{code}
\end{figure}

We can test our layout with the following code:

\begin{figure}[H]
      \begin{minipage}[t]{0.61\textwidth}
      \vspace{0pt}
\begin{code}{}
|view elements|
view := ROView new.
elements := ROElement spritesOn: (1 to: 3).
view addAll: elements.
RODiagonalLineLayout on: view elements.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}\raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{diagonalLineLayout}
   \end{minipage}
\label{fig:diagonalLineLayout}
\caption{Diagonal Line layout applied to a collection of elements}
\end{figure} 


\subsection*{The Collection hierarchy example}

As we need an hierarchy for the \ct{Collection} example, the \ct{ROTreeLayout} will be useful to obtain the visualization we want.
\sd{why do we have @ RODraggable and + ROBorder}\vp{added comments in the code. why we add a border and draggable is presented in the first step of the example}

\begin{figure}[H]
\begin{code}{}

"Create the elements to be displayed"
view := ROView new.
classElements := ROElement forCollection: Collection withAllSubclasses.
view addAll: classElements.

associations := OrderedCollection new.

classElements do: [:c | 

	"Make each element reflect their model characteristics"
	c width: c model instVarNames size.
	c height: c model methods size.
	
	"we add shape for the element to be seen"
	c + ROBorder. 
	"we make it draggable by the mouse"
	c @ RODraggable.
	
	"Create associations to build edges"
	(c model superclass = Object)
		ifFalse: [ associations add: ((view elementFromModel: c model superclass) -> c)]	
	 ].
	 
"Add edges between each class and its superclass"
edges := ROEdge linesFor: associations.
view addAll: edges.

"Arrange all the elements as a hierarchy"
ROTreeLayout new on: view elements.
view open
\end{code}
\end{figure}

The resulting visualization can be seen in \figref{collectionHierarchy}.

\fig{H}{0.4}{collectionHierarchy}{Collection class hierarchy with width reflecting instance variable number and height number of methods.}

%=====================

\section{Events and Callbacks}

Roassal allows any visible component in a visualization, including itself, to react to events. There are two kinds of events defined in Roassal. In the first kind are those responding to external events, like mouse clicks, mouse move or key press. The second kind of events includes those triggered by internal manipulation of the ROView or its components, like when a view needs to be refreshed. All events inherits from the \ct{ROEvent} class.

To see how events work, we will shown an example of a visualization that reacts to mouse clicks, translating an element to where the click was made. 
There are several event classes to deal with mouse events: \ct{ROMouseClick}, \ct{ROMouseMove}, \ct{ROMouseEnter} and \ct{ROMouseLeave}, among others; and to deal with key pressing, the \ct{ROKeyDown} class.

We will make the visualization to react to the left click of the mouse using the \ct{ROLeftMouseClick} event. The reaction will create an animation to translate the element to the event position.

We use the \ct{on:do:} message to set a Roassal object to react to an event, as shown in the following code. The first parameter must be the class of the expected event and the second one a block which defines the action to be executed when the event is received.

\begin{code}{}
view := ROView new.
el := ROElement sprite.
view add: el.
view 
	on: ROMouseLeftClick 
	do: [ :event | 
	        ROLinearMove new for: el to: event position].
view open. 
\end{code}


\ct{ROLinearMove} is one of the Roassal interactions. As its name suggest, it creates an animation for an element to be translated in a linear move. More about interactions is explained in the next section.

%
%\alex{How to define callbacks}
%\alex{What are the different events we can handle}


%=====================
\section{The interaction hierarchy} \seclabel{interactions}

A ROElement can respond to events by setting callbacks or interactions. We have already presented how to set callbacks so in this section will detail the interactions. 

The root class of all Roassal interactions is \ct{ROInteraction}. An interaction is set to an element by sending the \ct{@} message with an instance or a class of a subclass \ct{ROInteraction} as parameter. There are diverse interactions that can be set to an element such as  \ct{RODraggable}  or \ct{ROGrowable}.
\ct{RODraggable} allows an element to be dragged by the mouse and \ct{ROGrowable} makes an element to increase its size when clicked. 

An element can have more than one interaction. For example, we can set both, \ct{RODraggable}  or \ct{ROGrowable}, to an element.
Try the following code. Click the element to make it bigger or drag it on the view.

\begin{code}{}
|view element|
view := ROView new.
element := ROElement new size: 10.
element 
	+ ROBox;
	@ RODraggable; 
	@ ROGrowable.
view add: element.
view open.
\end{code}


Some interactions are more complex to setup, like popups elements which are displayed when the mouse is over an element. 

\paragraph{Animations} Animations are also interactions in Roassal. Some animations allows elements to be translated, like \ct{ROLinearMove}, \ct{ROMotionMove} or \ct{ROFunctionMove}. This animations allows elements to be translated in a linear move, with a decreasing speed and describing a curve given by a function, respectively. Animations like \ct{ROZoomInMove} and \ct{ROZoomOutMove} allows a view to be focused in and out. All animations are subclasses of \ct{ROAnimation}. As animations are interactions too, \ct{ROAnimation} is a sublcass of \ct{ROInteraction}.

From the availables interactions in Roassal, two examples are presented: one for \ct{ROAbstractPopup} and one for \ct{ROAnimation}.

\subsection*{ROAbstractPopup}

\ct{ROAbstractPopup} allows elements to react to mouse over events by displaying a popup. There are two kind of popups, (i) \ct{ROPopup}, which by default displays a box with the \ct{printString} value of the element model; and (ii) \ct{ROPopupView} that displays a custom view.

To add a popup to an element just send the \ct{@} message with the \ct{ROPopup} class as argument. It is also possible to setup a custom text using the \ct{text:} message with a string as parameter. 

In the following example we create an element by sending the \ct{spriteOn:} message to ROElement, which model is the parameter of the message. The resulting element has 50 size, a red border and is draggable by the mouse. We finally add the \ct{ROPopup} to the element.


\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
el := ROElement spriteOn: 'baz'.
el @ ROPopup. "Or with custom text -> (ROPopup text: 'this is custom text')"
view add: el.
view open.
  \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{popup}
   \end{minipage}
\label{fig:popup}
\caption{ROPopup}
\end{figure} 

\ct{ROPopupView} is slightly more complex as it needs the definition of the view to popup. This interaction can be created by sending the \ct{view:} message to the \ct{ROPopupView} class with the new view to be displayed. 
The parameter can also be a block which defines a view. When the mouse is over an element, the block is evaluated using the same element as parameter, allowing the view to be dynamically created.

The following example creates a view with five elements. Each one reacts when the mouse is over by displaying a popup. The popup view is defined as a block which creates a view with the same amount of nodes as the element model where the mouse is. For example, and as \figref{popupView} shows, when passing the mouse over the node ``3'', a popup with \textit{three} gray boxes appears.

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
elements := ROElement spritesOn: (1 to: 5).
"create the view to popup"
viewToPopup := [ :el | |v| 
	              	              v := ROView new.
	              	              "Add as much elements as the value represented"
	              	              v addAll: (ROElement forCollection: (1 to: el model)).
	              	              v elementsDo: [ :e | e size: 20; + ROBox ].
	              	              ROGridLayout on: v elements.
	              	              v ].
elements do: [ :e | e + ROLabel;  @ (ROPopupView view: viewToPopup)].
view addAll: elements.
ROHorizontalLineLayout on: view elements.
view open.
\end{code}
\end{minipage}\hfill\begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{popupView2}
   \end{minipage}
\label{fig:popupView}
\caption{\ct{ROPopupView} which creates a view with the same number of elements as the model of the element the mouse is over.}
\end{figure} 


%first example
%view := ROView new.
%el := ROElement spriteOn: 'Roassal'.
%
%"create the view to popup"
%viewToPopup := ROView new.
%viewToPopup 
%	addAll: (ROElement forCollection: (1 to: 4 )).
%viewToPopup 
%	elementsDo: [:e | e size: 20. e + ROBox  ].
%ROGridLayout 
%	on: viewToPopup elements.
%	
%el := ROElement spriteOn: 'Roassal'.
%el @ (ROPopupView view: viewToPopup).
%view add: el.
%view open.


%
%\vp{not sure if present this one}
%\subsubsection*{ROMenuActivable}
%
%\begin{figure}[H]
%      \begin{minipage}[t]{1\textwidth}
%      \vspace{0pt}
%     \begin{code}{}
%view := ROView new.
%el := ROElement sprite.
%el @ (ROMenuActivable new item: 'inspect' action: #inspect).
%view add: el.
%view open.
%  \end{code}
%   \end{minipage}
%   \hfill
%   \begin{minipage}[t]{1\textwidth}
%	 \vspace{0pt} \raggedright
%       \centering
%		\includegraphics[width=0.7\textwidth]{menuActivable}
%   \end{minipage}
%\label{fig:menuActivable}
%\caption{ROMenuActivable applied to a ROElement}
%\end{figure} 

\subsection*{\ct{ROAnimation}}
Any animation is an instance of a subclass of the \ct{ROAnimation} class. Some examples are \ct{ROLinearMove}, \ct{ROZoomInMove} and \ct{ROZoomOutMove}.

Each animation has a number of cycles to complete, executing each one by sending the \ct{doStep} message.
A \ct{ROAnimation} also allows one to set a block to be executed after the animation is finished, using the \ct{after:} message. It is important to notice that any action to be done after the animation is finished must be set before the animation is triggered, otherwise it will not be executed. \sd{do you have a before: message.} \vp{no, we do not have it, i'll add it and update this}

\figref{animationCode} presents \ct{ROLinearMove}. The following code allows an element to be animated in a sin curve, using the \ct{ROFunctionMove}.

\begin{figure}[H]
\begin{code}{}
view := ROView new.

element := ROElement new.
element size: 10.
element + (ROCircle color: Color green).

view add: element.
element translateBy: 30@20.

ROFuncionMove new
	nbCycles: 360;
	blockY: [ :x | (x * 3.1415 / 180) sin * 80 + 50 ];
	on: element.
view open.
\end{code}
\label{fig:animationCode}
\end{figure}

%\alex{Present the hierarchy of the interaction}

%\alex{Give some examples with buttons and animations}


%=====================
\section{Understanding a View's Camera} \seclabel{camera}

A view's camera represents the point of view from which it is actually viewed. 

When \ct{translateBy:} or \ct{translateTo:} messages are sent to a view, what actually happens is that its camera moves, no the view itself. The position of the camera is represented by the \ct{position} instance variable. The camera's position can be set by hand sending the same messages to the camera, \ct{translateBy:} or \ct{translateTo:}, but using negated values as parameters. This mean if the view has to be translated by 10 pixels horizontally and vertically, we can do it like this:

\begin{code}{}
view translateBy: 10@10
\end{code}

Or translate the view's camera by hand:

\begin{code}{}
view camera translateBy: (-10)@(-10)
\end{code}

A camera has an extent, which is what we are seeing and a real extent, which represents the far extent. 
The extent of the view's camera affects the way a view is drawn in a canvas. When rendering a view, each point, rectangle or other shape that needs to be drawn will be plotted according to the camera's extent. This is done by transforming each absolute position in \emph{virtual} points relative to the camera's vision.
For example, when zooming in on a view, the content on the extent is ``stretched'' to fill the real extent, which makes objects to look bigger. \vp{not sure if this explains completely} 
The extent and the real extent of the camera can be modified using \ct{extent:} and \ct{realExtent:} accessors, respectively.

The camera also stores the window size of the visualization.

The camera has an altitude from the view, which is calculated using the extent. The smaller the extent is, the lower the camera is located, and viceversa. The altitude of the camera can be set by sending the \ct{altitude:} message using a number as parameter.
A camera's directions is always perpendicular to the view.


\figref{cameraDiagram} shows a camera's diagram, indicating all its information regarding the view it is associated with. It can also be seen that the visible part of the visualization is giving by the camera's extent\vp{not sure how about this} .


\begin{figure}[H]
        \centering
		\subfigure[Camera diagram]{\includegraphics[width=1\textwidth]{cameraDiagram}} \hfill
		\subfigure[Camera extent, showing what it is actually seen]{\includegraphics[width=0.3\textwidth]{cameraExtent}}\hfill
        \caption{Components of a view's camera}\label{fig:cameraDiagram}
\end{figure}

The extent of the camera is used by the \ct{ROZoomMove} interaction. This interaction works by modifying the camera's position and extent to fit a desired rectangle. For example, when zooming to focus in a particular element of the view, the \ct{ROZoomMove} will translate and extent the camera to fit that element's bounds.
This movement can be simulated by changing the camera's altitude.

\vp{Stef suggested to explain this in more detail}
\paragraph{Using the camera to build a minimap for navigation}
This is also used by the \ct{ROMiniMap} interaction.

The \ct{ROMiniMap} allows one to have a complete vision of a visualization for better navigation. It use the original view's camera 

It is composed of a smaller version of the visualization and a ``lupa'', which represents the current visible part of the view's window. To add this interaction, just send the \ct{@ROMiniMap} message to a view and press ``m'' to open it (\figref{miniMap}). \sd{how the communication between the MiniMap and the other view is done?}

\fig{H}{0.9}{miniMap}{\ct{ROMiniMap} applied to the Collection Hierarchy example}

The smaller version of the view is displayed by a \ct{ROMiniMapDisplayer}, subclass of \ct{ROViewDisplayer}. 
As their name suggest it, they are shapes that display a view on a ROElement. The difference between both is that \ct{ROMiniMapDisplayer} uses its own camera, which has a different extent to the view's camera. This allows one to see the same view with different size. 

The lupa  size represents the visible part of the window and its position is related to the view's camera position. When the view is translated to a point, the lupa follows it by changing its position: the point representing the camera position is translated to a point on the \ct{ROMiniMapDisplayer} camera extent. And when the view is zoomed in or zoomed out the extent of the camera is changed, increasing or decreasing the lupa's size.

%\alex{MiniMap}
%\alex{Semantic zooming: Making objects appear when the camera goes down}



\section{Beyond Pharo}

Roassal have been designed to be easily ported to other Smalltalk dialects. Currently it has been ported to VisualWorks, Amber and VA Smalltalk.

As \figref{structure} shows, Roassal consists in three main components:

\begin{itemize}
\item  The Roassal Core, a set of packages that contains all the main classes definition, like ROView, ROElement, ROShape and ROCamera. It also contains all the tests.
\item The Mondrian DSL, composed by the Roassal-Builder and Roassal-Builder-Tests packages.
\item The platform dependent packages, that is dedicated to each Smalltalk dialect Roassal is ported to.
\end{itemize} 

In top of this components, you application will be build.

In the platform dependent packages several classes must be implemented. The main ones are a native canvas class, where a view can be rendered, and a widget factory class, which can return an object to contain the canvas and receive and delegate all the external events.
The first must be subclass of ROAbstractCanvas and the second must be subclass of RONativeWidgetFactory.

The \ct{ROPlatform} class defines how the bridge between the core and the dependent packages must be implemented. This class defines instance variables, like \ct{canvasClass} and \ct{widgetFactory}, which store the correspondent class to use according to their name. Each platform dependent package must implement its own platform class, make it subclass of ROPlatform and reference all the implemented platform dependent classes.
Internally, every time one of this classes is needed, the core relies in the current instance of a ROPlatform to return the needed class.

\fig{H}{0.3}{structure}{Roassal structure}

%\alex{Describe the platform architecture}

%=====================

\section{Conclusion}

Roassal enables any graph of objects to be visualized. This chapter has reviewed the main features of Roassal:

\begin{itemize}
\item Create graphical elements and shape them to look as desired.
\item Create edges to represent relationships between graphical elements.
\item Apply layouts to arrange collections of elements automatically.
\item Make elements to react to events by setting callbacks and defined interactions.
\item Move the visualization point of view, by interacting with its camera.
\end{itemize}

\paragraph{Acknowledgment}
We thank Chris Thorgrimsson for supporting the development of Roassal.

We are very grateful to Nicolas Rosselot Urrejola for his review of an early draft of the chapter. We also thanks Emmanuel Pietriga for the multiple discussions we have had about the design of Roassal. 

%Mondrian is a perpetual evolving application. This chapter intents to cover the features frequently used. If there is a topic you wish to see discussed here, send an email to alexandre@bergel.eu.
%
%We hope you have enjoyed it!
%
%=====================


%=============================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=============================================================


%Dead text:

Node color \ja{nothing about edge color ? I think we can say that it is possible too} is an important information support, as the width and the height of a node. Color should be easy to pick to represent particular condition.

The keyword if:fillColor: enables one to assign a color for a particular condition. Consider we want to extend the previous example by coloring abstract classes in red.

\begin{code}{}
view shape rectangle
  width: [ :each | each instVarNames size * 3 ];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: Collection withAllSubclasses.

view edges: Collection withAllSubclasses from: #yourself toAll: #subclasses.

view treeLayout.
\end{code}


The message \ct{if:fillColor:} may be sent to a shape to conditionally set a color. \ja{what is the link with the source code below ?}

\begin{code}{}
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: Collection withAllSubclasses.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

All red nodes represent abstract class. Waving the moose above a node make a text tooltip appear revealing its name. 

\ja{it should not be here, we are in section 'adding colors'}
Extended possibilities exist to define interaction. We will review them in a future section. For now, if you are interested in opening a system browser directly from a node, you define this interaction: \ja{can you display only the line concerned ? it is difficult to read each time the same code with only one line changed}

\begin{code}{}
view interaction action: #browse.
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: Collection withAllSubclasses.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

You can easily \ja{I think there are too much 'easy' or 'easily' in the chapter} spot some red node that do not have subclasses. This indicates a design flow since an abstract must to have subclasses. It makes no sense for a class that is not supposed to be instantiated (since it is abstract) to not have a subclass.

The very same analyzes can be realized on your own classes.

\ja{is this code useful ? it seems to be the same as above}

\begin{code}{}
view interaction action: #browse.
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: (PackageInfo named: 'Mondrian') classes.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

A shape may contains more than one condition. Let's distinguish abstract classes from classes that define abstract methods.

\begin{code}{}
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color lightRed;
  if: [:cls | cls methods anySatisfy: #isAbstract ] fillColor: Color red.

view nodes: Collection withAllSubclasses.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

All red nodes are still abstract classes. Light red indicates classes that do not define abstract methods; strong red indicates classes that define at least one abstract method.

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
