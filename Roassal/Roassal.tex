
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
    \DeclareGraphicsExtensions{.png,.jpg,.pdf,.eps,.gif}
	\newcommand{\fig}[4]{
		\begin{figure}[#1]
			\centering
			\includegraphics[width=#2\textwidth]{#3}
			\caption{\label{fig:#3}#4}
		\end{figure}}

	\newcommand{\largefig}[4]{
		\begin{figure*}[#1]
			\centering
			\includegraphics[width=#2\textwidth]{#3}
			\caption{\label{fig:#3}#4}
		\end{figure*}}
		
	\newcommand{\asdf}[4]{
		\begin{subfigure}[\label{fig:#3}]
                \centering
                \includegraphics[width=\textwidth]{#3}
                \caption{\label{fig:#3}#4}                
        \end{subfigure}}

\begin{document}
\fi
%=================================================================
%\renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Agile Visualization with Roassal}
\chalabel{roassal}


Giving a meaning to a a large amount of data is challenging without adequate tools. Textual outputs are known to be limited in their expression and interactions. 

Roassal is an agile visualization engine. It is made to visualize and interact with any arbitrary data, defined in terms of objects and their relationships. Roassal is commonly employed to produce interactive visualizations. Roassal is used by the Moose community to visualize software. This chapter introduces Roassal's principles and describes its expressive commands to quickly render your data. After its reading, you will be able to create interactive and visual representation.

For more information, please visit Roassal website: \url{http://objectprofile.com/roassal}

%=====================
\section{Installation and first visualization}
\sd{First we show how to load and get a first visualization.}

Roassal is available via a Metacello configuration. Just open a workspace and type:
\ja{we need a stable version before the publishing}
\begin{code}{}
Gofer new
	squeaksource: 'Roassal'; 
	package: 'ConfigurationOfRoassal';
	load.
(Smalltalk at: #ConfigurationOfRoassal) project lastVersion load.
\end{code}
\sd{having stable version would be better}


\subsection{A First Visualization}
\begin{code}{}
| view |
view := ROMondrianViewBuilder new.
view shape rectangle 
	width:  [ :cls | cls numberOfVariables * 5 ];  
	height: #numberOfMethods;
	linearFillColor: #numberOfLinesOfCode within:  Collection withAllSubclasses.
		
view interaction action: #browse.

view nodes: ROShape withAllSubclasses.
view edgesFrom: #superclass.
view treeLayout.
view open
\end{code}


\sd{add a screenshot}
%=====================

\section{Roassal Core Model}

\sd{may be explain Roassal is a frameworks, later we can customise it to support mondrian like DSL. }


Each Roassal visualization is an instance of the class \ct{ROView}, which is the container for all the data to be visualized.
Data is represented by instances of \ct{ROElement} that are added to the visualization. \sd{In general a visualization element is holding or referencing to a domain object, that we call its model and that is accessible via the model message.} %The data's value is stored in the \ct{model} instance variable.

\paragraph{Adding an element.} The following code creates and opens a visualization with a single element of 100 size:


\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element := ROElement new size: 100.
view add: element.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex1}
   \end{minipage}
\label{fig:ex1}
\end{figure}

However, by executing this code nothing appears in the visualization. The element is there but we haven't set how it should look like. The look of an element is given by shapes, instances of subclasses of \textbf{ROShape}. Let's add some shape (a border) to our element: \sd{why there is not a default shape and also @Empty}

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element := ROElement new size: 100.
element 
	+ ROBorder. "-> add shape"
view add: element.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex2}
   \end{minipage}
\label{fig:ex2}
\end{figure}

\paragraph{Adding a Shape.}
To add a shape to an element, we send the \ct{+} message with the wanted shape. For this example we added the \ct{ROBorder} shape. As its name suggests, \ct{ROBorder} adds a border to the \ct{ROElement}. By default, the color for a \ct{ROBorder} is black. There are several other shapes (such as \sd{}) that can be used and they can be composed to create more complex looks. \secref{shapes} details more on shapes and explains how to create more complex looks.

A \ct{ROElement} can also have interactions, allowing it to answer to events. For instance, they can be dragged by the mouse. To add an interaction to a \ct{ROElement} send the \ct{@} message with the interaction as parameter. \ct{RODraggable} allows an element to react to mouse drag. So let's make our element to be draggable. More about interactions is presented in \secref{interactions}.

\begin{code}{}
view := ROView new.
element := ROElement new size: 100.
element 
	+ ROBorder; "-> add shape"
	@ RODraggable. "-> add interaction"
view add: element.
view open.
\end{code}


\paragraph{More Elements.}
Visualizations are usually composed of more than one data value \sd{element?/data value does not fly}. You can add more elements to a \ct{ROView} by sending the message \ct{addAll:} with a collection of \ct{ROElements}. You can later access them by using the \ct{elements} accessor. \sd{the figure does not show the two boxes. strange on the paper version it does.}

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element1 := (ROElement new size: 100).
element2 := (ROElement new size: 50).
view addAll: (Array with: element1 with: element2).
view elements do: [:el | el + ROBorder; @ RODraggable].
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex3}
   \end{minipage}
\label{fig:ex3}
\end{figure}

By executing this code a visualization with two elements appears, both placed in the top left part. A ROElement can be translated using the \ct{translateBy:} or \ct{translateTo:} selector.
\sd{what are the axes?}

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
element1 := (ROElement new size: 100).
element2 := (ROElement new size: 50).
element2 translateBy: 150@150.
view addAll: (Array with: element1 with: element2).
view elements do: [:el | el + ROBorder; @ RODraggable].
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex4}
   \end{minipage}
\label{fig:ex4}
\end{figure}


\paragraph{Nesting Elements.}
When a visualization contains more than one element it is hard to setup each position by hand. Roassal provides defined layouts to arrange elements. A layout in Roassal is a subclass of \ct{ROLayout}. Layouts are explained in  \secref{layouts}.
A ROElement can also contain other ROElement's, creating nested elements. \sd{In addition as shown by the following example, the location of children is relative to the one of the parent. A translation is relative to the parent coordinates.} \sd{it would be good to translate the parent so that we show that the children are translated too. In addition you should show that a child can be translated relative to its parent.}



\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROView new.
parent := ROElement new 
				size: 100;
				+ ROBorder.
children := ROElement new 
				size: 50;
				+ ROBorder red.
parent add: children.
view add: parent.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{ex5}
   \end{minipage}
\label{fig:ex5}
\end{figure}

Finally, the ROElement model looks like \figref{ROElementModel}.

\fig{H}{0.5}{ROElementModel}{ROElement model}

%\vp{not sure if the camera should be explained here. What can be added here about the camera that helps you to build a visualization?}
A visualization \sd{view?} also answers to the \ct{translateBy:} and \ct{translateTo:} messages \sd{we do not answers to methods but to messages}. However, even if it looks like, is not the view which changes its position but its camera. The camera component of a view, represented by an instance of \ct{ROCamera}, is the point of view from which a visualization object is actually viewed. More about the ROCamera in \secref{camera}

\subsection*{The Collection hierarchy example}
\vp{I am not sure if this is the right order of if I will not add color}
As an example we will visualize the Collection hierarchy through the chapter. We will build it by executing the following steps:
\begin{enumerate}
\item Add all the data with no particular shape. In this case the data is the Collection class with all its subclasses;
\item make the classes look according to characteristics of each class;
\item add links between a class and its superclass;
\item arrange the elements as an hierarchy with a layout.
\end{enumerate}

In this section, we start with the first step: adding all elements corresponding to classes. \sd{can we have classElements in the script instead of data}
\begin{figure}[H]
\begin{code}{}
view := ROView new.
classes := ROElement forCollection: Collection withAllSubclasses.
classes 
	do: [:c | c + ROBorder.
			c @RODraggable ].
view addAll: classes.
ROHorizontalLineLayout new on: view elements.
view open.
\end{code}
\end{figure}

\fig{H}{0.6}{hier1}{Adding the elements representing classes}

The message \ct{forCollection:} sent to the class \ct{ROElement} is just a helper to build ROElements 
more easily from a collection. Each ROElement from the result is a representation of each element from the parameter. We add a border shape to each of them and make them draggable for easier manipulation.
Finally, to identify each element easily, we apply a default layout. More explanation of how layouts works will be explained later on. 

%=====================
\section{Shapes Detailled} \seclabel{shapes}

An element (instance of \ct{ROElement} can be shaped by sending the \ct{+} message with a shape (instance of \ct{ROShape} subclass) or with a \ct{ROShape} class. When sending the class as parameter, the element will be shaped with default values for each of its attributes. \sd{this sentence is unclear and what happen in the other case?}

Some of the shapes available are label (\ct{ROLabel}), border (\ct{ROBorder}), box (\ct{ROBox}) and circle (\ct{ROCircle}). By default, \ct{ROLabel} will display the data of the element associated as string, but it is also possible to set a custom text (\figref{label}). \sd{what about roassalString = printstring but the guy can change it?} When applying \ct{ROBorder}, \ct{ROBox} and \ct{ROCircle} to a ROElement, the shape will be adapted to the bounds of the element. It is also possible to set attributes as color, border color or border width to a shape. This is shown in \figref{border}, \figref{box} and \figref{circle}.
\sd{how can I display a label in addition to the box and the label is the printString of the model?}


\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
	ROElement new 
		size: 100; 
		+ (ROLabel text: 'hello!').	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{label}
   \end{minipage}
\caption{ROLabel}
\label{fig:label}
\end{figure}

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
	ROElement new 
		size: 100; 
		+ ROBorder.	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.25\textwidth]{border}
   \end{minipage}
\caption{ROBorder}
\label{fig:border}
\end{figure}  

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
ROElement new 
	size: 200; 
	+ (ROBox new 
				color: Color green; 
				borderColor: Color red; 
				borderWidth: 4 ).	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.5\textwidth]{box}
   \end{minipage}
\caption{ROBox}
\label{fig:box}
\end{figure} 

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
ROElement new 
	size: 100; 
	+ (ROCircle new 
				color: Color yellow; 
				borderColor: Color blue; 
				borderWidth: 2 ).	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.25\textwidth]{circle}     
   \end{minipage}
\caption{ROCircle}
\label{fig:circle}
\end{figure}



\paragraph{Composing Shapes.}
To create more complex looks we can compose shapes. To have an element shaped with more than one ROShape, we send the \ct{+} message several times with the desired shapes (\figref{composed}). This builds a chain of shapes associated to the element.
\sd{why do we need a cascade between shape? Is it key?}
\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}
     
ROElement new 
	size: 180;  
	+ (ROLabel new text: 'composed shape');
	+ (ROBorder new color: Color red); 
	+ (ROCircle new color: Color yellow; 
					borderWidth: 0 ).	\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{composed}
   \end{minipage}
\caption{Composing shapes}
\label{fig:composed}
\end{figure} 

\subsubsection*{The Collection hierarchy example}
We now will add some shape to the classes in the \ct{Collection} hierarchy example. Each class representation will have a width according to the number of instance variables of the class and a height according to the number of its methods. Obtaining a polymetric representation of the class.

\begin{code}{}
view := ROView new.
classes := ROElement forCollection: Collection withAllSubclasses.
classes do: [:c | 
	c width: c model instVarNames size.
	c height: c model methods size.
	c + ROBorder. 
	c @ RODraggable ].
view addAll: classes.
ROHorizontalLineLayout new on: view elements.
view open.
\end{code}

\fig{H}{0.6}{hier2}{Adding some shape for each class}


%=====================
\section{Edges: linking elements} \seclabel{edges}

In Roassal it is possible to build links between elements to represent relationships between them. A link between elements is an instance of the class \ct{ROEdge}. An edge needs two elements: one to be the starting point and another to be the ending point. It is important to notice than an edge also needs to be shaped. The following code shows a very simple example of how to build an edge between two elements.
\sd{why there is no default for ROEdge shape and a EmptyShape?}
\sd{why do you need to say new in ROEdge?}

\begin{figure}[H]
 \begin{code}{}
view := ROView new.
startElement := (ROElement on: 1) size: 20; + ROBorder red.
endElement := (ROElement on: 2)  size: 20; + ROBorder red.
endElement translateBy: 50@50.

edge := ROEdge from: startElement to: endElement.
edge + ROLine new. "-> an edge needs to be shaped too"
view 
	add: startElement; 
	add: endElement; 
	add: edge. "-> and to be added to the visualization"
view inspect.
\end{code}   
\caption{Simple edge}
\label{fig:simpleEdge}
\end{figure} 

There are several ways to shape a ROEdge. Some examples are shown in \figref{line}, \figref{arrowEdge} and \figref{orthoEdge}.

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + ROLine new. \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{line}
   \end{minipage}
\caption{Simple edge}
\label{fig:line}
\end{figure} 

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + (ROLine new add: ROArrow new). \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{arrowEdge}
   \end{minipage}
\caption{Arrowed edge}
\label{fig:arrowEdge}
\end{figure} 

\begin{figure}[H]
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
edge + (ROOrthoHorizontalLineShape new add: ROHorizontalArrow new)\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.4\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.4\textwidth]{orthoEdge}
   \end{minipage}
\caption{Orthogonal edge with horizontal oriented arrow}
\label{fig:orthoEdge}
\end{figure} 

\subsection*{The Collection hierarchy example}
Now we know how to make links between elements. With the following code we can create edges between each class to its superclass. To do so, we first need to create a collection of associations to build edges with them. Each association represents a starting point as the association key and an ending point as the association value. For this example each association goes from a \ct{ROElement} representing a class to a \ct{ROElement} that represents its superclass. After having the associations we create the instances of \ct{ROEdge} by using the \ct{linesFor:} selector.
\sd{the collect and select: sucks. why not simply using a do: and adding just what is needed.}

\begin{code}{}
view := ROView new.
classes := ROElement forCollection: Collection withAllSubclasses.
classes do: [:c | 
	c width: c model instVarNames size.
	c height: c model methods size.
	c + ROBorder. 
	c @ RODraggable ].
view addAll: classes.
associations := classes 
					collect: [:c | 	(c model superclass = Object)
										ifFalse: [ (view elementFromModel: c model superclass) -> c]]
					thenSelect: [:assoc | assoc isNil not ].
edges := ROEdge linesFor: associations.
view addAll: edges.
ROHorizontalLineLayout new on: view elements.
view open
\end{code}

\fig{H}{0.6}{hier3}{Adding links between each class and its superclass}

Now we have each class in the \ct{Collection} hierarchy with the shape we want and connected with each superclass. However we don't see a real hierarchy. This is because we need an appropriate layout to arrange all the elements of the view. Next section covers how to apply layouts to elements.


%=====================
\section{Layouts} \seclabel{layouts}
A layout defines how a collection of elements can be arranged automatically. Layouts inherits from the \ct{ROLayout} class. To apply a layout use the \ct{on:} message with a collection of \ct{ROElement}s as parameter, as shown in \figref{primerLayout}.


\begin{figure}[H]
\label{fig:primerLayout}
      \begin{minipage}[t]{0.5\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
view 
	addAll: (ROElement spritesOn: (1 to: 4)).
ROGridLayout on: view elements.
view open.
  \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.3\textwidth]{ROGrid2} %layout1?
   \end{minipage}

\caption{ROGridLayout applied to a group of ROElements}
\end{figure} 

The message \ct{spriteOn:} creates a collection of ROElements, each with size equals to 50, shaped with a red border and draggable. Some of the layouts available in Roassal can be seen in \figref{roLayouts}. \sd{How do I find the other layout availbale}

\begin{figure} [H]
        \centering
		\subfigure[ROGridLayout]{\includegraphics[width=0.15\textwidth]{ROGrid}} \hfill
		\subfigure[ROCircleLayout]{\includegraphics[width=0.15\textwidth]{ROCircle}}\hfill
		\subfigure[ROTreeLayout]{\includegraphics[width=0.11\textwidth]{ROTree}} \\ 
		\subfigure[ROMapTreeLayout]{\includegraphics[width=0.2\textwidth]{ROMapTree}} \hfill
		\subfigure[ROVerticalLineLayout]{\includegraphics[width=0.06\textwidth]{ROVertical}}\hfill
		\subfigure[ROHorizontalLineLayout]{\includegraphics[width=0.25\textwidth]{ROHorizontal}}
        \caption{Some of the layouts available applied to a group of elements}\label{fig:roLayouts}
\end{figure}


\paragraph{Layouts in Nested Structures.}
When dealing with nested ROElements, layouts can \sd{are?} be relative to each element container.

\begin{figure}[H]
      \begin{minipage}[t]{0.61\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
elements := (ROElement spritesOn: (1 to: 2)).
elements 
	do: [:el | el addAll: (ROElement spritesOn: (1 to: 3)). 
	           "arranging the children nodes"
			   ROGridLayout on: el elements.].			   
view addAll: elements.
ROHorizontalLineLayout on: view elements.
view open.
  \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{0.6\textwidth}
      \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.6\textwidth]{nestedLayout}
   \end{minipage}
\label{fig:nestedLayout}
\caption{Nested elements with different layouts }
\end{figure} 

\subsection*{The Collection hierarchy example}
\sd{would be nice to have an example showing that you have different layout for certain nodes.}
As we need an hierarchy, the \ct{ROTreeLayout} will be useful to obtain the visualization we want.
\sd{why do we have @ RODraggable and + ROBorder}

\begin{figure}[H]
\begin{code}{}
view := ROView new.
classes := ROElement forCollection: Collection withAllSubclasses.

"Make each element reflect their model characteristics"
classes do: [:c | 
	c width: c model instVarNames size.
	c height: c model methods size.
	c + ROBorder. 
	c @ RODraggable ].
view addAll: classes.

"Add edges between each class and its superclass (or its subclasseS)"
associations := classes collect: [:c | 
	(c model superclass = Object)
		ifFalse: [ (view elementFromModel: c model superclass) -> c]
	 ] thenSelect: [:assoc | assoc isNil not ].
edges := ROEdge linesFor: associations.
view addAll: edges.

"Arrange all the elements as a hierarchy"
ROTreeLayout new on: view elements.
view open
\end{code}
\end{figure}

We did it! :) \vp{<-ok, maybe remove this} The resulting visualization can be seen in \figref{collectionHierarchy}.

\fig{H}{0.4}{collectionHierarchy}{Collection class hierarchy with width reflecting instance variable number and height number of methods.}

%=====================

\section{Events and Callbacks}

Roassal allows any visible component in a visualization, including itself, to react to events. There are two kinds of events defined in Roassal. In the first kind are those responding to external events, like mouse clicks, mouse move or key press. The second kind of events includes those triggered by internal manipulation of the ROView or its components, like when a view needs to be refreshed. All events inherits from the \ct{ROEvent} class.

To see how events work, we define a visualization to react to mouse clicks, translating an element to where the click was made. 
There are several event classes to deal with mouse events: \ct{ROMouseClick}, \ct{ROMouseMove}, \ct{ROMouseEnter} and \ct{ROMouseLeave}, among others; and to deal with key pressing, the \ct{ROKeyDown} class.
We will make the visualization to react to the left click of the mouse using the \ct{ROLeftMouseClick} event. The reaction will create an animation to translate the element to the event position.


\begin{code}{}
view := ROView new.
el := ROElement sprite.
view add: el.
view 
	on: ROMouseLeftClick 
	do: [ :event | 
	        ROLinearMove new	for: el to: event position].
view open. 
\end{code}

We use the \ct{on:do:} message to set a Roassal object to react to an event. The first parameter must be the class of the expected event and the second one a block which defines the action to be executed when the event is received.

\ct{ROLinearMove} is one of the Roassal interactions. As its name suggest, it creates an animation for an element to be translated in a linear move. More about interactions are explained in next section.

%
%\alex{How to define callbacks}
%\alex{What are the different events we can handle}


%=====================
\section{The interaction hierarchy} \seclabel{interactions}

A ROElement can respond to events by setting callbacks or interactions. We already presented how to set callbacks, so here we will show the interactions. 

The root class of all Roassal interactions is \ct{ROInteraction}. An interaction is set to an element by sending the \ct{@} message with an instance of \ct{ROInteraction} as parameter. There are diverse interactions that can be set to a Roassal element \sd{such what?}.
 \ct{RODraggable} allows an element to be dragged by the mouse and \ct{ROGrowable} makes an element to increase its size when clicked. Try the following code. Click the element to make it bigger and drag it to move it on the view.

\begin{code}{}
|view element|
view := ROView new.
element := ROElement new size: 10.
element 
	+ ROBox;
	@ RODraggable; 
	@ ROGrowable.
view add: element.
view open.
\end{code}


Some interactions are more complex like popups elements, displayed when the mouse is over an element. 

%There are interactions that makes elements to react to events, such as \ct{RODraggable}, that allows an element to be dragged by the mouse, or \ct{ROGrowable}, that makes an element to increase its size when clicked. Some of this interactions are more complex like popups elements, accesible by the subclasses of \ct{ROAbstractPopup}, which are displayed when the mouse is over an element. 

\subsection{Animations} Animations are also interactions in Roassal. Some animations allows elements to be translated, like \ct{ROLinearMove}. \ct{ROZoomInMove} and \ct{ROZoomOutMove} zoom in or out, respectively. All animations are subclasses of \ct{ROAnimation}.

From the availables interactions in Roassal, two examples are presented: one for \ct{ROAbstractPopup} and one for \ct{ROAnimation}.

\subsubsection*{ROAbstractPopup}

\ct{ROAbstractPopup} allows elements to react to mouse over events by displaying a popup. There are two kind of popups, (i) \ct{ROPopup}, which by default displays a box with the string representation of the element value \sd{is printString used?}; and (ii) \ct{ROPopupView} that displays a custom view.

To add a popup to an element just send the \ct{@} message with the \ct{ROPopup} class as argument. It is also possible to setup a custom text using the \ct{text:} message with a custom string.
\sd{I do not understand ROElement spriteOn: 'Roassal'.}

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
el := ROElement spriteOn: 'Roassal'.
el @ ROPopup. "Or with custom text -> (ROPopup text: 'this is custom text')"
view add: el.
view open.
  \end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{popup}
   \end{minipage}
\label{fig:popup}
\caption{ROPopup}
\end{figure} 

\ct{ROPopupView} is slightly more complex as it needs the definition of the view to popup. This interaction can be created by sending the \ct{view:} message to the \ct{ROPopupView} class with the view to be displayed. The parameter can also be a block with one value to be evaluated with the element where the interaction belongs to. \sd{unclears}

The following example creates a view with five elements. Each one reacts when the mouse is over by displaying a popup. The popup is defined as a block which creates a view with the same amount of nodes as the element model where the mouse is. For example, and as \figref{popupView} shows, when passing the mouse over the node ``3'', a popup with \textit{three} gray boxes appears.
\sd{cool example!}
\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
     \begin{code}{}
view := ROView new.
elements := ROElement spritesOn: (1 to: 5).
"create the view to popup"
viewToPopup := [ :el | |v| 
	              	              v := ROView new.
	              	              "Add as much elements as the value represented"
	              	              v addAll: (ROElement forCollection: (1 to: el model)).
	              	              v elementsDo: [ :e | e size: 20; + ROBox ].
	              	              ROGridLayout on: v elements.
	              	              v ].
elements do: [ :e | e + ROLabel;  @ (ROPopupView view: viewToPopup)].
view addAll: elements.
ROHorizontalLineLayout on: view elements.
view open.
\end{code}
\end{minipage}\hfill\begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{popupView2}
   \end{minipage}
\label{fig:popupView}
\caption{\ct{ROPopupView} \sd{better title please}}
\end{figure} 


%first example
%view := ROView new.
%el := ROElement spriteOn: 'Roassal'.
%
%"create the view to popup"
%viewToPopup := ROView new.
%viewToPopup 
%	addAll: (ROElement forCollection: (1 to: 4 )).
%viewToPopup 
%	elementsDo: [:e | e size: 20. e + ROBox  ].
%ROGridLayout 
%	on: viewToPopup elements.
%	
%el := ROElement spriteOn: 'Roassal'.
%el @ (ROPopupView view: viewToPopup).
%view add: el.
%view open.


%
%\vp{not sure if present this one}
%\subsubsection*{ROMenuActivable}
%
%\begin{figure}[H]
%      \begin{minipage}[t]{1\textwidth}
%      \vspace{0pt}
%     \begin{code}{}
%view := ROView new.
%el := ROElement sprite.
%el @ (ROMenuActivable new item: 'inspect' action: #inspect).
%view add: el.
%view open.
%  \end{code}
%   \end{minipage}
%   \hfill
%   \begin{minipage}[t]{1\textwidth}
%	 \vspace{0pt} \raggedright
%       \centering
%		\includegraphics[width=0.7\textwidth]{menuActivable}
%   \end{minipage}
%\label{fig:menuActivable}
%\caption{ROMenuActivable applied to a ROElement}
%\end{figure} 

\subsubsection*{\ct{ROAnimation}}
Any animation is an instance of a subclass of the \ct{ROAnimation} class. Some examples are \ct{ROLinearMove}, \ct{ROZoomInMove} and \ct{ROZoomOutMove}.

Each animation has a number of cycles to complete, executing each one by sending the \ct{doStep} message.
A \ct{ROAnimation} also allows one to set a block to be executed after the animation is finished, using the \ct{after:} message. It is important to notice that any action to be done after the animation is finished must be set before the animation is triggered, otherwise it will not be executed. \sd{do you have a before: message.}

\figref{mouseClick} presents \ct{ROLinearMove}. The following code allows an element to be animated in a sin curve, using the \ct{ROFunctionMove}.

\begin{figure}[H]
\begin{code}{}
view := ROView new.

element := ROElement new.
element size: 10.
element + (ROCircle color: Color green).

view add: element.
element translateBy: 30@20.

ROFuncionMove new
	nbCycles: 360;
	blockY: [ :x | (x * 3.1415 / 180) sin * 80 + 50 ];
	on: element.
view open.
\end{code}
\end{figure}

%\alex{Present the hierarchy of the interaction}

%\alex{Give some examples with buttons and animations}


%=====================
\section{Understanding Camera} \seclabel{camera}

A view's camera represents the point of view from \sd{which} it is actually viewed. It has a position, where it is located on the visualization; an extent, which is what we are seeing; a real extent which represents the far extent and the window size of the visualization. A camera's directions is always perpendicular to the view. \sd{it would be good to have a diagram to show.}
\sd{what about a height method}

The extent of the view's camera affects the way a view is drawn in a canvas. When rendering a view, each point, rectangle or other shape that needs to be drawn will be plotted according to the camera extent. This is done by transforming each absolute position or size in \emph{virtual} points or rectangles relative to the camera's vision.

When \ct{translateBy:} or \ct{translateTo:} are called by a view, what actually happens is that its camera moves, no the visualization itself. And changing the altitude simulates the zooming facility of Roassal \sd{how can we change the altitude?}. By moving the camera down (\ie the view is zoomed in), it changes what will be shown: it defines a smaller rectangle that must be adapted to the real extent, and because of this making everything bigger.% the position and extent of the camera changes, defining smaller bounds and seeing everything bigger. 

This is used by the \ct{ROZoomMove}, which is used by \ct{ROZoomInMove} and \ct{ROZoomOutMove}. This is also used by the \ct{ROMiniMap} interaction.

The \ct{ROMiniMap} allows one to have a complete vision of a visualization for better navigation. It is composed of a smaller version of the visualization and a ``lupa'', which represents the current visible part of the view's window. To add this interaction, just send the \ct{@ROMiniMap} message to a view and press ``m'' to open it (\figref{miniMap}). \sd{how the communication between the MiniMap and the other view is done?}

\fig{H}{0.9}{miniMap}{\ct{ROMiniMap} applied to the Collection Hierarchy example}

The smaller version of the view is displayed by a \ct{ROMiniMapDisplayer}, subclass of \ct{ROViewDisplayer}. 
As their name suggest it, they are shapes that display a view on a ROElement. The difference between both is that \ct{ROMiniMapDisplayer} uses its own camera, which has a different extent to the view's camera. This allows \sd{one} to see the same view with different size. 

The lupa  size represents the visible part of the window and its position is related to the view's camera position. When the view is translated to a point, the lupa follows it by changing its position: the point representing the camera position is translated to a point on the \ct{ROMiniMapDisplayer} camera extent. And when the view is zoomed in or zoomed out the extent of the camera is changed, increasing o decreasing the lupa's size.

%\alex{MiniMap}
%\alex{Semantic zooming: Making objects appear when the camera goes down}

%=====================
\section{The Mondrian DSL}
\sd{Mondrian is an older visualization framework developed by D. Girba and M Meer and maintained by A. Bergel. It influenced the design of Roassal. It supports visualization scripting based on a dedicated DSL: the DSL is based on a stack model where elements on the top can be parametrized. Roassal is designed to be a flexible framework and it is not tight to a DSL. Now Roassal can be extended to support Mondrian-like DSL scripting. This is what we present in this Section.}


A \ct{ROMondrianViewBuilder} models the Mondrian DSL\footnote{\url{http://www.moosetechnology.org/tools/mondrian}}. It is mostly compatible with the original Mondrian language.% (cf., Mondrian paper and website).

%ROMondrianBuilder acts as a translation between the Mondrian DSL and the Roassal model.
A \ct{ROMondrianViewBuilder} internally contains an instance of a \ct{ROView}, called raw view. Its accessor is \ct{raw}. All scripting  using the \ct{ROMondrianViewBuilder} result in creating \ct{ROElement}s with the shapes and interactions set by the script, and added to the raw view. To start a visualization with the builder, you can use the following code:

\begin{code}{}
view := ROMondrianViewBuilder new.
view open.
\end{code}

A Mondrian builder can also be initialized with an instance of a ROView. However it is important to understand that this is not required, as the builder by default will create its own raw view.
When working with the builder, is it possible to use the Mondrian DSL, sending messages to an instance of the \ct{ROMondrianViewBuilder}, or directly with the raw view. %However the main benefit of the builder it to use the Mondrian scripting.

\begin{code}{}
rawView := ROView new.
view := ROMondrianViewBuilder view: rawView.
view open.
\end{code}

A small summary of the Mondrian DSL is offered here. To more detailed information, please refer to the dedicated Moose book chapter~\footnote{\url{http://themoosebook.org/book/internals/mondrian}}.

To add a node to the visualization, which be internally translated as a ROElement later on, use the selector \ct{node:} with the object you want to represent on the instance of the builder.

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROMondrianViewBuilder new.
view node: 1.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{mondrian1}
   \end{minipage}
\label{fig:mondrian1}
\end{figure} 




To define shapes, use the \ct{shape} message followed by the desired shape with its characteristics, before the node or nodes definition. This will locally define the shape for the nodes.

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROMondrianViewBuilder new.
view shape rectangle 
	size: 10;
	color: Color red.
view node: 1.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{mondrian2}
   \end{minipage}
\label{fig:mondrian2}
\end{figure} 


By using the \ct{nodes:} message with a collection of objects you can create several nodes.

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROMondrianViewBuilder new.
view shape rectangle 
	size: 10;
	color: Color red.
view nodes: (1 to: 5).
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{mondrian3}
   \end{minipage}
\label{fig:mondrian3}
\end{figure} 

If the node or nodes have nested nodes, use the \ct{node:forIt:} or \ct{nodes:forEach:} message to add them. The second parameter is a block which will add the nested nodes, as the following code shows:

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROMondrianViewBuilder new.
view shape rectangle 
	size: 10;
	color: Color red.
view 
	nodes: (1 to: 5) 	
	forEach:[:each |
		view shape rectangle 
			size: 5;
			color: Color yellow.
		view nodes: (1 to: 2).
	].
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{mondrian4}
   \end{minipage}
\label{fig:mondrian4}
\end{figure} 



%The shapes must be defined before the nodes definition.
%To define shapes, use the \#shape selector followed by the desired shape with its characteristics, before the node or nodes definition. This will locally define the shape for the nodes.

%\begin{code}{}
%view := ROMondrianViewBuilder new.
%view shape rectangle size: 20.
%view node: 1 forIt:[
%	view shape rectangle size: 20; color: Color red.
%	view nodes: (1 to: 3)
%].
%view open.
%\end{code}

It is possible to create edges by using the \ct{edgesFromAssociations:} message with a collection of associations between the model of the nodes.

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROMondrianViewBuilder new.
view shape rectangle 
	color: Color red.
view nodes: (1 to: 4).
view 
	edgesFromAssociations: (Array with: 1-> 2 with: 2 -> 3 with: 2 -> 4).
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{mondrian5}
   \end{minipage}
\label{fig:mondrian5}
\end{figure} 



Similar to the \ct{Collection} hierarchy example we need an appropriate layout. By default the builder applies a horizontal line layout and we need a tree layout. We use the \ct{treeLayout} to apply it.

\begin{figure}[H]
      \begin{minipage}[t]{1\textwidth}
      \vspace{0pt}
\begin{code}{}
view := ROMondrianViewBuilder new.
view shape rectangle 
	size: 10;
	color: Color red.
view nodes: (1 to: 4).
view edgesFromAssociations: (Array with: 1-> 2 with: 2 -> 3 with: 2 -> 4).
view treeLayout.
view open.
\end{code}
   \end{minipage}
   \hfill
   \begin{minipage}[t]{1\textwidth}
	 \vspace{0pt} \raggedright
       \centering
		\includegraphics[width=0.7\textwidth]{mondrian6}
   \end{minipage}
\label{fig:mondrian6}
\end{figure} 




\subsection*{The Collection Hierarchy example}

The Mondrian DSL allows a simpler scripting to the Collection hierarchy visualization than the one constructed through the chapter. By setting how each element and edge must be created, it is not necessary for us to create them by hand.
The following code can be replaced for the earlier version:

\begin{code}{}
view := ROMondrianViewBuilder new.
view shape rectangle
	width: [ :cls | cls instVarNames size ]; 
	height: [ :cls | cls methods size ].
view nodes: Collection withAllSubclasses.
view edgesFrom: #superclass.
view treeLayout.
view open.
\end{code}

%=====================
\section{Roassal Easel}


Pharo's World menu offers an item for launching the Easel. The easel is composed by two windows, the one on the left-hand side contains the visualization and the one in the right hand a workspace containing the script to be executed. By accepting (Cmd-S, Alt-S) in the editor, the changes will be displayed in the visualization window.

The easel offers lots of examples to see visualizations and learn how to make them, including a tutorial separated by steps. Examples are separated in two categories: \textbf{ROMondrianViewBuilder} and \textbf{ROExample}.

The first category includes examples done with the builder, using Mondrian DSL to make each script. The second one shows examples of how do directly interact with the \ct{ROView} class, making possible to reproduce them without the builder.

It also includes how to add buttons to zoom in and zoom out the visualization, export it to different formats and save it, among other actions. This buttons are not included by default in the Mondrian builder or the ROView, so the easel teach how to do it.
%=====================
\section{Beyond Pharo}

Roassal have been designed to be easily ported to other Smalltalk dialects. Currently it has been ported to VisualWorks, Amber and VA Smalltalk.

As \figref{structure} shows, Roassal consists in three main components:

\begin{itemize}
\item  The Roassal Core, a set of packages that contains all the main classes definition, like ROView, ROElement, ROShape and ROCamera. It also contains all the tests.
\item The Mondrian DSL, composed by the Roassal-Builder and Roassal-Builder-Tests packages.
\item The platform dependent packages, that is dedicated to each Smalltalk dialect Roassal is ported to.
\end{itemize} 

In top of this components, you application will be build.

In the platform dependent packages several classes must be implemented. The main ones are a native canvas class, where a view can be rendered, and a widget factory class, which can return an object to contain the canvas and receive and delegate all the external events.
The first must be subclass of ROAbstractCanvas and the second must be subclass of RONativeWidgetFactory.

The \ct{ROPlatform} class defines how the bridge between the core and the dependent packages must be implemented. This class defines instance variables, like \ct{canvasClass} and \ct{widgetFactory}, which store the correspondent class to use according to their name. Each platform dependent package must implement its own platform class, make it subclass of ROPlatform and reference all the implemented platform dependent classes.
Internally, every time one of this classes is needed, the core relies in the current instance of a ROPlatform to return the needed class.

\fig{H}{0.3}{structure}{Roassal structure}

%\alex{Describe the platform architecture}

%=====================

\section{Conclusion}

Roassal enables any graph of objects to be visualized. This chapter has reviewed the main features of Roassal:

\begin{itemize}
\item Create graphical elements
\item Shape them and make them look as desired
\item Make them react to events
\item Apply layouts to a view elements for them to be arranged automatically 
\item The builder to create a view using Mondrian DSL
\end{itemize}

\paragraph{Acknowledgment}
We are very grateful to Nicolas Rosselot Urrejola for his review of an early draft of the chapter.

%Mondrian is a perpetual evolving application. This chapter intents to cover the features frequently used. If there is a topic you wish to see discussed here, send an email to alexandre@bergel.eu.
%
%We hope you haved enjoyed it!
%
%=====================


%=============================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=============================================================


%Dead text:

Node color \ja{nothing about edge color ? I think we can say that it is possible too} is an important information support, as the width and the height of a node. Color should be easy to pick to represent particular condition.

The keyword if:fillColor: enables one to assign a color for a particular condition. Consider we want to extend the previous example by coloring abstract classes in red.

\begin{code}{}
view shape rectangle
  width: [ :each | each instVarNames size * 3 ];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: Collection withAllSubclasses.

view edges: Collection withAllSubclasses from: #yourself toAll: #subclasses.

view treeLayout.
\end{code}


The message \ct{if:fillColor:} may be sent to a shape to conditionally set a color. \ja{what is the link with the source code below ?}

\begin{code}{}
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: Collection withAllSubclasses.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

All red nodes represent abstract class. Waving the moose above a node make a text tooltip appear revealing its name. 

\ja{it should not be here, we are in section 'adding colors'}
Extended possibilities exist to define interaction. We will review them in a future section. For now, if you are interested in opening a system browser directly from a node, you define this interaction: \ja{can you display only the line concerned ? it is difficult to read each time the same code with only one line changed}

\begin{code}{}
view interaction action: #browse.
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: Collection withAllSubclasses.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

You can easily \ja{I think there are too much 'easy' or 'easily' in the chapter} spot some red node that do not have subclasses. This indicates a design flow since an abstract must to have subclasses. It makes no sense for a class that is not supposed to be instantiated (since it is abstract) to not have a subclass.

The very same analyzes can be realized on your own classes.

\ja{is this code useful ? it seems to be the same as above}

\begin{code}{}
view interaction action: #browse.
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color red.
view nodes: (PackageInfo named: 'Mondrian') classes.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

A shape may contains more than one condition. Let's distinguish abstract classes from classes that define abstract methods.

\begin{code}{}
view shape rectangle
  width: [ :each | each instVarNames size * 3];
  height: [ :each | each methods size ];
  if: #isAbstractClass fillColor: Color lightRed;
  if: [:cls | cls methods anySatisfy: #isAbstract ] fillColor: Color red.

view nodes: Collection withAllSubclasses.

view edgesFrom: #superclass.

view treeLayout.
\end{code}

All red nodes are still abstract classes. Light red indicates classes that do not define abstract methods; strong red indicates classes that define at least one abstract method.

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
