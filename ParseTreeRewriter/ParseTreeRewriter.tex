% $Author: ducasse $
% $Date: 2009-07-06 11:55:40 +0200 (Mon, 06 Jul 2009) $
% $Revision: 27889 $

% HISTORY:
% 2008-08-19 - Stef started chapter (outline only)
% 2011-09-11 - Migrated to PharoBox: svn checkout https://XXX@scm.gforge.inria.fr/svn/pharobooks/PharoByExampleTwo-Eng

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Checking and Transforming Programs with Rewrite rules}\chalabel{rewrite}




\section{Automatic manipulation of Code}




\section{Basic Knowledge on AST and other concepts}


\begin{code}{a Simple method}
< aPoint 
	"Answer whether the receiver is above and to the left of aPoint."

	^x < aPoint x and: [y < aPoint y]
\end{code}
	
	
\begin{code}{Getting the AST of a method}
( Point >> #<) parseTree
\end{code}	


\subsection{Basic on ProgramNodes and Subclasses}
Classes represent different nodes

ProgramNode is the superclass

Implement several useful methods: parent, nodesDo:, isVariable....



\subsection{Unification}
The pattern matchin algorithm in the parser tree rewriter is accomplished by a unification algorithm. This algorithm takes as input a tree (to search) and a pattern (a structure containing pattern variables).

The output of the algorithm is either False (there is no match found) or true and a set of assignments describing the variables. 

The set of assignments contains the values of the pattern variables that make the match between the tree and the pattern variables succeed. 

For example:
\begin{code}{}
self X matches self open if X = 'open'

X Y matches self open if X = 'self' and Y = 'foo'

X X does not match self open.
\end{code}



\section{Getting Started}

\begin{code}{Matching}
| className realClass replacer category |
className := #MyClass.
realClass := Smalltalk at: className.
category := #accessing.

\end{code}





If you really just want the string 'tabs', the string 'tabs' with the
quotes is the search expression.

If you want to find it as part of a substring use something along:
\begin{code}{}
   `#string `{ :node | node value isString and: [ node value
includesSubString: 'tabs' ] }

The `#string is a literal pattern (booleans, characters, arrays,
strings, numbers, ...) and `{ ... adds a constraint on the preceeding
match.
\end{code}



\begin{code}{}
| className realClass replacer category |

className := #MyClass.
realClass := Smalltalk at: className.
category := #accessing.

replacer := RBParseTreeRewriter new
				replace: '`receiver oldMessage' with: '`receiver newMessage';
				yourself.
(realClass organization listAtCategoryNamed: category)
	collect: [:sel |
		| parseTree |
		parseTree := ( realClass >> sel) parseTree.
		(replacer executeTree: parseTree)
			ifTrue: [ realClass compile: replacer tree newSource " [1] " ] ]

Now some questions:

1) In [1] "( RBClass existingNamed: className ) compileTree: replacer
tree" would be more appropiate? I get a MNU when evaluated with latest
AST/Refactoring.
2) The above script have some problems, if you want to get replaced

'this is a string' asString.

to

'this is a string' asText

it won't match. The same happens with: " self model asString " and
other patterns. 

answer>>>`#literal asString


How to modify the rewriter to match
oldMessage/newMessage at any point?

>>>``@obj oldMessage


i.e. [: tmp | anObject1 blabla1 blabla2 oldMessage blabla3 ]

Thanks in advance,
\end{code}


answer from lukas
\begin{code}{}
RBClass is a class private to the framework, you should never need to
instantiate it directly. And if you do, only through an instance of
RBNamespace that provides a delta to the current system state. In your
example you don't need to do that.

\end{code}

\section{Junk}

@@ here rules@@
 Pour vous en servir,
vous devez choisir les jeux de r\`egles que vous souhaitez appliquer
(dans le panneau, en haut à gauche), s\'electionner les r\`egles (panneau,
en bas à gauche), les cat\'egories (panneau du milieu), les classes
(panneau de droite), et finalement presser « Run ». Une fois que tout
est affich\'e, vous pouvez avoir acc\`es aux m\'ethodes suspectes en
cliquant sur les lignes qui d\'etaillent le r\'esultat.  Certaines
soci\'et\'es imposent aux d\'eveloppeurs d'invoquer syst\'ematiquement
SmallLint avant de d\'elivrer leur code. Notons que les r\`egles peuvent
en être particularis\'ees et qu'il est possible d'en ajouter de
nouvelles au jeu existant. La d\'efinition des r\`egles utilise la
reconnaissance de code (pattern matching) propos\'e par le RewriteTool
que nous allons maintenant \'etudier.

\section{Identification de code avec RewriteTool}

RewriteTool est un outil de r\'ecriture de code bas\'e sur la d\'efinition
de reconnaissance de formes (pattern matching), appliqu\'ee sur des
arbres de syntaxes abstraites. Une documentation plus compl\`ete est
disponible à http://st-www.cs.uiuc.edu/~brant/RefactoringBrowser/
Rewrite.html.

Il semble que Squeak ne dispose pas actuellement d'interface graphique
pour la r\'ecriture du code, mais uniquement pour identifier des
morceaux de code.


Cet outil de r\'ecriture de code est particuli\`erement utile lorsqu'on
doit transformer d'une mani\`ere r\'ep\'etitive du code. On peut repr\'esenter
dans les sch\'emas (patterns) de reconnais- sance des variables, des
listes, des instructions r\'ecursives et des litt\'eraux.

\begin{itemize}
\item	Variable. Un sch\'ema peut contenir des variables en utilisant
  le backquote ou accent grave. Ainsi, \ct{`key} repr\'esente n'importe
  quelle variable, mais pas une expression.

\item Liste. Pour repr\'esenter une expression potentiellement
  complexe, on utilise \ct{@} qui caract\'erise une liste. Ainsi, `@key
  peut repr\'esenter aussi bien une variable simple comme temp qu'une
  expression comme \ct{(aDict at: self keyForDict)}. Par exemple, | `@Temps
  | reconnaît une liste de variables temporaires. Le point . reconnaît
  une instruction dans une s\'equence de code.\ct{`@.Statements}
  reconnaît une liste d'instructions. Par exemple, foo `@message:
  \ct{`@args} reconnaît n'importe quel message envoy\'e à foo.


\item R\'ecursion. Pour que la reconnaissance s'effectue aussi à
  l'int\'erieur de l'expression, il faut doubler la quote. La seconde
  quote repr\'esente la r\'ecursion du sch\'ema cherch\'e. Ainsi,
  \ct{``@object foo} reconnaît foo, à quelque objet qu'il soit envoy\'e,
  mais observe \'egalement pour chaque reconnaissance si une
  reconnaissance est possible dans la partie repr\'esent\'ee par la
  variable \ct{``@object}.

\item	Litt\'eraux. \ct{\\#} repr\'esente les litt\'eraux ; ainsi, \ct{`\\#literal}
  reconnaît n'importe quel litt\'eral, par exemple 1, \ct{\\#()}, "unechaine"
  ou \ct{\\#unSymbol}.
\end{itemize}

\section{Des exemples d'identification de sch\'emas}

Si l'on veut identifier les expressions de type
aDict at: aKey ifAbsent: aBlock dans lesquelles les variables peuvent être des expressions compos\'ees, on \'ecrit l'expression
suivante :
\ct{``@aDict at: ``@aKey ifAbsent: ``@aBlock.}
Une telle expression identifie par exemple les expressions suivantes :

\begin{code}{}
instVarMap at: aClass name ifAbsent: [oldClass instVarNames]
deepCopier references at: argumentTarget ifAbsent: [argumentTarget]
bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]
object at: (keyArray at: selectionIndex) ifAbsent: [nil]
\end{code}

Comme l'interface en Squeak ne permet pas encore de s\'electionner les
classes sur lesquelles on veut travailler, le syst\`eme analyse les 1
934 classes et quelque 42 869 m\'ethodes qui sont disponibles dans la
distribution de base, ce qui peut sensiblement ralentir le traitement.

Voici quelques exemples d'
expressions qui pourraient être avantageusement transform\'ees :

\begin{code}{}
| `@Temps | ``@.Statements. ``@Boolean ifTrue: [^false]. ^true
| `@Temps | ``@.Statements. ^``@Boolean not
``@object not ifTrue: ``@block
``@object ifFalse: ``@block.
\end{code}


% RBParseTreeRewriter new
% 	replace: '``@aDictionary at: ``@key
% 		ifAbsent:
% 			[| `@Temps |
% 			``@.Statements.
% 			``@aDictionary at: ``@key put: ``@value]' with: '``@aDictionary at: ``@key
% 		ifAbsentPut:
% 			[| `@Temps |
% 			``@.Statements.
% 			``@value]';
% 	yourself

\begin{code}{}
rule := RBUnderscoreAssignmentRule new.
environment := BrowserEnvironment new forPackageNames: \#('PackageA'
'PackageB' ...).
SmalllintChecker runRule: rule onEnvironment: environment.
rule open
\end{code}

\begin{code}{}
ORLintBrowser
	openRule: (RBCompositeLintRule rules: (RBCompositeLintRule
rulesGroupedFor: RBSpellingRule) name: 'Spelling')
	environment: (BrowserEnvironment new forPackageNames: \#('Kernel'
'Collections-Abstract'))
\end{code}


%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: