<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- 	
	Cincom Smalltalk Community Blog
	Powered by Cincom Smalltalk
	http://smalltalk.cincom.com
	James A. Robertson, Vassili Bykov

	Structure:

       body
       	#container
			#header
			#main
				#content
					#posts
						.post *
					#referrers
				#menu
-->

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>

	
	
	
	
	
	
	
	
	
	
	

	

	

	
	
	
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">


	<style type="text/css" media="screen, projection">@import "css/cst-digest-blog.css";</style>
	<style type="text/css" media="print, handheld">@import "css/minimal.css";</style>


	<title>Cincom Smalltalk</title>



	<link rel="alternate" type="text/xml" title="RSS Feed" href="http://www.cincomsmalltalk.com/rssBlog/cincomsmalltalk.xml" />
	<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.cincomsmalltalk.com/rssBlog/cincomsmalltalk.xml" />
	<link rel="pingback" href="servlet/PingbackServlet" />

	<meta name="description" content="The best place to find out about Smalltalk" />
	<meta name="keywords" content="Smalltalk, OOP, Object, Object Technology, Object-Oriented Programming, VisualWorks, ObjectStudio, ParcPlace, Cincom, Linux, blog, Cincom Smalltalk" />
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<meta name="ICBM" content="39.214103, -76.878807" />
	<meta name="DC.title" content="Cincom Smalltalk" /> 

	<script language="JavaScript">
	<!--
	
	function sendMailTo(name, company, domain) {
	  locationstring = 'mai' + 'lto:' + name + '@' + company + '.' + domain;
	  window.location.replace(locationstring);
	}
	//-->
	</script>


    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
    <script type="text/javascript">
	    _uacct = "UA-298425-1";
	    urchinTracker();
    </script>


	<link rel="stylesheet" href="/css/lightbox.css" type="text/css" media="screen" />
	
	<script src="/js/prototype.js" type="text/javascript"></script>
	<script src="/js/scriptaculous.js?load=effects" type="text/javascript"></script>
	<script src="/js/lightbox.js" type="text/javascript"></script>


</head>


<body>

    <div id="container">

	<div id="header">
	<div class="watermark"></div>	
		
		<p id="communityblogs">
			<a href="/userblogs">Cincom Smalltalk Community Blogs</a>
		</p>
		<a href="/" title="Cincom Smalltalk Home">
		 	<div id="logo"></div>
		</a>
		
		
	
		<h1><a href="http://192.168.1.91/userblogs/cincom/blogView">Cincom Smalltalk</a></h1>
		<h2><a href="javascript:sendMailTo('jrobertson', 'cincom', 'com')">Smalltalk: It makes the hard things easy, and the impossible, possible</a></h2>
	
		<div id="blurb">
			<p><a href="digest" title="Cincom Smalltalk">Delivering Innovation Through Simplicity</a></p>
		</div>
	
		<p class="accessibility"><a href="#menu">Skip to Menu</a></p>

	</div> <!-- #header -->

	<div id="main">
	<div class="watermark"></div>	

		<div id="content">
		<div class="watermark"></div>	
		
			<div id="posts">	
			<div class="watermark"></div>	
				
			</div> <!-- #posts -->
			<p><a href="digestArchive">View Digest Archives</a></p>

			
			                        <P>Welcome to the another edition of the <I>Cincom Smalltalk            Digest</I>. The digest is a monthly newsletter designed to keep you aware of            Cincom Smalltalk products, services, and news to help the Smalltalk user community.            <a href="http://lm01.cincom.com/read/all_forums/subscribe?name=smalltalk_digest" target="_blank">            Click here</a> to subscribe.</p>            <p>To see a list of available Digests, <a href="digestArchive">click here</a>.</p>            <p align="center"><strong><a href="digest">July Digest</a></strong></p>                         <p align="center"><strong>Exceptions by Design:ANSI Standard Exception Handling</strong><br />  <em>By Vassili Bykov</em></p>  <p>All programs have to deal with errors and various unforeseen situations. Any reasonably complex operation may not run to a successful completion because of problems that may happen along the way. Detection, analysis, and recovery from errors is a vital part of any program.</p> <p>The ad-hoc approach to provide this functionality is to use designated values or <em>error codes</em> returned instead of the expected result when something goes wrong. This approach is popular in lower-level languages, but is occasionally used in Smalltalk as well. For example, the request to open a file in VisualAge returns an object that <em>may</em> be a stream. The caller is expected to send a message is<strong>CfsError</strong> to it to find out whether the result is a special error object indicating that there has been a problem opening the file, or is indeed a valid stream which the program can use.</p> <p>This approach is simple and straightforward, but is neither scalable nor convenient to use. The application code becomes polluted with the extra checks and branches to separate the "good" values from error codes and, when needed, to redirect control to the error handling code. The more complex the application and the greater the number of errors that can occur, the more work goes into maintaining this error handling infrastructure.</p> <p>This is the motivation for providing specialized error handling frameworks in various languages. The goal is to separate the "normal" code and the code that handles errors, and to eliminate the need to explicitly pass control and parameters from the <em>signaler</em> of the error (the code that detects the error) to the <em>handler</em> (the code that performs analysis and recovery). Usually, instead of "error", a more general term <em>exceptional situation</em>, or simply <em>exception</em> is preferred. With a typical exception handling framework, a program somehow defines a set of exceptional situations that can occur while it runs and associates blocks of code with particular kinds of error. These blocks, error handlers, are never explicitly invoked by the program. Instead, the error handling framework invokes them according to certain rules when it receives a notification from the program that an exceptional situation is detected.</p> <p>Several incompatible exception handling frameworks were introduced by various Smalltalk implementations before the introduction of the ANSI Standard. The framework specified by the standard is now implemented by VisualWorks 3.0 and Dolphin Smalltalk. The nicest thing about the ANSI exceptions, apart from their being the standard of course, is their very natural design that nicely fits the overall Smalltalk philosophy of "everything is an object". Because of that, in this article we will look at exceptions from a somewhat unusual perspective. It is a neither a classes-and-methods overview nor a how-to tutorial. Instead, we will pretend to design the framework from scratch, trying to reason what facilities it should include, and what rules it should follow.</p> <p><strong>The Big Picture</strong></p><p>As mentioned above, exception handling implies communication between two fragments of code: the signaler which is the fragment that detects an exceptional situation, and the handler which analyses the situation and decides how to recover from it.</p> <p>Because the purpose of exception handling is to hide any explicit error handling-related control transfers, signaling an exception should be a special operation that implicitly transfers control from the signaler to the handler. The following example is a sketch of how an exception would be detected and signaled in a hypothetical implementation of file streams:</p>   <p><blockquote>FileStream>>named: nameString   <br />&nbsp;&nbsp;&nbsp;filename := nameString asFilename.   <br />&nbsp;&nbsp;&nbsp;filename exists ifFalse: [...signal exception...].   <br />&nbsp;&nbsp;&nbsp;^FileStream withDescriptor: filename openDescriptor</blockquote></p><p>Even though the example is incomplete, it illustrates how using exceptions to handle errors separates the "normal" functionality from the error handling. We assume that signaling an exception puts in motion some language magic that takes control away from the signaler, and the <strong>ifFalse</strong> block never returns. Once the situation is "signaled away", the example concentrates on the normal actions which are to open the file with the given name (at this point, known to exist) and answer a <strong>FileStream</strong> with that descriptor. The user of this method will always receive a valid <strong>FileStream</strong> object, the exceptional (literally!) case of a non-existing file taken care of by the exception handling mechanism.</p> <p>For now, we will ignore exactly how an exceptional situation is signaled and instead consider the other part of the exception handling dialog &#150; the handler. </p><p>All Smalltalk control structures are implemented using blocks. A block is essentially a code fragment that we can pass around as an object. It is only natural to implement error handlers using blocks as well. What approach should we use to set a particular block as a handler for a particular exception?</p> <p>The simplest declaration of "from now on, use this block as a handler of this exception" would make a poor choice. We never actually need to set the handler indefinitely. Most often, we would write a handler to handle errors that occur while a particular fragment of code executes. Therefore, a better solution is to associate a handler with an exception only for the duration of execution of a certain code fragment, so that the handler is removed when the fragment finishes evaluating. To separate the fragment from the rest of the code, we can put it in a block of its own.</p>   <p><blockquote>[fileStream := FileStream named: nameString]   <br />&nbsp;&nbsp;on: ...file not found exception...   <br />&nbsp;&nbsp;do: [...handler actions...].   <br />&nbsp;&nbsp;fileStream nextPutAll: ...</blockquote></p> <p>We have not yet decided how a file not found exception is specified above and what a handler block looks like, but the example does illustrate the basic idea of establishing an exception handler. The first block in the example is evaluated. If a file not found exception is signaled during this time, evaluation is suspended and the handler block is invoked to recover from the error. The first block is also called a protected block because establishing a handler essentially protects it from a certain kind of error. Again, this example shows how the normal application logic, which assumes the fileStream variable always holds a valid instance of FileStream, is separated from the code responsible for handling an exceptional situation.</p> <p><strong>Exception Classes and Objects</strong></p><p>We have to be able to refer to exceptions by names to establish handlers or to signal their occurrences. Another useful thing would be to classify exceptions as generalizations or specializations of one another and to establish a handler on a generalized exception to handle occurrences of any specialization of that exception. For example, both <em>file not found</em> and <em>permission denied</em> could be specializations of <em>file access error</em>. A handler established on <em>file access</em> error would be invoked for occurrences of both <em>file not found</em> and <em>permission denied</em> signaled within the protected block. </p><p>This suggests that defining exceptions as classes would be a good thing to do. After all, since we have been talking about exceptional situations as something that occurs in programs, we might as well represent them as real objects. Here is how we can "objectify" exceptions.</p> <p>We will define different kinds of exceptions, such as division by zero and message not understood, as different classes. An exception which is a specialization of another exception is defined as a subclass of that exception. For convenience, we will provide a single root of the exception class hierarchy as a class named <strong>Exception</strong>.</p> <p>To establish a handler on an exception, we will refer to the class that represents that exception. </p><p>To signal an exception, we will create an instance of an appropriate exception class. That instance will represent the specific exceptional situation that has just occurred. Then we will send a message <strong>signal</strong> to the instance, which will activate the exception handling framework. The framework will find the proper handler and execute it.</p> <p>We can now refine the preceding example of signaling and handling a file not found exception. We assume there is a class <strong>FileNotFound</strong> defined somewhere in the <strong>Exception</strong> hierarchy.</p> <p>Signaling:</p>   <p><blockquote>FileStream>>named: nameString   <br />&nbsp;&nbsp;&nbsp;filename := nameString asFilename.   <br />&nbsp;&nbsp;&nbsp;filename exists ifFalse: [FileNotFound new signal].   <br />&nbsp;&nbsp;&nbsp;^FileStream withDescriptor: filename openDescriptor</blockquote></p><p>Handling:</p>   <p><blockquote>[fileStream := FileStream named: nameString]   <br />&nbsp;&nbsp;&nbsp;on: FileNotFound   <br />&nbsp;&nbsp;&nbsp;do: [...handler actions...].   <br />&nbsp;&nbsp;&nbsp;fileStream nextPutAll: ...</blockquote></p><p>At first glance, creating an exception object just to signal an exception may seem to be a waste. Why don't we allow signaling exceptions by sending a message <strong>signal</strong> to a class? Indeed, this is a convenient shortcut, and we will include it in the system, but the class-side <strong>signal</strong> will still create an instance of the class and then send the <strong>signal</strong> message to the instance. The reason we want to keep exception objects around is because we will shortly find more tasks that are naturally best handled by such objects. This is a good example of how a properly identified object gains substance in an OO system. This will happen as we take a closer look at what is involved in signaling and handling an exception.</p> <p>First of all, there is communication between the signaler and the handler. The signaler may want to provide extra information about the error for the handler to use. In our example, this information could be the name of the file that was not found. Because this information is part of the exceptional situation that has occurred in the program, it is only natural to make it an attribute of the exception instance representing that situation. This instance will be passed to the handler as the representation of the exception it is handling. (A handler should therefore be a one-argument block).</p><p>Revising our example, we would add an instance variable <strong>fileName</strong> and the usual accessor methods to <strong>FileNotFound</strong>, and change the code slightly.</p><p>Signaling:</p>   <p><blockquote>FileStream>>named: nameString   <br />&nbsp;&nbsp;&nbsp;filename := nameString asFilename.   <br />&nbsp;&nbsp;&nbsp;filename exists ifFalse:      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[FileNotFound new     <br /><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileName: nameString;</strong>          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;signal].   <br />&nbsp;&nbsp;&nbsp;^FileStream withDescriptor: filename openDescriptor</blockquote></p><p>Handling:</p>   <p><blockquote>[fileStream := FileStream named: nameString]   <br />&nbsp;&nbsp;&nbsp;&nbsp;on: FileNotFound   <br />&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex |     <br /><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"This is how we can get information from an     <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exception."     <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transcript show: 'File not found: ', ex fileName.</strong>     <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...more handler actions...]. <br />&nbsp;fileStream nextPutAll: ...</blockquote></p><p>Apart from exception-specific attributes such as <strong>fileName</strong> above, there is at least one attribute that every exception should have: a description. It is convenient to have a short descriptive message associated with an exception to use in debugging tools or error reports.</p> <p>To provide such a description, we'll assume that any exception has a <strong>messageText</strong> attribute. A signaler can set this attribute using either a <strong>messageText:</strong> accessing method, or by signaling the exception using <strong>signal: </strong>message and passing the description string as the argument. If no messageText is explicitly specified, it will be provided by an instance-side <strong>description</strong> message of an exception. </p><p><strong>Exception Handling</strong></p><p>When the exception framework is activated by a signaler, it searches for the handler by analyzing the program execution history. At any moment in time, the history is represented as a list of activation records, or contexts of methods and blocks that have sent a message and are now waiting for the answer. The head of the list is the context for the method or the block currently being executed. Each context holds invocation-specific information such as values of arguments and temporary variables, as well as a reference to the sender context. This chain of context starting with the one currently being executed is often called <em>the sender chain</em>.</p> <p>It is convenient to discuss program execution by showing the state of the sender chain at various moments of time and to draw the current context as the bottom-most, so that the contexts are arranged from top to bottom in the order they have been invoked.<p class='copy'> <p>For example, sending <strong>printString</strong> to a <strong>String</strong> is likely at some moment to have a sender chain similar to this:</p>    <p><blockquote>...    <br />&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String>>printString    <br />&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String>>printOn:    <br />&nbsp;|    <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String>>do:    <br />&nbsp;|    <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block in String>>printOn:    <br />&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Character>>printOn:</blockquote></p><p>The construct used to establish exception handlers</p>   <p><blockquote>&lt;protected block&gt; on: X do: &lt;handler block&gt;</blockquote></p><p>would have the following sender chain at the time when the protected block is being evaluated. (We assume the block's class is called <strong>Context</strong>. Depending on the Smalltalk dialect it could have a different name.): </p>   <p><blockquote>...    <br />&nbsp;|   <br />[ ]    <br />&nbsp;|   <br />[*]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context>>on:do:    <br />&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context>>value    <br />&nbsp;|   <br />[ ]    <br />&nbsp;|   <br />...</blockquote></p><p>We have marked the context for the <strong>on:do:</strong> message send with an asterisk to indicate that it is especially interesting for our purposes. The message arguments stored within this context are the exception class and the handler block for that exception. At the moment when an exception is signaled, the system will find this context and will check the arguments to see if the handler it establishes should be used for handling the exception. This, in fact, means that the <strong>on:do:</strong> method implementation might be as simple as this: </p>  <p><blockquote>Block>>on: exceptionClass do: handlerBlock   <br />&nbsp;&nbsp;&nbsp;&nbsp;^self value</blockquote></p><p>The only effect of this method would to create a context to be later recognized by the system as a holder of an exception and a handler for it. In this implementation, the sender chain doubles as the registry of currently established exception handlers. When the <strong>on:do:</strong> method returns, the corresponding context is removed from the chain, thus removing the handler it established before.</p> <p>Of course, any real implementation may be different. In our further discussion, we will not be concerned about the actual implementation of the <strong>on:do:</strong> method. The only important thing will be the fact that it establishes a handler before executing the protected block. To simplify our sender chain diagrams, we will sometimes use this shortcut representation of the use of <strong>on:do:</strong>     <p><blockquote>&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- X-[ ]    <br />&nbsp;|</blockquote></p> <p>The context on the chain corresponds to the protected block. We indicate on the right the handler on exception X established before the block execution. The context on the on:do: method is implied but not shown.</p> <p>Let us now suppose we have the following hierarchy of exception classes:</p>       <p><blockquote>&nbsp;&nbsp;&nbsp;A  <br />&nbsp;&nbsp;/&nbsp; \ <br />B   &nbsp;C</blockquote></p><p>and consider this sender chain diagram:</p>         <p><blockquote>&nbsp;&nbsp;|    <br />[1]  &nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;  B-[ ]    <br />&nbsp;&nbsp;|   <br />[2]    <br />&nbsp;&nbsp;|   <br />[3]  &nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;  A-[ ]    <br />&nbsp;&nbsp;|   <br />[4]  &nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;  C-[ ]    <br />&nbsp;&nbsp;|   <br />[5]  &nbsp;&nbsp;&nbsp;B signal</blockquote></p><p>The context [5] signals an exception <strong>B</strong>. By that time, three exception handlers have been established, the one on <strong>C</strong> most recently. Given the exception and these handlers, how should the system figure out which handler to run? Let's determine the rules the system should follow by analyzing what would be a reasonable thing to do.</p> <p>A handler is qualified to handle an exception that occurred only if the exception is a kind of exception the handler was established for. This is reasonable: if we establish a handler on <strong>FileError</strong>, it should handle any error which is a kind of <strong>FileError</strong>, and nothing else. In other words, a handler qualifies to handle an exception if the exception class it was established for is among the superclasses of the class of the signaled exception.</p> <p>Using this rule, we can select the applicable handlers among all the currently established ones. However, after doing so, we may end up with more than one handler. In the above example, exception <strong>B</strong> is signaled and both handlers established on <strong>A</strong> (a superclass of <strong>B</strong>) and <strong>B</strong> qualify to handle it. Which one should win? Intuitively, it should be the one "more relevant" to the signaled exception. The question is how to determine the relevance. There are two conflicting viewpoints.</p> <p>The signaled exception is an instance of <strong>B</strong>. <strong>B</strong> is a specialization of <strong>A</strong>, so the handler on <strong>B</strong> seems to be a better match.</p> <p>On the other hand, the <strong>B</strong> handler is located higher up the sender chain, meaning it was set sooner and will be removed later. Its "sphere of influence" covers a longer interval of the program execution time compared to the <strong>A</strong> handler. </p><p><blockquote>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exception <br />------+--------+-------*--------+----------+--------->       <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|---------|===========|------------|     <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B set    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A set          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A removed  &nbsp;&nbsp;&nbsp;B removed</blockquote></p><p>From this viewpoint, the <strong>A</strong> handler appears to be a "better fit" around the exception. So what is more important, exception classification or a handler extent?</p> <p>Remember what an expression like</p>   <p><blockquote>&lt;protected block&gt; on: A do: &lt;handler block&gt;</blockquote></p><p>is supposed to mean &#150; not in the technical terms of establishing a handler, but in terms of its purpose in the program. It means "while the code in the protected block runs, the handler block is responsible for recovery from any exception of kind <strong>A</strong>." When we have two conflicting handlers, the scenario that led to this is likely to have been as follows: The outer handler was established to catch errors that may occur in a relatively wide extent of the code. However, a more narrow portion of the code required a different approach to handling the same or overlapping set of errors, and for that purpose the inner handler was established. Now it is obvious that the handler for the more narrow portion of code should be used to handle the exception. In other words, it is the extent that determines a handler's relevance. In our original example, the handler for <strong>A</strong> should win because it has a more narrow extent, in spite of the fact that it handles a more general class of errors.</p> <p>We conclude that there are two kinds of specificity, depending on what part of exception handling we talk about. One is for exception classes, the other is for handlers. The former is determined by the exception class hierarchy and affects what handlers are selected to handle an exception. The latter is determined by the extent of a handler influence and affects which of several qualifying handlers is selected as the one to handle the exception.</p> <p>There is, however, one final point to be made from this discussion. Apparently, in a situation of several handlers with nested extents, a more specific "inner" handler, established to take care of certain peculiarities of the code for which it is responsible, might want to relinquish control to a more general enclosing handler if the exception that has occurred does not match the specifics the handler is designed to take care of. We will discuss such control transfers shortly, when we consider handler actions. For now, let us just keep in mind that even though the inner handler wins, the other applicable handlers may still be needed, so the system should keep them around.</p> <p>To summarize, here are the steps the system goes through to find a handler for an exception.</p> <p><ol><li>Find all the contexts on the sender chain that establish handlers. This essentially produces an ordered collection of contexts. (The handlers established by the contexts of that collection are called the <em>handler environment</em> of the signaled exception).  <li>Consider exception classes of all the contexts in the result. If the signaled exception is not a kind of the exception a context establishes a handler for, eliminate that context from the result.  <li>The remaining contexts hold all the relevant handlers. Assuming the sender chain was traversed from the exception originator, they are already sorted in order of relevance &#150; handlers on more narrow extents first.   <li>Invoke the first handler block on the list passing it the exception instance as the argument. Keep other handlers handy in case the original handler wants to pass control to the less specific ones. </ol></p><p>An important special case is what if we end up with an empty list of applicable handlers? It would make sense to let the exception itself decide what to do in such a case. If an exception has been signaled but no applicable handlers are found, as a last resort the system will send a message <strong>defaultAction</strong> to the signaled instance. All exceptions understand this message, and its default implementation <strong>Exception>>defaultAction</strong> usually opens a debugger.</p> <p><strong>Handler Actions</strong></p><p>Let us now consider what it means to handle an exception.</p> <p>One thing is obvious: in the handler, we may want to get more information about the exception before making any decisions on how to handle it. Because the exception object the handler receives is the reified exception, it holds all the relevant details. For example, an instance of <strong>MessageNotUnderstood</strong> has <strong>receiver</strong> and <strong>message</strong> attributes.</p> <p>When an error happens, what can we possibly do to recover?</p> <p>One option is to abort execution of the protected block altogether. Imagine we have to perform a sequence of actions to process a menu selection. In case of any error, we want to display a dialog box with an error message and then return from the menu action method as if nothing had happened, so the application would continue to run as usual. Suppose the menu action method looks like this:</p>   <p><blockquote>MyApplication>>fooMenuAction    <br />&nbsp;&nbsp;&nbsp;&nbsp;[self firstAction;    <br />&nbsp;&nbsp;&nbsp;&nbsp;self secondAction]      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: Error      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex |         <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dialog warn: 'An error has occurred: ', ex <br />messageText.        <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...]</blockquote></p><p>Assuming an error occurs within the <strong>firstAction</strong> message send, we want the handler to be able to abort execution of the protected block mid-way (so <strong>secondAction</strong> never runs) and then make the <strong>on:do:</strong> message send return as if the protected block ran to completion normally. It is fairly natural to implement this mechanism as a message sent to the exception instance. We will call it <strong>return</strong>. Just like <strong>signal</strong>, it is a special message: it does not return to the sender. Instead, the program continues running as if the <strong>on:do:</strong> message has just returned. Here is the complete example: </p>  <p><blockquote>MyApplication>>fooMenuAction    <br />&nbsp;&nbsp;&nbsp;&nbsp;[self firstAction    <br />&nbsp;&nbsp;&nbsp;&nbsp;self secondAction]      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: Error      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex |         <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dialog warn: 'An error has occurred: ', ex <br />messageText.       <br /><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex return]</blockquote></strong></p><p>It is interesting to trace the flow of control in this example. First, it follows the usual rules, going into the <strong>on:do:</strong> message send, then into the protected block, then into the <strong>firstAction</strong> message send. When the exception is signaled, control goes into the <strong>signal</strong> message send in the signaler and pops up inside the handler block. When the block sends <strong>return</strong> to the exception, control goes into this send and magically reappears as if the <strong>on:do:</strong> message returns.</p> <p>In other words, by sending <strong>return</strong> to the exception, the handler essentially says, "make it so that the <strong>on:do:</strong> message that established me returns". Every message returns an answer object, and we may agree that nil is returned from <strong>on:do:</strong> in this case. However, this suggests an improvement: a <strong>return:</strong> message that takes an object to return from the <strong>on:do:</strong> message. This may be necessary when we actually use the result of the protected block. Let's say we want to obtain a string with the contents of a file, or an empty string if the file is inaccessible for any reason. Here is a simple way to do this:</p>   <p><blockquote>&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;fileContents &nbsp;&nbsp;&nbsp;|  <br />&nbsp;&nbsp;&nbsp;&nbsp;fileContents := ['myfile.txt' asFilename readStream <br />contents]    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: Error    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex | ex return: String new]</blockquote></p><p>(If you noticed a bug in the example, congratulations).</p> <p>In terms of the sender chain diagram, <strong>return:</strong> cuts off and discards the "tail" of the chain before the <strong>on:do:</strong> context, and then returns the specified object to the <strong>on:do: </strong>sender context. </p>    <p><blockquote>&nbsp;&nbsp;&nbsp;|   <br />&nbsp;&nbsp;[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;enclosing method or block context&gt;  <br />----- CUT HERE   <br />&nbsp;&nbsp;[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context>>on:do:    <br />&nbsp;&nbsp;&nbsp;|   <br />&nbsp;&nbsp;[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context>>value    <br />&nbsp;&nbsp;&nbsp;|   <br />&nbsp;&nbsp;[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;protected block&gt;    <br />&nbsp;&nbsp;&nbsp;|</blockquote></p><p>Sometimes, aborting the action altogether is extreme. We may want to simply try something different, or even try the same action with different parameters. To make this possible, let's require the exception object to understand a message <strong>retryUsing:</strong>, with a block as the argument. When this message is sent, the system should abort execution of the protected block that caused a problem and then evaluate the block passed as the argument to <strong>retryUsing:</strong> as if it were the protected block in the original <strong>on:do:</strong>. Just like <strong>return</strong> and <strong>return:</strong>, <strong>retryUsing:</strong> message send does not return.</p>   <p><blockquote>&nbsp;&nbsp;&nbsp;&nbsp;| fileContents |  <br />&nbsp;&nbsp;&nbsp;&nbsp;fileContents := ['myfile.txt' asFilename readStream <br />contents]    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: Error    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex |      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| newName |      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newName := Dialog prompt: 'Problem reading <br />file.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Another name?'.      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex retryUsing: [newName asFilename <br />readStream&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contents]]</blockquote></p><p>This example (with the same bug as the previous one) is somewhat clumsy and can be rewritten based on the fact that the new protected block is essentially the same as the original one, except for the file name it uses. For just such cases, let us introduce the <strong>retry</strong> message. It is just like <strong>retryUsing:</strong>, but takes no argument because it simply restarts the original protected block. It is assumed that by the time the block is restarted, something has changed in the objects with which it works, so that this second time around the block has a better chance to succeed.</p>   <p><blockquote>&nbsp;&nbsp;&nbsp;&nbsp;| fileName fileContents |  <br />&nbsp;&nbsp;&nbsp;&nbsp;fileName := 'myfile.txt'.  <br />&nbsp;&nbsp;&nbsp;&nbsp;fileContents := [fileName asFilename readStream  <br />&nbsp;&nbsp;&nbsp;&nbsp;contents]    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: Error    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex |      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileName := Dialog prompt: 'Problem reading <br />file.  Another name?'.    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ex retry]</blockquote></p><p>In sender chain diagram terms, <strong>retryUsing:</strong> cuts off and discards the tail of the chain following the <strong>on:do:</strong> context and then starts growing a new chain, possibly using a new block, below the <strong>on:do:</strong> context.</p>     <p><blockquote>&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;enclosing method or block context&gt;    <br />&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context>>on:do:  <br />----- CUT HERE   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context>>value    <br />&nbsp;|   <br />[ ]    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;protected block&gt;<br />&nbsp;|</blockquote></p><p>The original <strong>on:do:</strong> context is preserved, meaning that the handler we established is still present during the new attempt. In the file reading example, if the new file specified by the user could not be successfully read, the handler would be invoked again.</p> <p>Let us now consider another example. Suppose that in our application, we often need to perform a collection of selectors on an object. Essentially, we need this method: </p>  <p><blockquote>Object>>performAll: selectorCollection  <br />selectorCollection do: [:each | self perform: each]</blockquote></p><p>However, there is a complication. Occasionally, there can be a selector in the collection that the object does not understand. This is allowed, and we would like simply to ignore such selectors. The following implementation seems to be reasonable. </p>  <p><blockquote>Object>>performAll: selectorCollection    <br />&nbsp;&nbsp;&nbsp;&nbsp;selectorCollection do:       <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:each |       <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self perform: each]        <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: MessageNotUnderstood        <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex | ex return]]</blockquote></p><p>However, looking closer, we may notice a problem. The handler we set will catch not only an exception caused by the receiver not understanding the current element in the collection, but also an exception resulting from a bug somewhere in the performed method. The handler we wrote will abort the attempt to perform the current selector and will move on to the next one regardless of the cause of the exception. This will simply hide programming errors in methods performed this way, something we do not want to do. To fix this, we want the handler to analyze the exception to see if it was indeed caused by the attempt to perform the current selector. If it was not, the handler should not do anything. Here is the corrected implementation. </p>  <p><blockquote>&nbsp;&nbsp;&nbsp;&nbsp;Object>>performAll: selectorCollection    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selectorCollection do:     <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[:each |     <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self perform: each]      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: MessageNotUnderstood      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex |        <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ex receiver == self and: [ex message selector 		<br />== each])          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifTrue: [ex return]          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifFalse: [ex pass]]]</blockquote></p><p>In our discussion of how a list of applicable handlers is determined when an exception is signaled, we mentioned that we first invoke the most recently established one. We must also keep all the others, however, because it may be useful to allow a handler to relinquish control to the next applicable one. The <strong>pass</strong> message does just that. It takes the next handler from the list of applicable handlers and invokes it. If there is no next handler on the list, the <strong>defaultAction</strong> message is sent to the exception instance. The <strong>pass</strong> action does not modify the sender chain in any way &#150; but the handler the control is passed to may do so. Like other messages we discussed in this section, pass is special &#150; it never returns to the sender.</p> <p>Now suppose that in our <strong>performAll:</strong> example we no longer want to ignore selectors not understood by the receiver. We do want to consider an occurrence of such a selector as an error. However, we want it to be signaled as one of our application-specific exceptions, let's say <strong>InvalidAction</strong>, rather than the generic <strong>MessageNotUnderstood</strong>. In other words, we want the ability to "resignal" a signaled exception as a different one. </p><p>It might seem that the solution would be to signal the new exception in the handler block. The handler block in our implementation of <strong>performAll:</strong> would be:</p>   <p><blockquote>&nbsp;&nbsp;&nbsp;&nbsp;[:ex |  <br />&nbsp;&nbsp;&nbsp;&nbsp;(ex receiver == self and: [ex message selector == <br />each])    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifTrue: [InvalidAction signal]    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifFalse: [ex pass]]</blockquote></p><p>A closer look reveals a subtle problem with this solution, however. Our original intent was to replace the occurrence of <strong>MessageNotUnderstood</strong> with <strong>InvalidAction</strong>. This replacement should have the effect as if <strong>InvalidAction</strong> was signaled in the same place in the program where the original <strong>MessageNotUnderstood</strong> was. Our solution signals <strong>InvalidAction</strong> in a different location. The difference in locations may lead to the difference in the set of applicable handlers. This is best shown using a sender chain diagram. Suppose that <strong>A</strong> and <strong>B</strong> are independent exceptions (that is, neither of them is a subclass of the other) and we have the following handlers established by the time exception <strong>B</strong> is signaled. </p>    <p><blockquote>&nbsp;&nbsp;|   <br />[1] -- A-[ ]    <br />&nbsp;&nbsp;|   <br />[2] -- B-[A signal]    <br />&nbsp;&nbsp;|   <br />[3] -- A-[ ]    <br />&nbsp;&nbsp;|    <br />[4] B signal</blockquote></p><p>The handler on <strong>B</strong> associated with context [2] decides that the specific exceptional situation should be resignaled as exception <strong>A</strong>. If this were the case, everything would happen as if there actually were "A signal" instead of "B signal" in the last context. The handlers on <strong>A</strong> associated with contexts [3] and [1] would be selected as the applicable ones, and the handler associated with [3] invoked first. Now, what happens if the <strong>B</strong> handler signals <strong>A</strong> right in the handler block? </p><p>In fact, this is something we have not yet considered at all. If an exception is signaled while executing a handler block, how are we supposed to handle it? What contexts should we consider when we select applicable handlers? An important choice to make is whether to consider the handlers established in the portion of the chain between the <strong>on:do:</strong> context that established the handler and the context that signaled the original exception (in our example, contexts [2], [3] and [4]).</p> <p>If we chose to do so, this would allow such handlers a chance to handle an error that occurred in the handler for the protected block. In other words, a portion of code that has a problem would try to fix a problem in the handler trying to fix the original problem. This sounds weird and before it gets too philosophical, let's just conclude this is not such a good idea.</p> <p>Instead, a solid alternative is to consider only the contexts above the <strong>on:do:</strong> context that established the handler, plus of course all the contexts related to the execution of the handler block (an exception could be signaled not in the handler block itself, but rather in one of the methods it invokes, and there could be more handlers established on the way from the handler context to the new exception context). </p><p>As an illustration, in the following diagram exception <strong>X</strong> is signaled, and while executing the handler for it (represented by a parallel sender chain), exception <strong>Y</strong> is signaled. According to the rule we have established, handlers [2] and [1] should be selected as applicable. Handler [3] should not be considered because it has been established in the portion of the sender chain we agreed to ignore.</p>  <p><blockquote>original sender chain B handler sender chain    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|   <br />&nbsp;&nbsp;&nbsp;&nbsp;[ ] -- Y-[1]    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|   <br />&nbsp;&nbsp;&nbsp;&nbsp;[ ] -- X-[ ] - - - - - > [ ]    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|   <br />&nbsp;&nbsp;&nbsp;&nbsp;[ ] -- Y-[3]             &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ ] -- Y-[2]    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                       |    <br />&nbsp;&nbsp;&nbsp;&nbsp;[X signal]               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Y signal]</blockquote></p><p>Coming back to our original example, if the <strong>B</strong> handler signals <strong>A</strong> immediately in the handler block, only the portion of the sender chain above the context [2] is searched for handlers, and only the handler associated with [1] runs. This is clearly not the same as what would happen if <strong>A</strong> were indeed signaled in place of <strong>B</strong>.</p> <p>To solve this problem, resignaling an exception should be a special action handled by the system. For this purpose, the system provides a message <strong>resignalAs:</strong>. The correct implementation of a handler block in our <strong>performAll:</strong> example should be </p>  <p><blockquote>&nbsp;&nbsp;&nbsp;&nbsp;[:ex |  <br />&nbsp;&nbsp;&nbsp;&nbsp;(ex receiver == self and: [ex message selector == <br />each])  <br />&nbsp;&nbsp;&nbsp;&nbsp;ifTrue: [<strong>ex resignalAs: InvalidAction</strong>]  <br />&nbsp;&nbsp;&nbsp;&nbsp;ifFalse: [ex pass]]</blockquote></p><p><strong>Resumable Exceptions</strong></p><p>So far, we have been considering an occurrence of an exception as a disaster so severe that the only options of recovery available were either abandoning the original attempt (<strong>return:</strong>), or trying something else (<strong>retryUsing:</strong>). (<strong>pass</strong> and <strong>resignalAs:</strong> are not really recovery options. They are merely the means for a handler to pass responsibility to other handlers).</p> <p>In some cases, such drastic measures are too much. Perhaps the exception is a condition of a more informative than emergency nature, and computation could safely be continued after it has been signaled. It is therefore useful to allow the handler to transfer control back to the signaler. To the handler, this transfer would look like yet another special message, resume, which does not return when sent to the exception instance. To the signaler, when the handler chooses this option, the control reappears from the signal message using which the exception was signaled. </p><p>For example, suppose that we read a file of configuration options, one option per line. If a line that cannot be parsed as a valid option is encountered, we want to give the user a choice between continuing reading the file or aborting.</p> <p>Here is the implementation, with the ubiquitous keep-awake bug: </p>  <p><blockquote>&nbsp;&nbsp;&nbsp;MyApplication>>readOptionsFrom: aStream    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| option |    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[aStream atEnd] whileFalse:      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[option := self parseOptionString. "nil if 	  <br />invalid"      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;option isNil        <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifTrue: [InvalidOption signal]        <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifFalse: [self addOption: option]]  <br /><br />&nbsp;&nbsp;&nbsp;MyApplication>>readConfiguration    <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[self readOptionsFrom: 'options' asFilename <br />readStream]      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on: InvalidOption      <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do: [:ex |        <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Dialog confirm: 'Invalid option line. Continue <br />loading?')          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifTrue: [ex resume]          <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifFalse: [ex return]]</blockquote> </p><p>If an invalid option line is encountered in <strong>readOptionsFrom:</strong>, the <strong>InvalidOption</strong> exception is signaled. If the handler in <strong>readConfiguration</strong> decides to resume, the signal message send in <strong>readOptionsFrom:</strong> returns and the execution continues.</p> <p>Of course, <strong>resume</strong> does not make sense for every possible exception. There is no reasonable way to resume a <strong>FileNotFound</strong> exception, for example. This is why we have to explicitly specify whether an exception is resumable. We do this by defining a method <strong>isResumable</strong> on the instance side of the exception class to answer true . In <strong>Error</strong>, <strong>isResumable </strong>is defined to return <strong>false</strong>, so by default errors are not resumable. If an exception is not resumable, it is illegal to send <strong>resume</strong> to it. </p><p>In addition to <strong>resume</strong>, there is also <strong>resume:</strong> which takes an argument. The object passed as the argument is returned from the <strong>signal</strong> message send in the signaler.</p> <p><strong>Exception Sets</strong></p><p>Finally, a facility worth mentioning is being able to associate a handler with more than one exception, when the exceptions a handler should intercept are not related to each other. To be able to do that, we introduce a new class, <strong>ExceptionSet</strong>, and allow it to use an exception set as the first argument of any <strong>on:do:</strong> message. A handler established this way is invoked if a signaled exception is a kind of any of the exception classes in the set.</p> <p>For convenience, there is an easily readable protocol to construct instances of <strong>ExceptionSet</strong>. Any exception responds to a binary message <strong>,</strong> (a comma) by creating and answering an <strong>ExceptionSet</strong> with two elements: itself and the message argument. An instance of <strong>ExceptionSet</strong> also understands this message by adding the argument to itself. This allows us to establish a handler on a group of exceptions using a very natural syntax:</p>   <p><blockquote>[...]  <br />on: MessageNotUnderstood, FileNotFound, ZeroDivide  <br />do: [...]</blockquote></p><p><strong>Odds and Ends</strong></p><p>Since the purpose of this discussion was not an exhaustive specification of ANSI exceptions, but rather a purpose-guided overview, we may stop here. A few details that have not been mentioned are described in the ANSI standard. They are mainly some other messages understood by exceptions and exception classes. These messages do not provide any radically new possibilities, and they easily fit into the overall picture presented in this overview.</p> <p>The standard specifies relatively few standard exception classes. This is why some of the exception names used in the examples are fictitious (for example, FileNotFound). </p><p>Some of the examples are distinctly VisualWorks-flavoured.</p> <p>Finally, the ubiquitous keep-awake bug was, of course, leaving a file open in a few of the examples. </p><br /><br /><hr><p><em>Vassili Bykov currently works for The Object People.  He is interested in advanced topics of programming language semantics.  You can reach him at <a href="mailto:vbykov@cincom.com">vbykov@cincom.com</a> to discuss this article or other topics.</em></p>           
			
		</div> <!-- #content -->
	
		<!--		THE MENU SECTION		-->
	
		<div id="menu">
		<div class="watermark"></div>	

	
		<!--		THE NAVIGATION MENU SECTION		-->

<ul>
<h2>Get Started</h2>
<li><a href="blogView?content=smalltalk">Download Now</a></li>
<li><a href="blogView?content=smalltalk_videos">Videos</a></li>
<li><a href="blogView?content=smalltalk_daily">Smalltalk Daily</a></li>
<li><a href="blogView?content=tutorials">Tutorials</a></li>
<li><a href="blogView?content=podcasts"><img src="http://www.cincomsmalltalk.com/images/podcasts.jpg" alt="podcasts" alt="Cincom Smalltalk Podcasts" title="Cincom Smalltalk Podcasts" /></a></li>
<li><a href="blogView?content=related">Related Links</a></li>
<li><a href="/userblogs/cincom/digest">Digest Online</a></li>
<li><a href="http://lm01.cincom.com/read/all_forums/subscribe?name=smalltalk_digest">Digest Email</a></li>
<li><a href="http://www.cincomsmalltalk.com/blog/blogView">Product Evangelist's Blog</a></li>
<li><a href="http://www.cincomsmalltalk.com/userblogs/arden/blogView">Product Manager's Blog</a></li>
</ul>

<ul>
<h2>News</h2>
<li><a href="blogView?content=events">Events</a></li>
<li><a href="blogView?content=blogNews">News</a></li>
</ul>

<ul>
<h2>Products</h2>
<li><a href="blogView?content=roadmap">Roadmap</a></li>
<li><a href="blogView?content=white_papers">White Papers</a></li>
<li><a href="http://www.cincomsmalltalk.com/userblogs/runarj/blogView?entry=3348279474">Scaling</a></li>
<li><a href="blogView?content=what_sets_cst_apart">What's Special?</a></li>
<li><a href="blogView?content=currentrelease">Current Release</a></li>
<li><a href="blogView?content=licensing">Licensing</a></li>
<li><a href="blogView?content=osfactsheet">ObjectStudio</a></li>
<li><a href="blogView?content=vwfactsheet">VisualWorks</a></li>
</ul>

<ul>
<h2>Support</h2>
<li><a href="http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Cincom+Smalltalk+Platform+Support+Guide">Support Info</a></li>
<li><a href="http://supportweb.cincom.com">Support Web</a></li>
<li><a href="blogView?content=ncVersions">NC Support</a></li>
<li><a href="blogView?content=downloadUpdates">Updates</a></li>
<li><a href="blogView?content=documentation">Documentation</a></li>
<li><a href="blogView?content=profServices">Services</a></li>
<li><a href="blogView?content=educationCourses">Education</a></li>
</ul>

<ul>
<h2>Community</h2>
<li><a href="http://www.cincomsmalltalk.com/userblogs">Blogs</a></li>
<li><a href="http://www.cincomsmalltalk.com/publicRepository">Store Index</a></li>
<li><a href="blogView?content=vwDeveloper">Developer's Program</a></li>
<li><a href="blogView?content=academic">Academic Program</a></li>
</ul>
		
	      </div> <!-- menu -->


	
      </div> <!-- #main -->

    </div> <!-- container -->

  </body>

</html>
<!-- Built with Cincom Smalltalk. http://www.cincomsmalltalk.com -->
