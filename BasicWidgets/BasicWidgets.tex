% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% HISTORY:


%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================

\chapter{Basic Widgets}

This chapter is about the basic window gadgets (aka widgets) used to compose graphical user interfaces in Pharo using Morphic. Since Morphic is based on a composite pattern,  you can easily assemble different widgets to build complex interfaces. We will explain how the essential widgets work and how to assemble them together. To help you understand the mechanisms behind Morphic, a single example will be used through the whole chapter.

\section{The window}
\index{Morphic!window}

\ja{explain the basis of Widget ? What is a widget in pharo ? Which classes should I know ? }

\subsection{Opening a window}
The basic class for managing a window is \clsind{StandardWindow}. Let's start with an empty one.

\dothis{To create and open an empty window just try the following:}

\begin{code}{}
StandardWindow new openInWorld
\end{code}
You should see a window with a top bar \ja{title bar ?} that you can move with the mouse (see \figref{fig:emptyWindow}). The text in the top bar is referred to as the window label.

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=6cm]{EmptyWindow}
	\caption{An empty window}
	\figlabel{fig:emptyWindow}
\end{center}
\end{figure} 

On one side, the topbar has three buttons for closing, collapsing and expanding the window. On the other side, the topbar has a menu button with a default set of items:

\begin{itemize}
\item Close, which closes the window
\item About, which displays the About window
\item Change title, which allows the user to set their own title for this window
\item Send to back, which puts this window behind all the others on the screen
\item Make next-to-topmost, which puts this window behind the window immediately behind it
\item Make closable/unclosable, which changes whether the window can be closed
\item Make draggable/undraggable, which controls whether or not the window is fixed in place
\item Maximize, which makes the window take up most of the screen
\item and Window color, which controls the default background color
\end{itemize}

These default menu items are added by \mthind{SystemWindow}{SystemWindow>>buildWindowMenu}, and in a moment we will learn how to extend this menu.

\subsection{A window and its model}
\index{Morphic!window model}

One of the first problems one runs into in developing graphical applications is the coupling of user interface code with application code. Proper object-oriented design promotes a separation of concerns: parts of the application that deal with the business logic should not also worry too much about what color font their text is rendered in. Every program with a UI must address this problem.

The early days of Smalltalk produced a novel solution to the problem of separating UI code from application code in the form of the Model-View-Controller design pattern. The idea is very simple:

\begin{itemize}
\item \emph{Models} represent the problem domain and the intelligence of the application
\item \emph{Views}  handle the visual representation of the model
\item \emph{Controllers} manage the interaction between the view and the model
\end{itemize}

We've come a long way since then, and Morphic simplifies the relationship, mostly removing the need for the controller \dkl{I have no idea if this is really true}. In Morphic, we instead deal with \emph{pluggable views}: views which manage themselves and delegate high-level responsibilities to a model that can be plugged into them. By specifying a model for a window, and implementing specific methods, the model will be able to control some of the window's behavior.

It's easy to set a model on a window:

\begin{code}{}
StandardWindow new model: myModel
\end{code}

\subsubsection{Example:}

First, let's create the model class:

\begin{classdef}{Defining a specific Model.}
Object subclass: #MyModel
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE2-Examples'

MyModel>>#initialExtent

	^ 200@200
\end{classdef}

Let's see the result:

\begin{code}{}
StandardWindow new openInWorld.
StandardWindow new model: (MyModel new); openInWorld.
\end{code}

You see a window with the same size as the previous one, and a small window whose size is exactly what you specified in the method \mthind{Morph}{initialExtent} (see \figref{fig:withAndWithoutModel}).

\sd{should we always specifies a model?}
\ben{If you want to specify the initial extent, either you define a model or you subclass (as far as I know)}
\sd{what should be put in the model vs. the Morph itself?}
\ben{I think/hope it will be clear when the API section will be complete}
\ja{if you are sure about your answers, just include them in the real text.}

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{WithAndWithoutModel}
	\caption{Two windows: one without a model and one with a model}
	\figlabel{fig:withAndWithoutModel}
\end{center}
\end{figure}
\ben{move that into Model API part}

You can also control whether or not the window can be closed by implementing \mthind{Model}{okToChange}:

\begin{method}{Define if the model is ok to change or not}
MyModel>>#okToChange

	^ false
\end{method}

Now the window doesn't close when you try to close it, because the model has explicitly stated that the widget is not OK to be changed.

\subsection{Your own topbar menu}

You can easily add shortcuts to the window's menu. Simply override the method \mthind{Object}{addModelItemsToWindowMenu: aMenu} and fill up the provided menu. For example:

\apl{addModelItemsToWindowMenu: is in Object !!}

\begin{method}{}
MyModel>>#addModelItemsToWindowMenu: aMenu
	"Add model-related items to the window menu"
	
	"First, we add a separator"
	aMenu addLine.
	
	"Then, we add our items"
	aMenu
		add: 'Label of the entry'
		target: receiverOfTheFollowingSelector
		action: #selectorWeWantToBeExecuted.

\end{method} 

\subsubsection{Example:}

\begin{method}{Define the extra entries of the menu}
MyModel>>#addModelItemsToWindowMenu: aMenu
	"Add model-related items to the window menu"
	super addModelItemsToWindowMenu: aMenu.
	aMenu addLine.
	aMenu
		add: 'Open an inspector on me'
		target: self
		action: #inspect.
\end{method}

When you click on the menu button, you see the new label at the end of the list (see \figref{fig:menuBar}) and when you click it, an inspector is opened (see \figref{fig:windowAndInspector}.)

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{MenuBar}
	\caption{Menu with our extra item at the end}
	\figlabel{fig:menuBar}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
	\includegraphics[width=7cm]{WindowAndInspector}
	\caption{An inspector is open}
	\figlabel{fig:windowAndInspector}
\end{center}
\end{figure}

\subsection{Main Window API}

\ja{some blahblah} Here is the list of the main API for a window:

\begin{itemize}
\item Title
\item Color
\item roundcorners?
\item minimumExtent: \dkl{these two methods exist but seem to do nothing}
\item maximumExtent:

\begin{code}{}
SystemWindow new
	maximumExtent: 200@100; openInWorld

pareil pour 

StandardWindow new
	unexpandedFrame: (0@0 extent: 200@100) ; openInWorld
\end{code}

je ne comprends pas pourquoi je peux alors avoir une fenetre immense? \ja{what ?}

\item unresizeable? \ja{what ?}
\item Action on close? \ja{what ?}
\end{itemize}

\paragraph*{About dialog.}

The SystemWindow will generate an About window for you. You can control the title by implementing \mthind{Model}{aboutTitle} and it will take the body of the class comment on your model as the text of the about dialog. For example:

\begin{figure}[ht]
\begin{center}
\includegraphics[width=9cm]{AboutDialog}
\caption{Customizing the About dialog}
\figlabel{fig:customizeAboutDialog}
\end{center}
\end{figure}

Other SystemWindow model delegate messages:

\begin{itemize}
\item \#initialExtent
\item \#modelWakeUpIn: aSystemWindow---sent when the window becomes active
\item \#modelSleep---sent when the window becomes inactive
\item \#windowIsClosing---sent during window deletion, before model is cleared
\item \#desiredWindowLabelHeightIn: aSystemWindow---sent during label creation
\item \#windowReqNewLabel: aString---sent by relabel

\item \#taskbarIcon
\item \#taskbarLabel

\item \#wantsStepsIn: aSystemWindow
\item \#stepAt: aMillisecondClockValue in: aSystemWindow---a step, sent if the model wants stepping
\item \#stepTimeIn: aSystemWindow---sent to request stepping at this interval
\end{itemize}

Additional StandardWindow model delegate messages:

\begin{itemize}
\item \#okToClose
\end{itemize}

\paragraph*{Title.}
\mthind{StandardWindow}{title:}
The default title of the window is simply 'Window'. You can change this title by sending \mthind{StandardWindow}{title:} to a window with a String as argument:
\begin{code}{}
w := StandardWindow new title: 'My first window'.
w openInWorld
\end{code}
\paragraph*{Position and size.}
In order to change the position and the size of a window, you can send the messages \mthind{StandardWindow}{extent:} and \mthind{StandardWindow}{position:} to a newly opened window. 
\needlines{4}
\begin{code}{}
w := StandardWindow new title: 'My first window'.
w openInWorld.
w extent: 100@50.
w position: 0@0
\end{code}
\dothis{Now try the following: first create a window but without opening it; then set its size and its position and then open it by sending \ct{openInWorld} to it.}
\needlines{4}
\begin{code}{}
w := StandardWindow new title: 'My first window'.
w extent: 100@50.
w position: 0@0
w openInWorld.
\end{code}
You should observe that the size and the position are not set with your values. Don't worry, you did nothing wrong, its a normal behavior regarding the way window opening is implemented in Morphic. In fact you have to know that a window internal state is overwritten with default values when it is opened. This is one of the responsibilities of \clsind{RealEstateAgent}. 


\section{Buttons}
\subsection{Push button}
Button is the simplest common GUI element. Button shows information what it will do by showing texts and images. Button sends message when clicked by the user. The simplest button is a button that shows nothing nor does anything.

\begin{code}{}
b := PluggableButtonMorph new openInWorld.
b bounds: (100@100 extent: 40@30).
\end{code}

\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=3.0cm]{SimpleButton}
	\caption{simple button}
	\figlabel{fig:simple button}
\end{center}
\end{figure}

If you click this button, you will notice the button does nothing. That's becuase we haven't told it what to do. We can set up the button to send a message to an object when it is clicked. The object who will receive a message is called "target" sometimes "model". For now it is called "model". The selector of the message is called "action". Let's set up the model and action, so the button itself be deleted when it is clicked. 

\begin{code}{}
b model: b.
b action: #delete.
\end{code}

\dothis{click the button}
 
 OK. The button is deleted. Since, block is an object and block is a chunk of operation that can be evaluated later. We can make a button do more complicated operations by setting model with a block and action with \clsind{\#value}.

\begin{code}{}
b := PluggableButtonMorph new openInWorld.
b bounds: (100@100 extent: 40@30).
b model: [ self inform: 'you pressed me' ].
b action: #value.
\end{code}
 
\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=3.0cm]{SimpleButtonInform}
	\caption{simple button with block}
	\figlabel{fig:simple button with block}
\end{center}
\end{figure}

To give our user some hint what the button will do, it will be nice put a label on the button.

\begin{code}{}
b label: 'press me'.
\end{code}

\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=3.0cm]{SimpleButtonWithLabel}
	\caption{simple button with label}
	\figlabel{fig:simple button with label}
\end{center}
\end{figure}
 
Let's delete the button and move on to the next subject.

\begin{code}{}
b delete.
\end{code}

Last button we played with had a label. But maybe our model for the button changed its state by pressing the button or by other events. User must be informed with correct information. Button has a getLabelSelector which is a selector used for asking the model what the new label should it be. To use getLabelSelector, we must send a message \ct{#on:getState:action:label:menu:}, which is a very typical form of method used in Morphic. It sets a bunch of requried selectors with its model. Put your model for keyword \ct{on:} and your button action for keyword \ct{action:} and \ct{getLabelSelector} for keyword \ct{#label:}.

Evaluate the code below in your workspace. You will see a button with label showing an OrderedCollection which is the model for the button.

\begin{code}{}
m := OrderedCollection withAll: {1. 2. 3. 4. 5}.

b := PluggableButtonMorph new openInWorld.
b addDependent: m.  
b bounds: (100@100 extent: 40@30).
b on: m getState: nil action: #myButtonAction label: #printString menu: nil.
\end{code}

Since we assigned the getLabelSelector with \ct{#printString}, label of the button will be the result of \ct{#printString} on m.

If you press the button, you will get a \ct{#dontUnderstandMessage:} error. That is because OrderedCollection does not have method myButtonAction. Define one as code below.

\begin{code}{}
myButtonAction

	self removeFirst.
	self changed: #printString.
\end{code}

Now if you press the button you will see the the m is being \ct{#removeFirst} and its label is updated. Button does not update the label of itself even though the \ct{getLabelSelector} is set. It need to be asked the update itself. To do that \ct{#changed:} in the \ct{#myButtonAction} method and \ct{#addDependent:} is used. To learn more about dependency system read section ....... \hjo{is there one?}

\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=3.0cm]{UpdatingButton}
	\caption{self updating button}
	\figlabel{fig:self updating button}
\end{center}
\end{figure}

Since the size of the collection is 5, more than five clicks, it will raise error. To avoid this, we need make it unpressable when collection gets empty. To do this, it is time to use \ct{#getEnabledSelector}. Set a selector that will be used for asking the model whether the button may be enabled. 

\begin{code}{}
b getEnabledSelector: #notEmpty.  
\end{code}

To trigger the enabling update, add another \ct{#changed:} send inside the \ct{#myButtonAction} method.

\begin{code}{}
myButtonAction

	self removeFirst.
	self changed: #printString.
	self changed: #notEmpty
\end{code}

\dothis{click the button more than 5 time}



\subsection{Checkbox}
Checkbox is a button that can show on and off state, and toggles it when clicked. Filled box means on state, empty box means off state. In Pharo, checkbox can be made with ThreePhaseButtonMorph or CheckboxButtonMorph.

\begin{code}{}
c := CheckboxButtonMorph new.
c openInWorld.
\end{code}

Send \ct{#selected:} message with boolean object to change its state.

\begin{code}{}
c selected: true.  "turn on"
c selected: false. "turn off"
\end{code}

If \ct{target}, and \ct{actionSelector} is set(setting \ct{arguments} is an option), checkbox can send message to its target.

\begin{code}{}
m := Morph new.
m openInWorld.

c :=  CheckboxButtonMorph new.
c openInWorld.
c target: m.
c actionSelector: #toggleCornerRounding.  
\end{code}



\subsection{Radio button}

Radio button in Pharo is sharing same classes with checkbox. Only difference is that it draws a circle than square box if it is sent a message \ct{beRadioButton}. It does not implement any behavior(logic) of radio button, so it is our responsibility to write a good radio button model object that makes sure only one button is turned on, and at least one button is turned on.

Pharo has a model class that is for demonstrating radio buttons, named \ct{ExampleRadioButtonModel}.

\begin{code}{}
radioModel := ExampleRadioButtonModel new.
r1 := (CheckboxMorph on: radioModel selected: #isLeft changeSelected: #beLeft)
		label: 'left'.
r2 := (CheckboxMorph on: radioModel selected: #isCenter changeSelected: #beCenter)
		label: 'center'.
r3 := (CheckboxMorph on: radioModel selected: #isRight changeSelected: #beRight)
		label: 'right'.
r1 openInWorld.
r2 openInWorld.
r3 openInWorld.
r1 bounds: (440@10 extent: 80@30).
r2 bounds: (440@40 extent: 80@30).
r3 bounds: (440@70 extent: 80@30).
\end{code}

As explained earlier, we are using the same class \ct{CheckboxMorph}, but it works perfectly as radio buttons. Radio buttons are asking the model whether they should turn themselves	on with selectors \ct{#isLeft}, \ct{#isCenter}, \ct{#isRight}. And when the user press the radio button it send message like \ct{#beLeft}, \ct{#beCenter}, \ct{beRight} to the model. Then the model sends message back to the buttons so the they turned on and off property.

Following codes will change their appearance, too.

\begin{code}{}
r1 beRadioButton.
r2 beRadioButton.
r3 beRadioButton.
2 timesRepeat: [
	r1 toggleEnabled.
	r2 toggleEnabled.
	r3 toggleEnabled.
].
\hjo{Hmm... Hope there is easier why to do this...}
\end{code}


Delete morphs after you are finished using them.

\begin{code}{}
r1 delete.
r2 delete.
r3 delete.
\end{code}

\section{Text fields}
\subsection{get text}
\subsection{set text}
\subsection{selection}

\section{Text editor}

\section{Panes and layout managing}
\subsection{newRow:}
\subsection{newColumn:}
\subsection{newGroup:}

\section{List widgets}
\subsection{getting list}
\subsection{getting selections}
\subsection{setting selections}

\hjo{outlining with subsections.}

\section{Tree widgets}
\subsection{getting list}
\subsection{getting selections}
\subsection{setting selections}
\subsection{collapsing and expanding}

\section{Layout management}
\index{Morphic!Layout management}

\ben{Maybe we should write a section about layouts to describe their API ?}
\sd{yes excellent idea. Do you know that luarent and hilaire wrote some text }
\ben{in fact, only TableLayout have a specific API}

A morph is basically a composite. As such it can be composed of sub-morphs. As it is explained below, adding a morph into a parent is very simple: just use the \mthind{Morph}{addMorph:} message which is sent to a parent morph with a sub-morph passed as argument. The problem is to understand how a morph can manage its own layout according to its size and the morphs that it contains. There are two main possibilities: (1) a morph can be added to another morph with a fixed position or (2) the placement of a morph is automatically managed with regards to its parent morph.

Of course, the second solution is predominantly chosen. In this case, a layout manager is to be used to manage the space of a morph. But one have to decide if the placement is managed from the parent-morph or from the sub-morph point of view:
\begin{description}
\item[top-down placement:] the placement is managed from the point of view of the parent morph which makes use of a layout manager that decides how to place the sub-morphs;
\item[bottom-up placement:] the placement is managed locally from the point of view of each sub-morph, the layout manager decides how to place a sub-morph according the parent extent.
\end{description}
Historically, these two possibilities are respectively provided by the \clsind{TableLayout} and by the \clsind{ProportionalLayout} classes. As it is explained in this chapter, each of these layout manager has its own variants and now a lot of possibilities are offered by the morphic framework.

%Adding a morph to another one is simple using the \ct{addMorph:} message. Now we often want to place a morph at a given place and in particular that the morph occupies space even if its container morph is resized. For that we use layout. Layout are objects that control how to morphs occupy space. Several layouts exist: proportional, 
\subsection{Composing a morph}
To add a morph into a parent morph, just make use of the \mthind{Morph}{addMorph:} message. Together with the use of the \ct{extent:} and of the \ct{position:} messages, it is straightforward to compose a morph.

\dothis{Declare a morph with a small extent and its parent with a bigger extent, then assign a color to the parent (different from blue), set the position of the parent, add the first morph to the parent and open the parent morph}

As an example, you can try with the following code:

\begin{code}
| sub parent |
sub := Morph new extent: 30 @ 30. "the sub-morph with a small extent"
parent := Morph new extent: 100 @ 80. "the parent morph with a bigger extent"
parent position: 10 @ 10; color: Color orange. "set the parent position and color"
parent addMorph: sub. "add the sub-morph"
parent openInWorld "open the parent morph"
\end{code}

\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=7cm]{composingMorph1}
	\caption{Composing a morph: a first try}
	\figlabel{fig:composingMorph1}
\end{center}
\end{figure}

The result is shown in \figref{fig:composingMorph1}. You may be surprised because the sub-morph is drawn outside it's parent. There are two reasons for this:
\begin{itemize}
\item first, you must recall that a particularity of the morph system is to consider a morph's position as an absolute one. Here, the sub-morph position is \ct{0@0} because it has not been explicitly changed. It implies that the sub-morph is drawn starting at the top left of the world.
\item second, the parent position has been set \textbf{before} the sub-morph has been added to it.
\end{itemize}

\dothis{To be convinced, try the same experiment but this time, set the parent morph before adding the sub-morph}

\begin{code}
| sub parent |
sub := Morph new extent: 30 @ 30. 
parent := Morph new extent: 100 @ 80. 
parent addMorph: sub. !\textbf{"add the sub-morph"}!
parent position: 10 @ 10; color: Color orange. !\textbf{"set the parent position after"}!
parent openInWorld 
\end{code}
The result of this second try is shown in \figref{fig:composingMorph2}.
\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=7cm]{composingMorph2}
	\caption{Composing a morph: a second try}
	\figlabel{fig:composingMorph2}
\end{center}
\end{figure}

For this second solution, the sub-morph is well physically inside its parent.

\dothis{Move the parent morph with the mouse or by sending to it the message \ct{position:} with a point as argument. Do this for the two solutions}

You can observe that the sub-morph is also moved whatever the solution you consider. If you inspect the sub-morph after having moved its parent you can see that its position has changed accordingly. So we can say that the sub-morph is logically in its parent but this doesn't mean that it is physically inside its parent. The reason why the second solution sub-morph is drawn inside its parent is only because the parent position has been changed after the sub-morph adding. 

The consequence is that if you want a submorph to be placed inside the area occupied by its parent then you have to explicitly calculate its position according to the parent position.

\dothis{Open the morph halo on the parent morph, then change the parent extent by clicking on the bottom right yellow button and moving the mouse around with the mouse button down. Do the same but with the sub-morph}

You observe that, if you change the parent morph extent, then the sub-morph extent stays unchanged and that you can make the parent morph smaller that its sub-morph. The same thing occurs if you change the sub-morph extent. It means that sub-morph and parent morph extents are managed independently.

So, if you want a morph extent to be changed according to a particular rule, for example according to a parent or a sub-morph extent change, then you have to implement it.

\dothis{To exercise yourself, try to implement the following: a red morph containing one row with three adjacent white sub-morphs, each containing itself a \ct{StringMorph} showing its position. see \figref{fig:composingMorph3}}.

\begin{figure}[htbp]
\begin{center}
	\includegraphics[width=7cm]{composingMorph3}
	\caption{Composing a morph with a row of sub-morphs}
	\figlabel{fig:composingMorph3}
\end{center}
\end{figure}
Here is a solution:
\begin{code}
| parent |
parent := Morph new color: Color red.
1 to: 3
 do: [:i | 	| sub |
	sub := Morph new color: Color white; borderWidth: 1; extent: 20 @ 20; yourself.
	sub addMorphCentered: (StringMorph contents: i asString).
	parent addMorph: sub.
	sub position: (Point x: i - 1 * sub width y: 0)].
parent openInWorld
\end{code}


Now, imagine that you want the parent morph extent to exactly fit its row extent, that you want to be able to add a sub-morph and have the parent morph extent updated accordingly. It is clear that one can't implement it like that. But don't be despaired of this, don't give up!.  Of course, there are many way do automatically manage morph positions and area extents as it is explained in next sections.


%On remarque que, bien que le morph bleu soit ajouté dans le morph orange, le morph bleu est visuellement à l'extérieur de l'orange. Par contre, si on déplace le morph orange, on déplace bien son contenu, le morph bleu, aussi. L'envoi du message #position: à un morph provoque le déplacement du morph et des morphs contenus. Le décalage observé entre nos deux morphs existe parce-que le message #position: a été envoyé au morph orange avant l'ajout du morph bleu.
%
%Quand on ajoute un morph dans un autre sans indiquer de position avec le message #position:, le morph est ajouté en position absolue 0@0. Si on ajoute un second morph, alors il recouvre le premier, toujours en position 0@0.
%
%La taille du morph orange peut être changée (à l'aide du halo par exemple) sans conséquence vis à vis du bleu. De même, la taille du bleu peut être changée sans conséquence vis à vis de l'orange.
%
%Dans Squeak, certaines IHM sont construites de cette façon (voir le panneau compilation de l'éditeur de Smacc) mais ce n'est pas à conseiller, l'utilisation de positions fixes rend difficile la maintenance et l'adaptabilité d'un tel code.
%
%Voici par exemple le code d'un morph contenant d'autres morphs dont la position est calculée de façon à constituer une ligne régulière :
%
%alig0
%	"MUIDAlignmentTest new alig0"
%	| alig sm |
%	alig := Morph new.
%	alig color: Color orange.
%	1
%		to: 3
%		do: [:i | 
%			alig addMorphBack: (sm := self cellMorphNamed: i printString).
%			sm
%				position: (Point x: i - 1 * sm width y: 0)].
%	alig openInWorld
%
%Les sous-morphs sont créés par la méthode suivante :
%
%cellMorphNamed: aString 
%	| m |
%	m := Morph new color: Color lightBlue;
%				 borderColor: Color black;
%				 borderWidth: 1;
%				 extent: 20 @ 20;
%				 yourself.
%	m
%		addMorphCentered: (StringMorph contents: aString font: Preferences windowTitleFont).
%	^ m
%
%Le résultat ci-contre montre que la largeur du morph orange contenant est inférieure à celle des morphs contenus ce qui n'est généralement pas souhaité. De plus, on ne peux pas facilement changer les positions des morphs contenus ou changer leur taille sans intervenir dans le code. La réactivité du morph est très limité et son amélioration nécessite beaucoup de codage lourd et non maintenable. Par exemple, pensez au modifications nécessaires pour que les morphs contenus soient tous séparés par un espace élastique qui augmente ou diminue suivant la taille du contenant orange. Ou encore, si on veut que la taille du contenant soient toujours en cohérence vis à vis des morphs contenus.



\subsection{With the default layout into a window}

This section  explains how to add morph into a window with the default layout.
\apl{Se serait mieux d'utiliser un parent Morph plutot qu'un Window}
The default layout is ProportionalLayout. To use it, you have to use the method \mthind{addMorph:frame:}{addMorph: aMorph frame: aFrame}
\begin{code}{}
aWindow
	addMorph: morphToAdd
	frame: (x0@y0 corner: x1@y1)
\end{code}
where x0, y0, x1 and y1 are defined as shown in  Figure~\ref{fig:frameExplanation}. Note that their values are floats between 0 and 1.

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{DefaultFrame}\includegraphics[width=6cm]{FrameExplanation}
	%\caption{How frames are defined}
	%\label{fig:defaultFrame}
	\caption{An example with a frame \ct{0@0 corner: 0.5@0.5}.}
	\label{fig:frameExplanation}
\end{figure}

\subsubsection{Some Morphs}
First, let's define some morphs to illustrate and experiment with.
\begin{code}{Objects definition}
| container redMorph blueMorph greenMorph |
redMorph := Morph new color: Color red; yourself.				
blueMorph := Morph new color: Color blue; yourself.
greenMorph := Morph new  color: Color green; yourself.
container := PanelMorph new.
\end{code}

We will not repeat their definition in the future except in the first code snippet so that you can 
get its full definition. 

\paragraph{A first configuration.}
The following snippet of code asks the red morph to occupy all the space of its container.
\begin{code}{}
| window |
window := SystemWindow new.
redMorph := Morph new color: Color red; yourself.	
window
	addMorph: redMorph
	frame: (0@0 corner: 1@1).
	
redMorph color: Color red.	
window openInWorld
\end{code}
Note: you have to reset the color of the morph after having added it because the window set the default color. Here it seems strange but for more complicated morphs (like buttons, list \dots) it sets the background color for a better integration.

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{SimpleLayoutExample1}
	\caption{The red morph fill the whole space.}
	\label{fig:simpleLayoutExample1}
\end{figure}

As a result, you can see that the red morph is stretched the fill the space both vertically and horizontally (see Figure~\ref{fig:simpleLayoutExample1}).


\paragraph{A little more complicated configuration.}
Now we add three morphs of different colors. 

\begin{code}{}
window
	addMorph: redMorph
	frame: (0@0 corner: 0.33@1).
window
	addMorph: blueMorph
	frame: (0.33@0 corner: 0.66@1).
window
	addMorph: greenMorph
	frame: (0.66@0 corner: 1@1).
\end{code}

As a result, you can see three stripes of color where each is horizontally a third of the window size and fills the space vertically (see Figure~\ref{fig:simpleLayoutExample2}).

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{SimpleLayoutExample2}
	\caption{Three color stripes}
	\label{fig:simpleLayoutExample2}
\end{figure}

Note that if you resize the window, proportions are kept. Also note that each stripe can be resized horizontally.

\paragraph{A last example.}
Now we change the configuration of 
\begin{code}{}
window
	addMorph: redMorph
	frame: (0@0 corner: 0.5@0.5).

window
	addMorph: blueMorph
	frame: (0.5@0 corner: 1@0.5).

window
	addMorph: greenMorph
	frame: (0@0.5 corner: 1@1).
\end{code}

As you may guess, the result is composed by two squares above a green rectangle (see Figure~\ref{fig:simpleLayoutExample3}).

\begin{figure}[ht]\centering
	\includegraphics[width=6cm]{SimpleLayoutExample3}
	\caption{Two squares above and a rectangle below}
	\label{fig:simpleLayoutExample3}
\end{figure}

Note that like for the previous example, you can resize each part. So basically, you now know everything about the default layout.


%----------------------------------------------------------------------------------------------
%
%				More Complicated Layouts
%
%----------------------------------------------------------------------------------------------


\subsection{More complicated layouts}

This section explains how to use different layouts and to use them to add morphs into another morph, which is a window or not.

Now that we have seen the default layout, we introduce you quickly the other layouts:
\begin{itemize}
	\item LayoutFrame
	\item RowLayout
	\item StackLayout
	\item TableLayout
\end{itemize}

\subsubsection{LayoutFrame}

This layout is used when you have to specified both a fix part \footnote{independent of the size of the window} and a proportional part\footnote{like the ProportionalLayout}.

This layout is used by example to add a toolbar.

To use this layout, you will have to use the method \mthind{addMorph:fullFrame:}{addMorph: aMorph fullFrame: aLayout} as follows:

\begin{code}{}
toolBarHeight := 100.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@0) "proportional part"
				offsets: (0@0 corner: 0@toolBarHeight)). "fix part"
				
				"Here, fractions: (0@0 corner: 1@0) means that the morph will fit the while width of the morph, but that the height is not dynamic (both y values are 0)"
				"and offsets: (0@0 corner: 0@toolBarHeight) means that the height is static and values toolBarHeight"
				
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@1) "proportional part"
				offsets: (0@toolBarHeight corner: 0@0)). "fix part"
				
	"Here fractions: (0@0 corner: 1@1) means that the moprh will	fit the whole container"
	"but offsets: (0@toolBarHeight corner: 0@0) precise that the top of the morph will always be at toolBarHeight from the top of the container"
\end{code}

As a result, you can see the red static part and the blue part which fill the space. When you resize the window, the red part will always stay the same (see Figure~\ref{fig:layoutFrame}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{LayoutFrame}
	\caption{Fix red part and dynamic blue part}
	\label{fig:layoutFrame}
\end{figure}

Here is another example showing the fixed sized bar at the bottom of the window.
\begin{code}{}
toolBarHeight := 100.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@1) "proportional part"
				offsets: (0@0 corner: 0@(toolBarHeight negated))). "fix part"
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0@1 corner: 1@1) "proportional part"
				offsets: (0@(toolBarHeight negated) corner: 0@0)). "fix part"
\end{code}

Here you can see that the fix part (the blue one) is below (see Figure~\ref{fig:layoutFrame2}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{LayoutFrame2}
	\caption{Fix blue part and red blue part}
	\label{fig:layoutFrame2}
\end{figure}

Let's try a bit more complicated example:
\begin{code}{}
toolBarHeight := 100.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 1@0.4) "proportional part"
				offsets: (0@0 corner: 0@0)). "fix part"
window
	addMorph: greenMorph
	fullFrame: (LayoutFrame
				fractions: (0@0.4 corner: 1@0.4)
				offsets: (0@0 corner: 0@toolBarHeight)).				
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0@0.4 corner: 1@1) "proportional part"
				offsets: (0@toolBarHeight corner: 0@0)). "fix part"
window openInWorld.
\end{code}

So now, the fix part is the green morph which stick in the middle of the window (see Figure~\ref{fig:layoutFrame3}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{LayoutFrame3}
	\caption{Dynamic red and blue parts and green fix part}
	\label{fig:layoutFrame3}
\end{figure}

\begin{figure}[!ht]\centering
	\includegraphics[width=6cm]{LayoutFrame4}
	\caption{Dynamic red and blue parts and green fix part}
	\label{fig:layoutFrame4}
\end{figure}

Of course, you can do the same vertically:
\begin{code}{}
toolBarWidth := 50.
window
	addMorph: redMorph
	fullFrame: (LayoutFrame
				fractions: (0@0 corner: 0.4@1) "proportional part"
				offsets: (0@0 corner: 0@0)). "fix part"				
window
	addMorph: greenMorph
	fullFrame: (LayoutFrame
				fractions: (0.4@0 corner: 0.4@1)
				offsets: (0@0 corner: toolBarWidth@0)).				
window
	addMorph: blueMorph
	fullFrame: (LayoutFrame
				fractions: (0.4@0 corner: 1@1) "proportional part"
				offsets: (toolBarWidth@0 corner: 0@0)). "fix part"
\end{code}

So the result is the same but vertically (see Figure~\ref{fig:layoutFrame4}).



\subsection{RowLayout}
The row layout is used to add submorphs in a single row where each submorph will be equally dispatched.

So let's try to use it. The message \ct{layoutPolicy:} specifies the new layout.
\begin{code}{}
window layoutPolicy: RowLayout new.

window 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.

window openInWorld.
\end{code}

As you can see, the window title bar is misplaced because it is added by the system using the same method once the layout has been changed (see Figure~\ref{fig:rowLayout1}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{RowLayout1}
	\caption{The title bar is misplaced}
	\label{fig:rowLayout1}
\end{figure}

To fix that, we will use a container instance of \ct{PanelMorph}.
\begin{code}{}
container := PanelMorph new.
container layoutPolicy: RowLayout new.
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

As you can see, it's a bit better, but the morphs do not fill the whole space (see FIG~\ref{fig:rowLayout2}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{RowLayout2}
	\caption{The title bar is well placed, but morphs do not fill the whole space}
	\label{fig:rowLayout2}
\end{figure}

So let's fix that using \ct{hResizing:} and \ct{vResizing:}. 

\begin{code}{}
container := PanelMorph new.
container layoutPolicy: RowLayout new.
redMorph
	hResizing: #spaceFill;
	vResizing: #spaceFill.
blueMorph
	hResizing: #spaceFill;
	vResizing: #spaceFill.
greenMorph
	hResizing: #spaceFill;
	vResizing: #spaceFill.
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

So for each submorph we have specified that both vertically and horizontally it should fill the space.
The result is what we have expected (see Figure~\ref{fig:rowLayout3}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{RowLayout3}
	\caption{Finally what we expected}
	\label{fig:rowLayout3}
\end{figure}

Note that contrary to the ProportionalLayout, here you can't resize any part.

\subsection{StackLayout}

\ben{I do not know how it works ... Should ask Igor}
\sd{or  may be we should drop it. Ask igor}

\subsection{TableLayout}
This layout is used to align submorphs following a row or a column and taking in account a direction.
So by default, the layout builds a column directed from top to bottom.
\begin{code}{}
container := PanelMorph new.
container 
	layoutPolicy: TableLayout new;
	listDirection: #topToBottom.
{ redMorph. blueMorph. greenMorph } do: [:each |
	each 
		hResizing: #spaceFill;
		vResizing: #spaceFill ].
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

So we obtain a column where any morph is dispatched equally (see Figure~\ref{fig:tableLayout1}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{TableLayout1}
	\caption{TableLayout by default}
	\label{fig:tableLayout1}
\end{figure}

Note that you can't resize any submorph and that you have add in order:
red, blue and green and you get 
green, blue and  red.

The explanation is that when you add a morph following the direction, it's done like in Tetris, you make them fall following the direction. But the direction is kept when there is space to keep.


The following example show a situation  where we do not force each morph to expand vertically
\begin{code}{}
container := PanelMorph new.
container 
	layoutPolicy: TableLayout new;
	listDirection: #topToBottom.
{ redMorph. blueMorph. greenMorph } do: [:each |
	each hResizing: #spaceFill ].
container 
	addMorph: redMorph;
	addMorph: blueMorph;
	addMorph: greenMorph.
window
	addMorph: container
	frame: (0@0 corner: 1@1).
window openInWorld.
\end{code}

Here you see that the space is kept below submorphs (see Figure~\ref{fig:tableLayout2}).

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{TableLayout2}
	\caption{The space is left below submorphs}
	\label{fig:tableLayout2}
\end{figure}

You can also experiment the other directions

\begin{figure}[ht]\centering
	\includegraphics[width=4cm]{TableLayout3}
	\caption{Bottom To Top}
	\label{fig:tableLayout3}
	\includegraphics[width=4cm]{TableLayout4}
	\caption{Left To Righ}
	\label{fig:tableLayout4}
	\includegraphics[width=4cm]{TableLayout5}
	\caption{Right To Left}
	\label{fig:tableLayout5}
\end{figure}


TableLayout is also good to get a FlowLayout using its \ct{wrapDirection}.
By flow layout we mean  which works the same way usually text is handled:
All submorphs are put on a single line and wrapped when the border is hit.

\hjo{Does reader know about UITheme here?}
\begin{code}{}
|builder|
builder := UITheme builder.
(builder newRow: {
   Morph new color: Color red.
   Morph new color: Color yellow.
   Morph new color: Color green.
   Morph new color: Color blue.
   Morph new color: Color orange})
      cellInset: 10;
      wrapDirection: #topToBottom;
      openInWindow
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=4cm]{FlowLayout}
	\caption{TableLayout can be used to implement FlowLayout To Left}
	\label{fig:tableLayout5}
\end{figure}


\newpage
\section{Some Examples}


I would like to create a Text Morph that wraps the text horizontally, and expands the height to fit the text. Thus, this morph would never offer scrolling. Figure~\ref{fig:paneMorph}.


\begin{code}{}
| textMorph |
textMorph := UITheme builder newText: ''.
textMorph
    hResizing: #spaceFill;
    borderWidth: 1.
(UITheme builder newColumn: {textMorph}) openInWindow.
textMorph contentsWrapped: 'Some text here

Get a halo and inspect the text morph
then use #contentsWrapped: to change text'
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=7cm]{paneMorph}
	\caption{PaneMorph}
	\label{fig:paneMorph}
\end{figure}


If I place this one in a surrounding pane / expander / tab, how do I get the surrounding morph to resize when the text changes? See Figure~\ref{fig:expanders}.

\begin{code}{}
|textMorph|
textMorph := UITheme builder newText: ''.
textMorph
    hResizing: #spaceFill;
    borderWidth: 1.
(UITheme builder newColumn: {
    UITheme builder newExpander: 'One' for: textMorph.
    UITheme builder newExpander: 'Two' for: Morph new}) openInWindow.

textMorph contentsWrapped: 'Some text here
use #contentsWrapped: to change text'
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=5cm]{expanded}\includegraphics[width=5cm]{expanded2}
	\caption{Two Expanders }
	\label{fig:expanders}
\end{figure}


In general, if the surrounding morph has \ct{#shrinkWrap} constraints then changes to the (minimum) dimensions of its submorphs will propagate resulting in a change of size for the surrounding morph.



\section{Conclusion}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
